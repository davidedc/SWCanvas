!function(){"use strict";class t{constructor(t,e,r,i=255,n=!1){if(t<0||t>255||e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("Color components must be in range 0-255");if(n)this._r=Math.round(t),this._g=Math.round(e),this._b=Math.round(r),this._a=Math.round(i);else{const n=i/255;this._r=Math.round(t*n),this._g=Math.round(e*n),this._b=Math.round(r*n),this._a=Math.round(i)}}static transparent(){return new t(0,0,0,0)}get premultipliedR(){return this._r}get premultipliedG(){return this._g}get premultipliedB(){return this._b}get premultipliedA(){return this._a}get r(){return 0===this._a?0:255===this._a?this._r:Math.round(255*this._r/this._a)}get g(){return 0===this._a?0:255===this._a?this._g:Math.round(255*this._g/this._a)}get b(){return 0===this._a?0:255===this._a?this._b:Math.round(255*this._b/this._a)}get a(){return this._a}toRGBA(){return[this.r,this.g,this.b,this.a]}toPremultipliedRGBA(){return[this._r,this._g,this._b,this._a]}get normalizedAlpha(){return this._a/255}get isTransparent(){return 0===this._a}get isOpaque(){return 255===this._a}withGlobalAlpha(e){if(e<0||e>1)throw new Error("Global alpha must be in range 0-1");const r=this.r,i=this.g,n=this.b,s=this.a,a=Math.round(s*e);return new t(r,i,n,a,!1)}blendOver(e){if(255===this._a)return this;if(0===this._a)return e;const r=1-this.normalizedAlpha,i=Math.round(this._r+e._r*r),n=Math.round(this._g+e._g*r),s=Math.round(this._b+e._b*r),a=Math.round(this._a+e._a*r);return new t(i,n,s,a,!0)}toBMP(){return{r:this.r,g:this.g,b:this.b}}toString(){return`Color(${this.r}, ${this.g}, ${this.b}, ${this.a})`}equals(e){return e instanceof t&&this._r===e._r&&this._g===e._g&&this._b===e._b&&this._a===e._a}}class e{constructor(t,e){if("number"!=typeof t||"number"!=typeof e)throw new Error("Point coordinates must be numbers");if(!isFinite(t)||!isFinite(e))throw new Error("Point coordinates must be finite numbers");this._x=t,this._y=e,Object.freeze(this)}get x(){return this._x}get y(){return this._y}static from(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Object must have numeric x and y properties");return new e(t.x,t.y)}distanceTo(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");const r=this._x-t._x,i=this._y-t._y;return Math.sqrt(r*r+i*i)}translate(t,r){return new e(this._x+t,this._y+r)}add(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return new e(this._x+t._x,this._y+t._y)}subtract(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return new e(this._x-t._x,this._y-t._y)}scale(t){if("number"!=typeof t)throw new Error("Scale factor must be a number");return new e(this._x*t,this._y*t)}scaleXY(t,r){if("number"!=typeof t||"number"!=typeof r)throw new Error("Scale factors must be numbers");return new e(this._x*t,this._y*r)}rotate(t){if("number"!=typeof t)throw new Error("Angle must be a number");const r=Math.cos(t),i=Math.sin(t);return new e(this._x*r-this._y*i,this._x*i+this._y*r)}rotateAround(t,r){if(!(t instanceof e))throw new Error("Center must be a Point instance");return this.subtract(t).rotate(r).add(t)}get magnitude(){return Math.sqrt(this._x*this._x+this._y*this._y)}get magnitudeSquared(){return this._x*this._x+this._y*this._y}normalize(){const t=this.magnitude;return 0===t?new e(0,0):new e(this._x/t,this._y/t)}dot(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return this._x*t._x+this._y*t._y}cross(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return this._x*t._y-this._y*t._x}round(){return new e(Math.round(this._x),Math.round(this._y))}floor(){return new e(Math.floor(this._x),Math.floor(this._y))}ceil(){return new e(Math.ceil(this._x),Math.ceil(this._y))}clamp(t,r,i,n){return new e(Math.max(t,Math.min(i,this._x)),Math.max(r,Math.min(n,this._y)))}lerp(t,r){if(!(t instanceof e))throw new Error("Target must be a Point instance");if("number"!=typeof r||r<0||r>1)throw new Error("Interpolation factor must be between 0 and 1");return new e(this._x+(t._x-this._x)*r,this._y+(t._y-this._y)*r)}toObject(){return{x:this._x,y:this._y}}toArray(){return[this._x,this._y]}equals(t,r=1e-10){return t instanceof e&&Math.abs(this._x-t._x)<r&&Math.abs(this._y-t._y)<r}isOrigin(t=1e-10){return Math.abs(this._x)<t&&Math.abs(this._y)<t}toString(){return`Point(${this._x}, ${this._y})`}}class r{constructor(t,e,r,i){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("Rectangle parameters must be numbers");if(!(isFinite(t)&&isFinite(e)&&isFinite(r)&&isFinite(i)))throw new Error("Rectangle parameters must be finite numbers");if(r<0||i<0)throw new Error("Rectangle dimensions must be non-negative");this._x=t,this._y=e,this._width=r,this._height=i,Object.freeze(this)}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this._x}get top(){return this._y}get right(){return this._x+this._width}get bottom(){return this._y+this._height}static boundingBox(t){if(!Array.isArray(t))throw new Error("Points must be an array");if(0===t.length)return new r(0,0,0,0);for(const r of t)if(!(r instanceof e))throw new Error("All items must be Point instances");let i=1/0,n=1/0,s=-1/0,a=-1/0;for(const e of t)i=Math.min(i,e.x),n=Math.min(n,e.y),s=Math.max(s,e.x),a=Math.max(a,e.y);return new r(i,n,s-i,a-n)}get center(){return new e(this._x+this._width/2,this._y+this._height/2)}get area(){return this._width*this._height}get perimeter(){return 2*(this._width+this._height)}get isEmpty(){return 0===this._width||0===this._height}get isSquare(){return this._width===this._height&&this._width>0}toString(){return`Rectangle(${this._x}, ${this._y}, ${this._width}, ${this._height})`}}class i{constructor(t){if(t&&Array.isArray(t)&&6===t.length){for(let e=0;e<6;e++)if("number"!=typeof t[e]||!isFinite(t[e]))throw new Error(`Transform2D component ${e} must be a finite number`);this.a=t[0],this.b=t[1],this.c=t[2],this.d=t[3],this.e=t[4],this.f=t[5]}else{if(t&&void 0!==t.length)throw new Error("Transform2D initialization array must have exactly 6 elements");this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0}Object.freeze(this)}static translation(t,e){return new i([1,0,0,1,t,e])}static scaling(t,e){return new i([t,0,0,e,0,0])}static rotation(t){const e=Math.cos(t),r=Math.sin(t);return new i([e,r,-r,e,0,0])}multiply(t){if(!(t instanceof i))throw new Error("Can only multiply with another Transform2D");return new i([this.a*t.a+this.b*t.c,this.a*t.b+this.b*t.d,this.c*t.a+this.d*t.c,this.c*t.b+this.d*t.d,this.e*t.a+this.f*t.c+t.e,this.e*t.b+this.f*t.d+t.f])}translate(t,e){const r=i.translation(t,e);return this.multiply(r)}scale(t,e){const r=i.scaling(t,e);return this.multiply(r)}rotate(t){const e=i.rotation(t);return this.multiply(e)}invert(){const t=this.a*this.d-this.b*this.c;if(Math.abs(t)<1e-10)throw new Error("Transform2D matrix is not invertible (determinant ≈ 0)");return new i([this.d/t,-this.b/t,-this.c/t,this.a/t,(this.c*this.f-this.d*this.e)/t,(this.b*this.e-this.a*this.f)/t])}transformPoint(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Point must have numeric x and y properties");return{x:this.a*t.x+this.c*t.y+this.e,y:this.b*t.x+this.d*t.y+this.f}}transformPoints(t){return t.map(t=>this.transformPoint(t))}toArray(){return[this.a,this.b,this.c,this.d,this.e,this.f]}get isIdentity(){return 1===this.a&&0===this.b&&0===this.c&&1===this.d&&0===this.e&&0===this.f}get determinant(){return this.a*this.d-this.b*this.c}equals(t,e=1e-10){return t instanceof i&&Math.abs(this.a-t.a)<e&&Math.abs(this.b-t.b)<e&&Math.abs(this.c-t.c)<e&&Math.abs(this.d-t.d)<e&&Math.abs(this.e-t.e)<e&&Math.abs(this.f-t.f)<e}toString(){return`Transform2D([${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e}, ${this.f}])`}}class n{constructor(){this.commands=[]}closePath(){this.commands.push({type:"closePath"})}moveTo(t,e){this.commands.push({type:"moveTo",x:t,y:e})}lineTo(t,e){this.commands.push({type:"lineTo",x:t,y:e})}bezierCurveTo(t,e,r,i,n,s){this.commands.push({type:"bezierCurveTo",cp1x:t,cp1y:e,cp2x:r,cp2y:i,x:n,y:s})}quadraticCurveTo(t,e,r,i){this.commands.push({type:"quadraticCurveTo",cpx:t,cpy:e,x:r,y:i})}rect(t,e,r,i){this.moveTo(t,e),this.lineTo(t+r,e),this.lineTo(t+r,e+i),this.lineTo(t,e+i),this.closePath()}arc(t,e,r,i,n,s){this.commands.push({type:"arc",x:t,y:e,radius:r,startAngle:i,endAngle:n,counterclockwise:!!s})}ellipse(t,e,r,i,n,s,a,o){this.commands.push({type:"ellipse",x:t,y:e,radiusX:r,radiusY:i,rotation:n,startAngle:s,endAngle:a,counterclockwise:!!o})}arcTo(t,e,r,i,n){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i||"number"!=typeof n){const t=new TypeError("All parameters must be numbers");throw t.message="TypeError: "+t.message,t}if(!(isFinite(t)&&isFinite(e)&&isFinite(r)&&isFinite(i)&&isFinite(n))){const t=new TypeError("All parameters must be finite numbers");throw t.message="TypeError: "+t.message,t}if(n<0){const t=new Error("IndexSizeError");throw t.name="IndexSizeError",t}this.commands.push({type:"arcTo",x1:t,y1:e,x2:r,y2:i,radius:n})}}class s{constructor(t,e){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("Surface width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("Surface height must be a positive integer");if(t*e>268435456)throw new Error("SurfaceTooLarge");const r=16384;if(t>r||e>r)throw new Error("Surface dimensions must be ≤ 16384x16384");Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1}),Object.defineProperty(this,"stride",{value:4*t,writable:!1}),this.data=new Uint8ClampedArray(this.stride*e)}clone(){const t=new s(this.width,this.height);return t.data.set(this.data),t}getPixel(e,r){if(e<0||e>=this.width||r<0||r>=this.height)return null;const i=r*this.stride+4*e;return new t(this.data[i],this.data[i+1],this.data[i+2],this.data[i+3],!1)}setPixel(e,r,i){if(e<0||e>=this.width||r<0||r>=this.height)return;if(!(i instanceof t))throw new Error("Color must be a Color instance");const n=r*this.stride+4*e;this.data[n]=i.r,this.data[n+1]=i.g,this.data[n+2]=i.b,this.data[n+3]=i.a}clear(e=t.transparent()){if(!(e instanceof t))throw new Error("Color must be a Color instance");const r=e.toRGBA();for(let t=0;t<this.data.length;t+=4)this.data[t]=r[0],this.data[t+1]=r[1],this.data[t+2]=r[2],this.data[t+3]=r[3]}getMemoryUsage(){return this.data.byteLength}toString(){const t=(this.getMemoryUsage()/1048576).toFixed(2);return`Surface(${this.width}×${this.height}, ${t}MB)`}}class a{static blendPixel(t,e,r,i,n,s,o,h,l){if(0===n)switch(t){case"destination-out":default:return{r:s,g:o,b:h,a:l};case"destination-atop":case"source-in":case"destination-in":case"source-out":return{r:0,g:0,b:0,a:0};case"copy":return{r:e,g:r,b:i,a:n}}if(0===l)switch(t){case"source-over":case"destination-over":case"destination-atop":case"source-out":case"xor":case"copy":default:return{r:e,g:r,b:i,a:n};case"source-atop":case"destination-out":case"source-in":case"destination-in":return{r:0,g:0,b:0,a:0}}const c=n/255,u=l/255;let f,g,d,m;switch(t){case"source-over":default:return a._sourceOver(e,r,i,n,s,o,h,l);case"destination-over":return a._sourceOver(s,o,h,l,e,r,i,n);case"source-atop":if(m=l,0===l)return{r:0,g:0,b:0,a:0};f=Math.round(c*e+(1-c)*s),g=Math.round(c*r+(1-c)*o),d=Math.round(c*i+(1-c)*h);break;case"destination-atop":if(m=n,0===n)return{r:0,g:0,b:0,a:0};f=Math.round(u*s+(1-u)*e),g=Math.round(u*o+(1-u)*r),d=Math.round(u*h+(1-u)*i);break;case"source-in":if(m=Math.round(n*u),0===m)return{r:0,g:0,b:0,a:0};f=e,g=r,d=i;break;case"destination-in":if(m=Math.round(l*c),0===m)return{r:0,g:0,b:0,a:0};f=s,g=o,d=h;break;case"source-out":if(m=Math.round(n*(1-u)),0===m)return{r:0,g:0,b:0,a:0};f=e,g=r,d=i;break;case"destination-out":if(m=Math.round(l*(1-c)),0===m)return{r:0,g:0,b:0,a:0};f=s,g=o,d=h;break;case"xor":return 0===c&&0===u?{r:0,g:0,b:0,a:0}:0===c?{r:s,g:o,b:h,a:l}:0===u?{r:e,g:r,b:i,a:n}:{r:0,g:0,b:0,a:0};case"copy":return{r:e,g:r,b:i,a:n}}return{r:Math.max(0,Math.min(255,Math.round(f))),g:Math.max(0,Math.min(255,Math.round(g))),b:Math.max(0,Math.min(255,Math.round(d))),a:Math.max(0,Math.min(255,Math.round(m)))}}static _sourceOver(t,e,r,i,n,s,a,o){if(255===i)return{r:t,g:e,b:r,a:i};const h=i/255,l=1-h;return{r:Math.round(t*h+n*l),g:Math.round(e*h+s*l),b:Math.round(r*h+a*l),a:Math.round(i+o*l)}}static getSupportedOperations(){return["source-over","destination-over","source-atop","destination-atop","source-in","destination-in","source-out","destination-out","xor","copy"]}static isSupported(t){return a.getSupportedOperations().includes(t)}}class o{constructor(t={r:255,g:255,b:255}){if(!t||"object"!=typeof t)throw new Error("backgroundColor must be an object with r, g, b properties");const{r:e,g:r,b:i}=t;if("number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("backgroundColor components (r, g, b) must be numbers");if(e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("backgroundColor components must be in range 0-255");this._backgroundColor=Object.freeze({r:Math.round(e),g:Math.round(r),b:Math.round(i)}),Object.freeze(this)}get backgroundColor(){return this._backgroundColor}static withBackgroundColor(t,e,r){return new o({r:t,g:e,b:r})}static withWhiteBackground(){return new o({r:255,g:255,b:255})}static withBlackBackground(){return new o({r:0,g:0,b:0})}static withGrayBackground(t=128){return new o({r:t,g:t,b:t})}equals(t){if(!(t instanceof o))return!1;const e=this._backgroundColor,r=t._backgroundColor;return e.r===r.r&&e.g===r.g&&e.b===r.b}toString(){const t=this._backgroundColor;return`BitmapEncodingOptions(backgroundColor: rgb(${t.r}, ${t.g}, ${t.b}))`}}o.DEFAULT=new o;class h{static encode(t,e=o.DEFAULT){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");const r=t.width,i=t.height,n=t.data,s=r*i*4;if(n.length!==s)throw new Error(`Surface data size mismatch. Expected ${s}, got ${n.length}`);const a=h._calculateDimensions(r,i),l=new ArrayBuffer(a.fileSize),c=new DataView(l),u=new Uint8Array(l);return h._writeBMPHeaders(c,a),h._writePixelData(u,n,t,a,e),l}static _calculateDimensions(t,e){const r=4*Math.floor((3*t+3)/4),i=r*e;return{width:t,height:e,rowSize:r,imageSize:i,fileSize:h.BMP_HEADER_SIZE+i}}static _writeBMPHeaders(t,e){h._writeBMPFileHeader(t,e.fileSize),h._writeBMPInfoHeader(t,e)}static _writeBMPFileHeader(t,e){const r=new Uint8Array(t.buffer);r[0]=66,r[1]=77,t.setUint32(2,e,!0),t.setUint32(6,0,!0),t.setUint32(10,h.BMP_HEADER_SIZE,!0)}static _writeBMPInfoHeader(t,e){t.setUint32(14,40,!0),t.setInt32(18,e.width,!0),t.setInt32(22,-e.height,!0),t.setUint16(26,1,!0),t.setUint16(28,24,!0),t.setUint32(30,0,!0),t.setUint32(34,e.imageSize,!0);t.setInt32(38,2835,!0),t.setInt32(42,2835,!0),t.setUint32(46,0,!0),t.setUint32(50,0,!0)}static _writePixelData(t,e,r,i,n){let s=h.BMP_HEADER_SIZE;for(let a=0;a<i.height;a++){let o=s;for(let s=0;s<i.width;s++){const i=a*r.stride+4*s,l=e[i],c=e[i+1],u=e[i+2],f=e[i+3],g=h._unpremultiplyAlpha(l,c,u,f,n.backgroundColor);t[o]=g.b,t[o+1]=g.g,t[o+2]=g.r,o+=3}for(;o-s<i.rowSize;)t[o]=0,o++;s+=i.rowSize}}static _unpremultiplyAlpha(t,e,r,i,n={r:255,g:255,b:255}){if(0===i)return{r:n.r,g:n.g,b:n.b};if(255===i)return{r:t,g:e,b:r};const s=i/255;return{r:Math.round(t*s+n.r*(1-s)),g:Math.round(e*s+n.g*(1-s)),b:Math.round(r*s+n.b*(1-s))}}static getBMPInfo(t){if(!t||!t.width||!t.height)throw new Error("Invalid surface");const e=h._calculateDimensions(t.width,t.height);return{width:e.width,height:e.height,bitsPerPixel:24,compression:"None",rowSize:e.rowSize,imageSize:e.imageSize,fileSize:e.fileSize,headerSize:h.BMP_HEADER_SIZE}}static canEncode(t){try{if(!t||"object"!=typeof t)return!1;if(!t.width||!t.height||!t.data)return!1;if(t.width<=0||t.height<=0)return!1;if(t.width>h.MAX_DIMENSION||t.height>h.MAX_DIMENSION)return!1;const e=t.width*t.height*4;return t.data.length===e}catch(t){return!1}}static calculateMemoryUsage(t,e){if(t<=0||e<=0)return 0;return h._calculateDimensions(t,e).fileSize}}h.BMP_HEADER_SIZE=54,h.MAX_DIMENSION=65535;class l{constructor(t={}){const{preserveTransparency:e=!0,compressionLevel:r=0}=t;if("boolean"!=typeof e)throw new Error("preserveTransparency must be a boolean");if("number"!=typeof r||r<0||r>9)throw new Error("compressionLevel must be a number between 0-9");if(0!==r)throw new Error("Only compression level 0 (no compression) is currently supported");this._config=Object.freeze({preserveTransparency:e,compressionLevel:r}),Object.freeze(this)}get preserveTransparency(){return this._config.preserveTransparency}get compressionLevel(){return this._config.compressionLevel}static withDefaults(){return new l}static withTransparency(){return new l({preserveTransparency:!0})}static withoutTransparency(){return new l({preserveTransparency:!1})}static withCompressionLevel(t){return new l({compressionLevel:t})}static forMaximumCompatibility(){return new l({preserveTransparency:!0,compressionLevel:0})}equals(t){if(!(t instanceof l))return!1;const e=this._config,r=t._config;return e.preserveTransparency===r.preserveTransparency&&e.compressionLevel===r.compressionLevel}toString(){const t=this._config;return`PngEncodingOptions(transparency: ${t.preserveTransparency}, compression: ${t.compressionLevel})`}withTransparency(t){return new l({preserveTransparency:t,compressionLevel:this._config.compressionLevel})}withCompression(t){return new l({preserveTransparency:this._config.preserveTransparency,compressionLevel:t})}}l.DEFAULT=new l;class c{static encode(t,e=l.DEFAULT){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");const r=t.width,i=t.height,n=t.data,s=r*i*4;if(n.length!==s)throw new Error(`Surface data size mismatch. Expected ${s}, got ${n.length}`);if(r<=0||i<=0)throw new Error("Surface dimensions must be positive");if(r>c.MAX_DIMENSION||i>c.MAX_DIMENSION)throw new Error(`Surface dimensions must be ≤ ${c.MAX_DIMENSION}x${c.MAX_DIMENSION}`);const a=c._createScanlines(r,i,n),o=c._createZlibData(a),h=c._createSignature(),u=c._createIHDRChunk(r,i),f=c._createIDATChunk(o),g=c._createIENDChunk(),d=h.length+u.length+f.length+g.length,m=new Uint8Array(d);let p=0;return m.set(h,p),p+=h.length,m.set(u,p),p+=u.length,m.set(f,p),p+=f.length,m.set(g,p),m.buffer}static _createSignature(){return new Uint8Array([137,80,78,71,13,10,26,10])}static _createScanlines(t,e,r){const i=new Uint8Array((4*t+1)*e);let n=0,s=0;for(let a=0;a<e;a++){i[s++]=0;for(let e=0;e<t;e++)i[s++]=r[n++],i[s++]=r[n++],i[s++]=r[n++],i[s++]=r[n++]}return i}static _createZlibData(t){const e=new Uint8Array([120,1]),r=[];let i=0;for(;i<t.length;){const e=t.length-i,n=Math.min(65535,e),s=i+n===t.length?1:0,a=new Uint8Array(5);a[0]=s,a[1]=255&n,a[2]=n>>>8&255;const o=65535&~n;a[3]=255&o,a[4]=o>>>8&255,r.push(a),r.push(t.subarray(i,i+n)),i+=n}const n=c._calculateAdler32(t),s=c._u32be(n);let a=e.length+s.length;for(const t of r)a+=t.length;const o=new Uint8Array(a);let h=0;o.set(e,h),h+=e.length;for(const t of r)o.set(t,h),h+=t.length;return o.set(s,h),o}static _createIHDRChunk(t,e){const r=new Uint8Array(13),i=c._u32be(t);r.set(i,0);const n=c._u32be(e);return r.set(n,4),r[8]=8,r[9]=6,r[10]=0,r[11]=0,r[12]=0,c._createChunk("IHDR",r)}static _createIDATChunk(t){return c._createChunk("IDAT",t)}static _createIENDChunk(){return c._createChunk("IEND",new Uint8Array(0))}static _createChunk(t,e){if(4!==t.length)throw new Error("Chunk type must be exactly 4 characters");const r=(new TextEncoder).encode(t),i=e.length,n=c._u32be(i),s=new Uint8Array(r.length+e.length);s.set(r,0),s.set(e,r.length);const a=c._calculateCRC32(s),o=c._u32be(a),h=new Uint8Array(8+i+4);let l=0;return h.set(n,l),l+=n.length,h.set(r,l),l+=r.length,h.set(e,l),l+=e.length,h.set(o,l),h}static _u32be(t){const e=new Uint8Array(4);return e[0]=t>>>24&255,e[1]=t>>>16&255,e[2]=t>>>8&255,e[3]=255&t,e}static _calculateCRC32(t){let e=4294967295;for(let r=0;r<t.length;r++){e^=t[r];for(let t=0;t<8;t++)e=e>>>1^3988292384&-(1&e)}return(4294967295^e)>>>0}static _calculateAdler32(t){let e=1,r=0;for(let i=0;i<t.length;i++)e=(e+t[i])%65521,r=(r+e)%65521;return(r<<16|e)>>>0}static getPNGInfo(t){if(!t||!t.width||!t.height)throw new Error("Invalid surface");const e=(4*t.width+1)*t.height,r=e+200;return{width:t.width,height:t.height,colorType:"RGBA (6)",bitDepth:8,compression:"DEFLATE (stored blocks)",filter:"None (0)",interlace:"None (0)",approximateFileSize:r,scanlineBytes:e}}static canEncode(t){try{if(!t||"object"!=typeof t)return!1;if(!t.width||!t.height||!t.data)return!1;if(t.width<=0||t.height<=0)return!1;if(t.width>c.MAX_DIMENSION||t.height>c.MAX_DIMENSION)return!1;const e=t.width*t.height*4;return t.data.length===e}catch(t){return!1}}static calculateMemoryUsage(t,e){return t<=0||e<=0?0:t*e*4+1*e+200}}c.MAX_DIMENSION=65535;class u{static flattenPath(t){const r=[];let i=[],n=new e(0,0),s=new e(0,0);for(const a of t.commands)switch(a.type){case"moveTo":u._handleMoveTo(a,r,i),n=new e(a.x,a.y),s=new e(a.x,a.y),i=[n.toObject()];break;case"lineTo":n=new e(a.x,a.y),i.push(n.toObject());break;case"closePath":u._handleClosePath(i,s,r),i=[];break;case"quadraticCurveTo":const t=u._flattenQuadraticBezier(n.x,n.y,a.cpx,a.cpy,a.x,a.y);u._appendPoints(i,t,1),n=new e(a.x,a.y);break;case"bezierCurveTo":const o=u._flattenCubicBezier(n.x,n.y,a.cp1x,a.cp1y,a.cp2x,a.cp2y,a.x,a.y);u._appendPoints(i,o,1),n=new e(a.x,a.y);break;case"arc":const h=u._handleArc(a,i,n,s);n=h.currentPoint,i=h.currentPoly,h.subpathStart&&(s=h.subpathStart);break;case"ellipse":const l=u._flattenEllipse(a.x,a.y,a.radiusX,a.radiusY,a.rotation,a.startAngle,a.endAngle,a.counterclockwise);u._handleEllipsePoints(l,i,n),l.length>0&&(n=new e(l[l.length-1].x,l[l.length-1].y));break;case"arcTo":const c=u._handleArcTo(a,i,n,s);n=c.currentPoint,i=c.currentPoly,c.subpathStart&&(s=c.subpathStart)}return i.length>0&&r.push(i),r}static _handleMoveTo(t,e,r){r.length>0&&e.push(r)}static _handleClosePath(t,e,r){if(t.length>0){const i=t[t.length-1];i.x===e.x&&i.y===e.y||t.push(e.toObject()),r.push(t)}}static _appendPoints(t,e,r){for(let i=r;i<e.length;i++)t.push(e[i])}static _handleArc(t,r,i,n){const s=u._flattenArc(t.x,t.y,t.radius,t.startAngle,t.endAngle,t.counterclockwise);if(0===s.length)return{currentPoint:i,currentPoly:r,subpathStart:null};const a=new e(s[0].x,s[0].y);if(0===r.length){r.push(a.toObject());const t=a,i=a;return u._appendPoints(r,s,1),{currentPoint:s.length>1?new e(s[s.length-1].x,s[s.length-1].y):t,currentPoly:r,subpathStart:i}}return i.distanceTo(a)>.01&&r.push(a.toObject()),u._appendPoints(r,s,1),{currentPoint:new e(s[s.length-1].x,s[s.length-1].y),currentPoly:r,subpathStart:null}}static _handleEllipsePoints(t,r,i){if(t.length>0){const n=new e(t[0].x,t[0].y);i.distanceTo(n)>.01&&r.push(n.toObject()),u._appendPoints(r,t,1)}}static _flattenQuadraticBezier(t,e,r,i,n,s){const a=[{x:t,y:e}];return u._flattenQuadraticBezierRecursive(t,e,r,i,n,s,a,u.TOLERANCE),a}static _flattenQuadraticBezierRecursive(t,e,r,i,n,s,a,o){const h=n-t,l=s-e;if(Math.abs((r-t)*l-(i-e)*h)/Math.sqrt(h*h+l*l)<=o||a.length>1e3)return void a.push({x:n,y:s});const c=(t+r)/2,f=(e+i)/2,g=(r+n)/2,d=(i+s)/2,m=(c+g)/2,p=(f+d)/2;u._flattenQuadraticBezierRecursive(t,e,c,f,m,p,a,o),u._flattenQuadraticBezierRecursive(m,p,g,d,n,s,a,o)}static _flattenCubicBezier(t,e,r,i,n,s,a,o){const h=[{x:t,y:e}];return u._flattenCubicBezierRecursive(t,e,r,i,n,s,a,o,h,u.TOLERANCE),h}static _flattenCubicBezierRecursive(t,e,r,i,n,s,a,o,h,l){const c=a-t,f=o-e,g=Math.sqrt(c*c+f*f);if(0===g)return void h.push({x:a,y:o});if(Math.abs((r-t)*f-(i-e)*c)/g+Math.abs((n-t)*f-(s-e)*c)/g<=l||h.length>1e3)return void h.push({x:a,y:o});const d=(t+r)/2,m=(e+i)/2,p=(r+n)/2,_=(i+s)/2,b=(n+a)/2,y=(s+o)/2,w=(d+p)/2,x=(m+_)/2,M=(p+b)/2,P=(_+y)/2,S=(w+M)/2,C=(x+P)/2;u._flattenCubicBezierRecursive(t,e,d,m,w,x,S,C,h,l),u._flattenCubicBezierRecursive(S,C,M,P,b,y,a,o,h,l)}static _flattenArc(t,e,r,i,n,s){if(r<=0)return[];let a=i,o=n;!s&&o<a?o+=2*Math.PI:s&&a<o&&(a+=2*Math.PI);const h=Math.abs(o-a),l=2*Math.acos(Math.max(0,1-u.TOLERANCE/r)),c=Math.max(1,Math.ceil(h/l)),f=[],g=(o-a)/c;for(let i=0;i<=c;i++){const n=a+i*g;f.push({x:t+r*Math.cos(n),y:e+r*Math.sin(n)})}return f}static _flattenEllipse(t,e,r,i,n,s,a,o){if(r<=0||i<=0)return[];let h=s,l=a;!o&&l<h?l+=2*Math.PI:o&&h<l&&(h+=2*Math.PI);const c=Math.abs(l-h),f=Math.min(r,i),g=2*Math.acos(Math.max(0,1-u.TOLERANCE/f)),d=Math.max(1,Math.ceil(c/g)),m=[],p=(l-h)/d,_=Math.cos(n),b=Math.sin(n);for(let n=0;n<=d;n++){const s=h+n*p,a=r*Math.cos(s),o=i*Math.sin(s);m.push({x:t+a*_-o*b,y:e+a*b+o*_})}return m}static _flattenArcWithTolerance(t,e,r,i,n,s,a){if(r<=0)return[];let o=i,h=n;!s&&h<o?h+=2*Math.PI:s&&o<h&&(o+=2*Math.PI);const l=Math.abs(h-o),c=2*Math.acos(Math.max(0,1-a/r)),u=Math.ceil(l/(Math.PI/2)*16),f=Math.ceil(l/c),g=Math.max(1,Math.max(u,f)),d=[],m=(h-o)/g;for(let i=0;i<=g;i++){const n=o+i*m;d.push({x:t+r*Math.cos(n),y:e+r*Math.sin(n)})}return d}static _handleArcTo(t,r,i,n){const{x1:s,y1:a,x2:o,y2:h,radius:l}=t;if(0===r.length){const t=new e(s,a);return r.push(t.toObject()),{currentPoint:t,currentPoly:r,subpathStart:t}}if(l<=0){const t=new e(s,a);return r.push(t.toObject()),{currentPoint:t,currentPoly:r,subpathStart:null}}const c=i,f=new e(s,a),g=new e(o,h),d=new e(c.x-f.x,c.y-f.y),m=new e(g.x-f.x,g.y-f.y),p=Math.sqrt(d.x*d.x+d.y*d.y),_=Math.sqrt(m.x*m.x+m.y*m.y);if(p<1e-10||_<1e-10){const t=new e(s,a);return r.push(t.toObject()),{currentPoint:t,currentPoly:r,subpathStart:null}}const b=new e(d.x/p,d.y/p),y=new e(m.x/_,m.y/_),w=b.x*y.x+b.y*y.y,x=b.x*y.y-b.y*y.x,M=Math.max(-1,Math.min(1,w)),P=Math.acos(M);if(Math.abs(Math.sin(P))<1e-10){const t=new e(s,a);return r.push(t.toObject()),{currentPoint:t,currentPoly:r,subpathStart:null}}const S=P/2,C=l/Math.tan(S),v=new e(f.x+b.x*C,f.y+b.y*C),E=new e(f.x+y.x*C,f.y+y.y*C),k=new e(-b.y,b.x),A=(new e(-y.y,y.x),Math.sign(x)),O=new e(v.x+k.x*A*l,v.y+k.y*A*l),I=Math.atan2(v.y-O.y,v.x-O.x),D=Math.atan2(E.y-O.y,E.x-O.x),T=A>0;i.distanceTo(v)>.01&&r.push(v.toObject());const B=Math.min(.1,u.TOLERANCE),z=u._flattenArcWithTolerance(O.x,O.y,l,I,D,T,B);u._appendPoints(r,z,1);return{currentPoint:z.length>0?new e(z[z.length-1].x,z[z.length-1].y):E,currentPoly:r,subpathStart:null}}}u.TOLERANCE=.25;class f{static fillPolygons(t,e,r,i,n,s,a=1,o=1,h="source-over",l=null){if(0===e.length)return;if(!f._isValidPaintSource(r))throw new Error("Paint source must be a Color, Gradient, or Pattern instance");const c=e.map(t=>t.map(t=>n.transformPoint(t))),u=f._calculateBounds(c,t);for(let e=u.minY;e<=u.maxY;e++)f._fillScanline(t,e,c,r,i,s,n,a,o,h,l)}static _calculateBounds(t,e){let r=1/0,i=-1/0;for(const e of t)for(const t of e)r=Math.min(r,t.y),i=Math.max(i,t.y);return{minY:Math.max(0,Math.floor(r)),maxY:Math.min(e.height-1,Math.ceil(i))}}static _fillScanline(t,e,r,i,n,s,a,o,h=1,l="source-over",c=null){const u=[];for(const t of r)f._findPolygonIntersections(t,e+.5,u);u.sort((t,e)=>t.x-e.x),f._fillSpans(t,e,u,i,n,s,a,o,h,l,c)}static _findPolygonIntersections(t,e,r){for(let i=0;i<t.length;i++){const n=t[i],s=t[(i+1)%t.length];if(Math.abs(n.y-s.y)<1e-10)continue;const a=Math.min(n.y,s.y),o=Math.max(n.y,s.y);if(e>=a&&e<o){const t=(e-n.y)/(s.y-n.y),i=n.x+t*(s.x-n.x),a=s.y>n.y?1:-1;r.push({x:i,winding:a})}}}static _fillSpans(t,e,r,i,n,s,a,o,h=1,l="source-over",c=null){if(0===r.length)return;let u=0,g=!1;for(let d=0;d<r.length;d++){const m=r[d],p=r[d+1];if(u+=m.winding,g="evenodd"===n?u%2!=0:0!==u,g&&p){const r=Math.max(0,Math.ceil(m.x)),n=Math.min(t.width-1,Math.floor(p.x));f._fillPixelSpan(t,e,r,n,i,s,a,o,h,l,c)}}}static _fillPixelSpan(t,e,r,i,n,s,a,o,h=1,l="source-over",c=null){for(let u=r;u<=i;u++){if(s&&s.isPixelClipped(u,e))continue;if(c){c.setPixel(u,e,!0);continue}const r=f._evaluatePaintSource(n,u,e,a,o,h),i=e*t.stride+4*u;f._blendPixel(t,i,r,l)}}static _blendPixel(t,e,r,i="source-over"){const n=t.data[e],s=t.data[e+1],o=t.data[e+2],h=t.data[e+3],l=a.blendPixel(i,r.r,r.g,r.b,r.a,n,s,o,h);t.data[e]=l.r,t.data[e+1]=l.g,t.data[e+2]=l.b,t.data[e+3]=l.a}static colorFromRGBA(e){return new t(e[0],e[1],e[2],e[3],!1)}static getPolygonBounds(t){if(0===t.length)return new r(0,0,0,0);const i=t.flat();return r.boundingBox(i.map(t=>new e(t.x,t.y)))}static countVertices(t){return t.reduce((t,e)=>t+e.length,0)}static _isValidPaintSource(e){return e instanceof t||e instanceof y||e instanceof w||e instanceof x||e instanceof M||e instanceof P}static _evaluatePaintSource(e,r,i,n,s,a=1){let o;o=e instanceof t?e:e instanceof y||e instanceof w||e instanceof x||e instanceof M||e instanceof P?e.getColorForPixel(r,i,n):new t(0,0,0,0);let h=o.withGlobalAlpha(s);if(a<1){const e=Math.round(h.a*a);h=new t(h.r,h.g,h.b,e,h.premultiplied)}return h}static isPointInPolygons(t,e,r,i="nonzero"){if(0===r.length)return!1;for(const i of r)if(!(i.length<3))for(let r=0;r<i.length;r++){const n=i[r],s=i[(r+1)%i.length];if(f._isPointOnEdge(t,e,n,s,1e-10))return!0}let n=0;for(const i of r)if(!(i.length<3))for(let r=0;r<i.length;r++){const s=i[r],a=i[(r+1)%i.length];if(Math.abs(s.y-a.y)<1e-10)continue;const o=Math.min(s.y,a.y),h=Math.max(s.y,a.y);if(e>=o&&e<h){const r=(e-s.y)/(a.y-s.y);if(s.x+r*(a.x-s.x)>=t){n+=a.y>s.y?1:-1}}}return"evenodd"===i?n%2!=0:0!==n}static _isPointOnEdge(t,e,r,i,n){const s=i.x-r.x,a=i.y-r.y,o=Math.sqrt(s*s+a*a);if(o<n)return Math.abs(t-r.x)<n&&Math.abs(e-r.y)<n;const h=t-r.x,l=e-r.y;if(Math.abs(h*a-l*s)>n*o)return!1;const c=(h*s+l*a)/(s*s+a*a);return c>=-n&&c<=1+n}}class g{static generateStrokePolygons(t,e){const r=g._validateStrokeProperties(e);if(r.lineWidth<=0)return[];const i=u.flattenPath(t),n=g._applyDashPattern(i,r),s=[];for(const t of n){if(t.length<2)continue;const e=g._generateStrokeForPolygon(t,r);s.push(...e)}return s}static _validateStrokeProperties(t){const e={lineWidth:1,lineJoin:"miter",lineCap:"butt",miterLimit:10,lineDash:[],lineDashOffset:0,...t};if(e.lineWidth<0)throw new Error("lineWidth must not be negative");if(!["miter","round","bevel"].includes(e.lineJoin))throw new Error(`Invalid lineJoin: ${e.lineJoin}`);if(!["butt","round","square"].includes(e.lineCap))throw new Error(`Invalid lineCap: ${e.lineCap}`);if(e.miterLimit<=0)throw new Error("miterLimit must be positive");return e}static _applyDashPattern(t,e){if(!e.lineDash||0===e.lineDash.length)return t;const r=[];for(const i of t){if(i.length<2)continue;const t=g._dashPolygon(i,e.lineDash,e.lineDashOffset);r.push(...t)}return r}static _dashPolygon(t,e,r){if(t.length<2)return[];const i=[],n=e.reduce((t,e)=>t+e,0);if(n<=0)return[t];let s=r%n;s<0&&(s+=n);let a=s,o=0,h=!0,l=0;for(let t=0;t<e.length;t++){if(l+e[t]>s){o=t,a=s-l,h=t%2==0;break}l+=e[t]}let c=[];for(let r=0;r<t.length-1;r++){const n=t[r],s=t[r+1],l=Math.sqrt(Math.pow(s.x-n.x,2)+Math.pow(s.y-n.y,2));if(0===l)continue;const u=g._processSegmentWithDash(n,s,l,e,o,a,h,c,i);o=u.patternIndex,a=u.patternPosition,h=u.isDash,c=u.currentSegment}return c.length>1&&i.push(c),i}static _processSegmentWithDash(t,e,r,i,n,s,a,o,h){let l=r,c=t;for(a&&0===o.length&&o.push({x:t.x,y:t.y});l>0;){const u=i[n],f=u-s,g=Math.min(l,f),d=(r-l+g)/r,m={x:t.x+d*(e.x-t.x),y:t.y+d*(e.y-t.y)};a&&o.push({x:m.x,y:m.y}),l-=g,(s+=g)>=u&&(a&&o.length>1&&(h.push(o),o=[]),n=(n+1)%i.length,s=0,(a=!a)&&l>0&&(o=[{x:m.x,y:m.y}])),c=m}return{patternIndex:n,patternPosition:s,isDash:a,currentSegment:o}}static _generateStrokeForPolygon(t,e){if(t.length<2)return[];const r=[],i=e.lineWidth/2,n=g._isPathClosed(t),s=g._generateSegments(t,i);if(0===s.length)return[];for(const t of s)r.push(t.body);return g._generateJoins(s,r,e,n),!n&&s.length>0&&g._generateCaps(s,r,e,i),r}static _isPathClosed(t){return t.length>2&&Math.abs(t[0].x-t[t.length-1].x)<1e-10&&Math.abs(t[0].y-t[t.length-1].y)<1e-10}static _generateSegments(t,r){const i=[];for(let n=0;n<t.length-1;n++){const s=new e(t[n].x,t[n].y),a=new e(t[n+1].x,t[n+1].y),o=s.distanceTo(a);if(o<1e-10)continue;const h=g._createSegment(s,a,r,o);i.push(h)}return i}static _createSegment(t,r,i,n){const s=r.subtract(t).scale(1/n),a=new e(-s.y,s.x);return{body:[t.add(a.scale(i)).toObject(),r.add(a.scale(i)).toObject(),r.add(a.scale(-i)).toObject(),t.add(a.scale(-i)).toObject()],p1:t,p2:r,tangent:s,normal:a,length:n}}static _generateJoins(t,e,r,i){for(let i=0;i<t.length-1;i++){const n=t[i],s=t[i+1],a=g._generateJoin(n,s,r);e.push(...a)}if(i&&t.length>1){const i=t[t.length-1],n=t[0],s=g._generateJoin(i,n,r);e.push(...s)}}static _generateJoin(t,e,r){const i=e.p1,n=t.tangent.cross(e.tangent);if(Math.abs(n)<1e-10)return g._generateBevelJoin(t,e,i);switch(r.lineJoin){case"miter":return g._generateMiterJoin(t,e,i,r.miterLimit);case"round":return g._generateRoundJoin(t,e,i);default:return g._generateBevelJoin(t,e,i)}}static _generateMiterJoin(t,e,r,i){const n=Math.sqrt(Math.pow(t.body[0].x-t.body[3].x,2)+Math.pow(t.body[0].y-t.body[3].y,2))/2,s=t.tangent.cross(e.tangent);let a,o;s>0?(a=t.body[2],o=e.body[3]):(a=t.body[1],o=e.body[0]);const h={x:a.x+100*t.tangent.x,y:a.y+100*t.tangent.y},l={x:o.x-100*e.tangent.x,y:o.y-100*e.tangent.y},c=g._lineIntersection(a,h,o,l);if(!c)return g._generateBevelJoin(t,e,r);if(Math.sqrt(Math.pow(c.x-r.x,2)+Math.pow(c.y-r.y,2))/n>i)return g._generateBevelJoin(t,e,r);let u,f;return s>0?(u=t.body[1],f=e.body[0]):(u=t.body[2],f=e.body[3]),[[a,c,o],[a,o,f,u]]}static _generateBevelJoin(t,e,r){const i=t.tangent.cross(e.tangent),n=g._getOuterSides(t,e,i),s=g._getInnerSides(t,e,i);return[[n.outer1,n.outer2,s.inner2,s.inner1]]}static _generateRoundJoin(t,e,r){const i=Math.sqrt(Math.pow(t.body[0].x-t.body[3].x,2)+Math.pow(t.body[0].y-t.body[3].y,2))/2;let n,s;t.tangent.cross(e.tangent)>0?(n=t.body[2],s=e.body[3]):(n=t.body[1],s=e.body[0]);let a=Math.atan2(n.y-r.y,n.x-r.x),o=Math.atan2(s.y-r.y,s.x-r.x),h=o-a;if(h>Math.PI?h-=2*Math.PI:h<-Math.PI&&(h+=2*Math.PI),h<0){const t=a;a=o,o=t,h=-h}const l=Math.max(2,Math.ceil(h/(Math.PI/4))),c=h/l,u=[];for(let t=0;t<l;t++){const e=a+t*c,n=a+(t+1)*c,s={x:r.x+i*Math.cos(e),y:r.y+i*Math.sin(e)},o={x:r.x+i*Math.cos(n),y:r.y+i*Math.sin(n)};u.push([r.toObject(),s,o])}return u}static _generateCaps(t,e,r,i){const n=g._generateCap(t[0].p1,t[0].tangent,i,r.lineCap,!0);n&&e.push(...Array.isArray(n[0])?n:[n]);const s=t[t.length-1],a=g._generateCap(s.p2,s.tangent,i,r.lineCap,!1);a&&e.push(...Array.isArray(a[0])?a:[a])}static _generateCap(t,r,i,n,s){const a=new e(-r.y,r.x);switch(n){case"square":return g._generateSquareCap(t,r,a,i,s);case"round":return g._generateRoundCap(t,a,i,s);default:return null}}static _generateSquareCap(t,e,r,i,n){const s=n?t.subtract(e.scale(i)):t.add(e.scale(i));return[[s.add(r.scale(i)).toObject(),s.subtract(r.scale(i)).toObject(),t.subtract(r.scale(i)).toObject(),t.add(r.scale(i)).toObject()]]}static _generateRoundCap(t,e,r,i){const n=Math.atan2(e.y,e.x);return g._generateArcFan(t,r,n,n+Math.PI*(i?1:-1))}static _getOuterSides(t,e,r){return r>0?{outer1:t.body[2],outer2:e.body[3]}:{outer1:t.body[1],outer2:e.body[0]}}static _getInnerSides(t,e,r){return r>0?{inner1:t.body[1],inner2:e.body[0]}:{inner1:t.body[2],inner2:e.body[3]}}static _lineIntersection(t,e,r,i){const n=(t.x-e.x)*(r.y-i.y)-(t.y-e.y)*(r.x-i.x);if(Math.abs(n)<1e-10)return null;const s=((t.x-r.x)*(r.y-i.y)-(t.y-r.y)*(r.x-i.x))/n;return{x:t.x+s*(e.x-t.x),y:t.y+s*(e.y-t.y)}}static _generateArcFan(t,e,r,i){let n=i-r;for(;n>Math.PI;)n-=2*Math.PI;for(;n<-Math.PI;)n+=2*Math.PI;const s=Math.abs(n),a=Math.max(2,Math.ceil(s/(Math.PI/4))),o=n/a,h=[];for(let i=0;i<a;i++){const n=r+i*o,s=r+(i+1)*o,a={x:t.x+e*Math.cos(n),y:t.y+e*Math.sin(n)},l={x:t.x+e*Math.cos(s),y:t.y+e*Math.sin(s)};h.push([t.toObject(),a,l])}return h}}class d{constructor(t,e,r=0){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("BitBuffer width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("BitBuffer height must be a positive integer");if(0!==r&&1!==r)throw new Error("BitBuffer defaultValue must be 0 or 1");this._width=t,this._height=e,this._numPixels=t*e,this._numBytes=Math.ceil(this._numPixels/8),this._defaultValue=r,this._buffer=new Uint8Array(this._numBytes),this._initializeToDefault(),Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}_initializeToDefault(){if(1===this._defaultValue){this._buffer.fill(255);const t=this._numPixels%8;if(0!==t){const e=this._numBytes-1,r=(1<<t)-1;this._buffer[e]=r}}else this._buffer.fill(0)}getPixel(t,e){if(t<0||t>=this._width||e<0||e>=this._height)return!1;const r=e*this._width+t;return 1===this._getBit(r)}setPixel(t,e,r){if(t<0||t>=this._width||e<0||e>=this._height)return;const i=e*this._width+t;this._setBit(i,r?1:0)}clear(){this._buffer.fill(0)}fill(){this._buffer.fill(255);const t=this._numPixels%8;if(0!==t){const e=this._numBytes-1,r=(1<<t)-1;this._buffer[e]=r}}reset(){this._initializeToDefault()}and(t){if(!(t instanceof d))throw new Error("Argument must be a BitBuffer instance");if(t._width!==this._width||t._height!==this._height)throw new Error("BitBuffer dimensions must match for AND operation");for(let e=0;e<this._numBytes;e++)this._buffer[e]&=t._buffer[e]}copyFrom(t){if(!(t instanceof d))throw new Error("Argument must be a BitBuffer instance");if(t._width!==this._width||t._height!==this._height)throw new Error("BitBuffer dimensions must match for copy operation");this._buffer.set(t._buffer)}isFull(){for(let t=0;t<this._numBytes-1;t++)if(255!==this._buffer[t])return!1;const t=this._numPixels%8;if(0===t)return 255===this._buffer[this._numBytes-1];{const e=(1<<t)-1;return this._buffer[this._numBytes-1]===e}}isEmpty(){for(let t=0;t<this._numBytes;t++)if(0!==this._buffer[t])return!1;return!0}getMemoryUsage(){return this._buffer.byteLength}_getBit(t){const e=Math.floor(t/8),r=t%8;return e>=this._buffer.length?0:this._buffer[e]&1<<r?1:0}_setBit(t,e){const r=Math.floor(t/8),i=t%8;r>=this._buffer.length||(e?this._buffer[r]|=1<<i:this._buffer[r]&=~(1<<i))}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this.isEmpty()?"empty":this.isFull()?"full":"mixed";return`BitBuffer(${this._width}×${this._height}, ${t}KB, ${e})`}equals(t){if(!(t instanceof d))return!1;if(t._width!==this._width||t._height!==this._height)return!1;for(let e=0;e<this._numBytes;e++)if(this._buffer[e]!==t._buffer[e])return!1;return!0}}class m{constructor(t,e){this._bitBuffer=new d(t,e,1),Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}getPixel(t,e){return this._bitBuffer.getPixel(t,e)}setPixel(t,e,r){this._bitBuffer.setPixel(t,e,r)}isPixelClipped(t,e){return!this.getPixel(t,e)}clear(){this._bitBuffer.fill()}clipAll(){this._bitBuffer.clear()}intersectWith(t){if(!(t instanceof m))throw new Error("Argument must be a ClipMask instance");this._bitBuffer.and(t._bitBuffer)}clone(){const t=new m(this.width,this.height);return t._bitBuffer.copyFrom(this._bitBuffer),t}createPixelWriter(){return(t,e,r)=>{if(t<0||t>=this._width||e<0||e>=this._height)return;const i=r>.5;this.setPixel(t,e,i)}}getMemoryUsage(){return this._bitBuffer.getMemoryUsage()}hasClipping(){return!this._bitBuffer.isFull()}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this.hasClipping()?"with clipping":"no clipping";return`ClipMask(${this.width}×${this.height}, ${t}KB, ${e})`}equals(t){return t instanceof m&&this._bitBuffer.equals(t._bitBuffer)}}class p{constructor(t,e){this._bitBuffer=new d(t,e,0),this._bounds={minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0,isEmpty:!0},Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}getPixel(t,e){return this._bitBuffer.getPixel(t,e)}setPixel(t,e,r){if(t<0||t>=this.width||e<0||e>=this.height)return;const i=this._bitBuffer.getPixel(t,e);this._bitBuffer.setPixel(t,e,r),r&&!i&&(this._bounds.isEmpty?(this._bounds.minX=t,this._bounds.minY=e,this._bounds.maxX=t,this._bounds.maxY=e,this._bounds.isEmpty=!1):(this._bounds.minX=Math.min(this._bounds.minX,t),this._bounds.minY=Math.min(this._bounds.minY,e),this._bounds.maxX=Math.max(this._bounds.maxX,t),this._bounds.maxY=Math.max(this._bounds.maxY,e)))}clear(){this._bitBuffer.clear(),this._bounds={minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0,isEmpty:!0}}isEmpty(){return this._bounds.isEmpty}getBounds(){return{minX:this._bounds.minX,minY:this._bounds.minY,maxX:this._bounds.maxX,maxY:this._bounds.maxY,isEmpty:this._bounds.isEmpty}}getIterationBounds(t=null,e=!1){if(this._bounds.isEmpty)return{minX:0,minY:0,maxX:-1,maxY:-1,isEmpty:!0};if(e)return t&&t.hasClipping(),{minX:0,minY:0,maxX:this.width-1,maxY:this.height-1,isEmpty:!1};return{minX:Math.max(0,this._bounds.minX),minY:Math.max(0,this._bounds.minY),maxX:Math.min(this.width-1,this._bounds.maxX),maxY:Math.min(this.height-1,this._bounds.maxY),isEmpty:!1}}createPixelWriter(){return(t,e,r)=>{if(t<0||t>=this.width||e<0||e>=this.height)return;const i=r>.5;this.setPixel(t,e,i)}}getMemoryUsage(){return this._bitBuffer.getMemoryUsage()}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this._bounds.isEmpty?"empty":`(${this._bounds.minX},${this._bounds.minY})-(${this._bounds.maxX},${this._bounds.maxY})`;return`SourceMask(${this.width}×${this.height}, ${t}KB, bounds: ${e})`}}class _{static validateAndConvert(t){_._validateImageLike(t);const e=t.width*t.height*3,r=t.width*t.height*4;if(t.data.length===e)return _._convertRGBToRGBA(t);if(t.data.length===r)return{width:t.width,height:t.height,data:t.data};throw new Error(`ImageLike data length (${t.data.length}) must match width*height*3 (${e}) for RGB or width*height*4 (${r}) for RGBA`)}static _validateImageLike(t){if(!t||"object"!=typeof t)throw new Error("ImageLike must be an object");if("number"!=typeof t.width||t.width<=0||!Number.isInteger(t.width))throw new Error("ImageLike width must be a positive integer");if("number"!=typeof t.height||t.height<=0||!Number.isInteger(t.height))throw new Error("ImageLike height must be a positive integer");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageLike data must be a Uint8ClampedArray");const e=16384;if(t.width>e||t.height>e)throw new Error("ImageLike dimensions must be ≤ 16384x16384")}static _convertRGBToRGBA(t){const e=t.width*t.height*4,r=new Uint8ClampedArray(e);for(let e=0;e<t.width*t.height;e++){const i=3*e,n=4*e;r[n]=t.data[i],r[n+1]=t.data[i+1],r[n+2]=t.data[i+2],r[n+3]=255}return{width:t.width,height:t.height,data:r}}static surfaceToImageLike(t){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");return{width:t.width,height:t.height,data:new Uint8ClampedArray(t.data)}}static createBlankImage(e,r,i=[0,0,0,255]){if(!Number.isInteger(e)||!Number.isInteger(r)||e<=0||r<=0)throw new Error("Width and height must be positive integers");const n=e*r,s=new Uint8ClampedArray(4*n);let a,o,h,l;if(i instanceof t){const t=i.toRGBA();a=t[0],o=t[1],h=t[2],l=t[3]}else{if(!(Array.isArray(i)&&i.length>=4))throw new Error("fillColor must be a Color instance or RGBA array");a=i[0],o=i[1],h=i[2],l=i[3]}for(let t=0;t<n;t++){const e=4*t;s[e]=a,s[e+1]=o,s[e+2]=h,s[e+3]=l}return{width:e,height:r,data:s}}static extractRegion(t,e,r,i,n){const s=_.validateAndConvert(t);if(e<0||r<0||e+i>s.width||r+n>s.height)throw new Error("Extraction region exceeds source image bounds");if(i<=0||n<=0)throw new Error("Extraction region dimensions must be positive");const a=new Uint8ClampedArray(i*n*4);for(let t=0;t<n;t++){const n=4*((r+t)*s.width+e),o=t*i*4,h=4*i;a.set(s.data.subarray(n,n+h),o)}return{width:i,height:n,data:a}}static scaleImage(t,e,r){const i=_.validateAndConvert(t);if(!Number.isInteger(e)||!Number.isInteger(r)||e<=0||r<=0)throw new Error("Target dimensions must be positive integers");const n=new Uint8ClampedArray(e*r*4),s=i.width/e,a=i.height/r;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const o=Math.floor(r*s),h=Math.floor(t*a),l=Math.min(o,i.width-1),c=4*(Math.min(h,i.height-1)*i.width+l),u=4*(t*e+r);n[u]=i.data[c],n[u+1]=i.data[c+1],n[u+2]=i.data[c+2],n[u+3]=i.data[c+3]}return{width:e,height:r,data:n}}static isImageLike(t){try{_._validateImageLike(t);const e=t.width*t.height*3,r=t.width*t.height*4;return t.data.length===e||t.data.length===r}catch(t){return!1}}static getImageInfo(t){const e=_.validateAndConvert(t),r=t.data.length===t.width*t.height*3;return{width:e.width,height:e.height,pixelCount:e.width*e.height,format:r?"RGB":"RGBA",dataSize:e.data.length,bytesPerPixel:r?3:4,memoryUsage:e.data.byteLength}}static fromCanvas(t){if(!t||"object"!=typeof t)throw new Error("Canvas must be a valid HTMLCanvasElement");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("Canvas must have numeric width and height");if(!t.getContext||"function"!=typeof t.getContext)throw new Error("Canvas must have getContext method");try{const e=t.getContext("2d").getImageData(0,0,t.width,t.height);return{width:t.width,height:t.height,data:new Uint8ClampedArray(e.data)}}catch(t){throw new Error(`Failed to extract canvas data: ${t.message}`)}}}class b{constructor(){this._cache=new Map,this._namedColors={black:{r:0,g:0,b:0},silver:{r:192,g:192,b:192},gray:{r:128,g:128,b:128},white:{r:255,g:255,b:255},maroon:{r:128,g:0,b:0},red:{r:255,g:0,b:0},purple:{r:128,g:0,b:128},fuchsia:{r:255,g:0,b:255},green:{r:0,g:128,b:0},lime:{r:0,g:255,b:0},olive:{r:128,g:128,b:0},yellow:{r:255,g:255,b:0},navy:{r:0,g:0,b:128},blue:{r:0,g:0,b:255},teal:{r:0,g:128,b:128},aqua:{r:0,g:255,b:255},aliceblue:{r:240,g:248,b:255},antiquewhite:{r:250,g:235,b:215},aquamarine:{r:127,g:255,b:212},azure:{r:240,g:255,b:255},beige:{r:245,g:245,b:220},bisque:{r:255,g:228,b:196},blanchedalmond:{r:255,g:235,b:205},blueviolet:{r:138,g:43,b:226},brown:{r:165,g:42,b:42},burlywood:{r:222,g:184,b:135},cadetblue:{r:95,g:158,b:160},chartreuse:{r:127,g:255,b:0},chocolate:{r:210,g:105,b:30},coral:{r:255,g:127,b:80},cornflowerblue:{r:100,g:149,b:237},cornsilk:{r:255,g:248,b:220},crimson:{r:220,g:20,b:60},cyan:{r:0,g:255,b:255},darkblue:{r:0,g:0,b:139},darkcyan:{r:0,g:139,b:139},darkgoldenrod:{r:184,g:134,b:11},darkgray:{r:169,g:169,b:169},darkgreen:{r:0,g:100,b:0},darkgrey:{r:169,g:169,b:169},darkkhaki:{r:189,g:183,b:107},darkmagenta:{r:139,g:0,b:139},darkolivegreen:{r:85,g:107,b:47},darkorange:{r:255,g:140,b:0},darkorchid:{r:153,g:50,b:204},darkred:{r:139,g:0,b:0},darksalmon:{r:233,g:150,b:122},darkseagreen:{r:143,g:188,b:143},darkslateblue:{r:72,g:61,b:139},darkslategray:{r:47,g:79,b:79},darkslategrey:{r:47,g:79,b:79},darkturquoise:{r:0,g:206,b:209},darkviolet:{r:148,g:0,b:211},deeppink:{r:255,g:20,b:147},deepskyblue:{r:0,g:191,b:255},dimgray:{r:105,g:105,b:105},dimgrey:{r:105,g:105,b:105},dodgerblue:{r:30,g:144,b:255},firebrick:{r:178,g:34,b:34},floralwhite:{r:255,g:250,b:240},forestgreen:{r:34,g:139,b:34},gainsboro:{r:220,g:220,b:220},ghostwhite:{r:248,g:248,b:255},gold:{r:255,g:215,b:0},goldenrod:{r:218,g:165,b:32},grey:{r:128,g:128,b:128},greenyellow:{r:173,g:255,b:47},honeydew:{r:240,g:255,b:240},hotpink:{r:255,g:105,b:180},indianred:{r:205,g:92,b:92},indigo:{r:75,g:0,b:130},ivory:{r:255,g:255,b:240},khaki:{r:240,g:230,b:140},lavender:{r:230,g:230,b:250},lavenderblush:{r:255,g:240,b:245},lawngreen:{r:124,g:252,b:0},lemonchiffon:{r:255,g:250,b:205},lightblue:{r:173,g:216,b:230},lightcoral:{r:240,g:128,b:128},lightcyan:{r:224,g:255,b:255},lightgoldenrodyellow:{r:250,g:250,b:210},lightgray:{r:211,g:211,b:211},lightgreen:{r:144,g:238,b:144},lightgrey:{r:211,g:211,b:211},lightpink:{r:255,g:182,b:193},lightsalmon:{r:255,g:160,b:122},lightseagreen:{r:32,g:178,b:170},lightskyblue:{r:135,g:206,b:250},lightslategray:{r:119,g:136,b:153},lightslategrey:{r:119,g:136,b:153},lightsteelblue:{r:176,g:196,b:222},lightyellow:{r:255,g:255,b:224},limegreen:{r:50,g:205,b:50},linen:{r:250,g:240,b:230},magenta:{r:255,g:0,b:255},mediumaquamarine:{r:102,g:205,b:170},mediumblue:{r:0,g:0,b:205},mediumorchid:{r:186,g:85,b:211},mediumpurple:{r:147,g:112,b:219},mediumseagreen:{r:60,g:179,b:113},mediumslateblue:{r:123,g:104,b:238},mediumspringgreen:{r:0,g:250,b:154},mediumturquoise:{r:72,g:209,b:204},mediumvioletred:{r:199,g:21,b:133},midnightblue:{r:25,g:25,b:112},mintcream:{r:245,g:255,b:250},mistyrose:{r:255,g:228,b:225},moccasin:{r:255,g:228,b:181},navajowhite:{r:255,g:222,b:173},oldlace:{r:253,g:245,b:230},olivedrab:{r:107,g:142,b:35},orange:{r:255,g:165,b:0},orangered:{r:255,g:69,b:0},orchid:{r:218,g:112,b:214},palegoldenrod:{r:238,g:232,b:170},palegreen:{r:152,g:251,b:152},paleturquoise:{r:175,g:238,b:238},palevioletred:{r:219,g:112,b:147},papayawhip:{r:255,g:239,b:213},peachpuff:{r:255,g:218,b:185},peru:{r:205,g:133,b:63},pink:{r:255,g:192,b:203},plum:{r:221,g:160,b:221},powderblue:{r:176,g:224,b:230},rebeccapurple:{r:102,g:51,b:153},rosybrown:{r:188,g:143,b:143},royalblue:{r:65,g:105,b:225},saddlebrown:{r:139,g:69,b:19},salmon:{r:250,g:128,b:114},sandybrown:{r:244,g:164,b:96},seagreen:{r:46,g:139,b:87},seashell:{r:255,g:245,b:238},sienna:{r:160,g:82,b:45},skyblue:{r:135,g:206,b:235},slateblue:{r:106,g:90,b:205},slategray:{r:112,g:128,b:144},slategrey:{r:112,g:128,b:144},snow:{r:255,g:250,b:250},springgreen:{r:0,g:255,b:127},steelblue:{r:70,g:130,b:180},tan:{r:210,g:180,b:140},thistle:{r:216,g:191,b:216},tomato:{r:255,g:99,b:71},turquoise:{r:64,g:224,b:208},violet:{r:238,g:130,b:238},wheat:{r:245,g:222,b:179},whitesmoke:{r:245,g:245,b:245},yellowgreen:{r:154,g:205,b:50}}}parse(t){if(this._cache.has(t))return this._cache.get(t);let e;if("string"!=typeof t)e={r:0,g:0,b:0,a:255};else{const r=t.trim().toLowerCase();if(r.startsWith("#"))e=this._parseHex(r);else if(r.startsWith("rgb"))e=this._parseRGB(r);else if(this._namedColors[r]){const t=this._namedColors[r];e={r:t.r,g:t.g,b:t.b,a:255}}else e={r:0,g:0,b:0,a:255}}return this._cache.set(t,e),e}_parseHex(t){if(3===(t=t.substring(1)).length&&(t=t.split("").map(t=>t+t).join("")),6===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:255}}if(8===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:parseInt(t.substring(6,8),16)}}return{r:0,g:0,b:0,a:255}}_parseRGB(t){const e=t.match(/rgba?\s*\(\s*([^)]+)\s*\)/);if(!e)return{r:0,g:0,b:0,a:255};const r=e[1].split(",").map(t=>t.trim());if(r.length<3)return{r:0,g:0,b:0,a:255};const i=Math.max(0,Math.min(255,parseInt(r[0])||0)),n=Math.max(0,Math.min(255,parseInt(r[1])||0)),s=Math.max(0,Math.min(255,parseInt(r[2])||0));let a=255;if(r.length>=4){const t=parseFloat(r[3]);isNaN(t)||(a=Math.max(0,Math.min(255,Math.round(255*t))))}return{r:i,g:n,b:s,a:a}}clearCache(){this._cache.clear()}}class y{constructor(){this._colorStops=[],this._sorted=!1}addColorStop(e,r){if("number"!=typeof e||!isFinite(e))throw new Error("Color stop offset must be a finite number");if(e<0||e>1)throw new Error("Color stop offset must be between 0 and 1");const i=(new b).parse(r),n=new t(i.r,i.g,i.b,i.a);this._colorStops.push({offset:e,color:n}),this._sorted=!1}_getSortedColorStops(){return this._sorted||(this._colorStops.sort((t,e)=>t.offset-e.offset),this._sorted=!0),this._colorStops}_getColorAt(e){const r=this._getSortedColorStops();if(0===r.length)return new t(0,0,0,0);if(1===r.length)return r[0].color;if(e<=r[0].offset)return r[0].color;if(e>=r[r.length-1].offset)return r[r.length-1].color;for(let i=0;i<r.length-1;i++){const n=r[i],s=r[i+1];if(e>=n.offset&&e<=s.offset){const r=s.offset-n.offset;if(0===r)return n.color;const i=(e-n.offset)/r,a=n.color.r,o=n.color.g,h=n.color.b,l=n.color.a,c=s.color.r,u=s.color.g,f=s.color.b,g=s.color.a,d=Math.round(a+(c-a)*i),m=Math.round(o+(u-o)*i),p=Math.round(h+(f-h)*i),_=Math.round(l+(g-l)*i);return new t(d,m,p,_)}}return r[0].color}getColorForPixel(t,e,r){throw new Error("getColorForPixel must be implemented by subclass")}}class w extends y{constructor(t,e,r,i){super(),this._x0=t,this._y0=e,this._x1=r,this._y1=i,this._dx=r-t,this._dy=i-e,this._lengthSquared=this._dx*this._dx+this._dy*this._dy}getColorForPixel(t,r,i){const n=i.transformPoint(new e(this._x0,this._y0)),s=i.transformPoint(new e(this._x1,this._y1)),a=s.x-n.x,o=s.y-n.y,h=a*a+o*o;if(0===h)return this._getColorAt(0);const l=((t-n.x)*a+(r-n.y)*o)/h;return this._getColorAt(l)}}class x extends y{constructor(t,e,r,i,n,s){if(super(),r<0||s<0)throw new Error("Radial gradient radii must be non-negative");if(t===i&&e===n&&r===s)throw new Error("Radial gradient circles must not be identical");this._x0=t,this._y0=e,this._r0=r,this._x1=i,this._y1=n,this._r1=s}getColorForPixel(t,r,i){const n=i.transformPoint(new e(this._x0,this._y0)),s=i.transformPoint(new e(this._x1,this._y1)),a=Math.sqrt((t-n.x)**2+(r-n.y)**2),o=Math.sqrt((t-s.x)**2+(r-s.y)**2),h=Math.sqrt((s.x-n.x)**2+(s.y-n.y)**2)+this._r1;let l;return l=a<=this._r0?0:o>=this._r1?1:(a-this._r0)/(h-this._r0),this._getColorAt(Math.max(0,Math.min(1,l)))}}class M extends y{constructor(t,e,r){super(),this._angle=t,this._x=e,this._y=r}getColorForPixel(t,r,i){const n=i.transformPoint(new e(this._x,this._y));let s=Math.atan2(r-n.y,t-n.x)-this._angle;for(;s<0;)s+=2*Math.PI;for(;s>=2*Math.PI;)s-=2*Math.PI;const a=s/(2*Math.PI);return this._getColorAt(a)}}class P{constructor(t,e="repeat"){this._imageData=_.validateAndConvert(t);const r=["repeat","repeat-x","repeat-y","no-repeat"];if(!r.includes(e))throw new Error(`Invalid repetition mode: ${e}. Must be one of: ${r.join(", ")}`);this._repetition=e,this._patternTransform=new i,Object.freeze(this)}setTransform(t){if(t instanceof i){const e=Object.create(Object.getPrototypeOf(this));return e._imageData=this._imageData,e._repetition=this._repetition,e._patternTransform=t,Object.freeze(e),e}if(t&&"number"==typeof t.a){const e=new i([t.a,t.b,t.c,t.d,t.e,t.f]);return this.setTransform(e)}throw new Error("Pattern transform must be a Transform2D or DOMMatrix-like object")}getColorForPixel(r,i,n){try{const t=n.multiply(this._patternTransform),s=t.invert().transformPoint(new e(r,i));return this._samplePattern(s.x,s.y)}catch(e){return new t(0,0,0,0)}}_samplePattern(e,r){const i=this._imageData.width,n=this._imageData.height;let s,a;switch(this._repetition){case"repeat":s=this._repeatCoordinate(e,i),a=this._repeatCoordinate(r,n);break;case"repeat-x":if(s=this._repeatCoordinate(e,i),a=r,r<0||r>=n)return new t(0,0,0,0);break;case"repeat-y":if(s=e,a=this._repeatCoordinate(r,n),e<0||e>=i)return new t(0,0,0,0);break;case"no-repeat":if(s=e,a=r,e<0||e>=i||r<0||r>=n)return new t(0,0,0,0)}const o=Math.floor(s),h=Math.floor(a),l=Math.max(0,Math.min(i-1,o)),c=4*(Math.max(0,Math.min(n-1,h))*i+l),u=this._imageData.data[c],f=this._imageData.data[c+1],g=this._imageData.data[c+2],d=this._imageData.data[c+3];return new t(u,f,g,d)}_repeatCoordinate(t,e){if(0===e)return 0;let r=t%e;return r<0&&(r+=e),r}getDimensions(){return{width:this._imageData.width,height:this._imageData.height}}getRepetition(){return this._repetition}getTransform(){return this._patternTransform}static fromSurface(t,e="repeat"){const r=_.surfaceToImageLike(t);return new P(r,e)}static createSolid(t,e,r,i="repeat"){const n=_.createBlankImage(t,e,r);return new P(n,i)}}class S{constructor(t){if(!t||"object"!=typeof t)throw new Error("Rasterizer requires a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");this._surface=t,this._currentOp=null}get surface(){return this._surface}get currentOp(){return this._currentOp}beginOp(t={}){this._validateParams(t),this._currentOp={composite:t.composite||"source-over",globalAlpha:void 0!==t.globalAlpha?t.globalAlpha:1,transform:t.transform||new i,clipMask:t.clipMask||null,fillStyle:t.fillStyle||null,strokeStyle:t.strokeStyle||null,sourceMask:null},this._requiresCanvasWideCompositing(this._currentOp.composite)&&(this._currentOp.sourceMask=new p(this._surface.width,this._surface.height))}endOp(){this._currentOp=null}_validateParams(t){if(void 0!==t.globalAlpha&&("number"!=typeof t.globalAlpha||t.globalAlpha<0||t.globalAlpha>1))throw new Error("globalAlpha must be a number between 0 and 1");if(t.composite&&!a.isSupported(t.composite))throw new Error(`Invalid composite operation. Supported: ${a.getSupportedOperations().join(", ")}`);if(t.transform&&!(t.transform instanceof i))throw new Error("transform must be a Transform2D instance")}_requireActiveOp(){if(!this._currentOp)throw new Error("Must call beginOp() before drawing operations")}_requiresCanvasWideCompositing(t){return["destination-atop","destination-in","source-in","source-out","copy"].includes(t)}_isPixelClipped(t,e){return!!this._currentOp?.clipMask&&this._currentOp.clipMask.isPixelClipped(t,e)}fillRect(e,r,i,s,a){if(this._requireActiveOp(),"number"!=typeof e||"number"!=typeof r||"number"!=typeof i||"number"!=typeof s)throw new Error("Rectangle coordinates must be numbers");if(i<0||s<0)throw new Error("Rectangle dimensions must be non-negative");if(0===i||0===s)return;if(this._currentOp.clipMask||this._requiresCanvasWideCompositing(this._currentOp.composite)){const o=new n;o.rect(e,r,i,s);const h=this._currentOp.fillStyle;return a&&Array.isArray(a)&&(this._currentOp.fillStyle=new t(a[0],a[1],a[2],a[3])),this.fill(o,"nonzero"),void(a&&Array.isArray(a)&&(this._currentOp.fillStyle=h))}const o=this._currentOp.transform,h=o.transformPoint({x:e,y:r}),l=o.transformPoint({x:e+i,y:r}),c=o.transformPoint({x:e,y:r+s}),u=o.transformPoint({x:e+i,y:r+s}),g=Math.max(0,Math.floor(Math.min(h.x,l.x,c.x,u.x))),d=Math.min(this._surface.width-1,Math.floor(Math.max(h.x,l.x,c.x,u.x)-1)),m=Math.max(0,Math.floor(Math.min(h.y,l.y,c.y,u.y))),p=Math.min(this._surface.height-1,Math.floor(Math.max(h.y,l.y,c.y,u.y)-1));if(0===this._currentOp.transform.b&&0===this._currentOp.transform.c&&(a instanceof t||Array.isArray(a)))this._fillAxisAlignedRect(g,m,d-g+1,p-m+1,a);else{const n=[{x:e,y:r},{x:e+i,y:r},{x:e+i,y:r+s},{x:e,y:r+s}],o=Array.isArray(a)?new t(a[0],a[1],a[2],a[3]):a;f.fillPolygons(this._surface,[n],o,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite)}}_fillAxisAlignedRect(e,r,i,n,s){const o=this._surface,h=this._currentOp.globalAlpha,l=(Array.isArray(s)?new t(s[0],s[1],s[2],s[3]):s).withGlobalAlpha(h),c=l.r,u=l.g,f=l.b,g=l.a;for(let t=r;t<r+n;t++)if(!(t<0||t>=o.height))for(let r=e;r<e+i;r++){if(r<0||r>=o.width)continue;if(this._currentOp.clipMask&&this._isPixelClipped(r,t))continue;const e=t*o.stride+4*r,i=o.data[e],n=o.data[e+1],s=o.data[e+2],h=o.data[e+3],l=a.blendPixel(this._currentOp.composite,c,u,f,g,i,n,s,h);o.data[e]=l.r,o.data[e+1]=l.g,o.data[e+2]=l.b,o.data[e+3]=l.a}}_performCanvasWideCompositing(e,r=1,i=1){if(!this._currentOp||!this._currentOp.sourceMask)throw new Error("Canvas-wide compositing requires active operation with source mask");const n=this._surface,s=this._currentOp.sourceMask,o=this._currentOp.composite,h=this._currentOp.transform,l=this._currentOp.clipMask,c=s.getIterationBounds(l,!0);if(!c.isEmpty)for(let u=c.minY;u<=c.maxY;u++)for(let g=c.minX;g<=c.maxX;g++){if(l&&l.isPixelClipped(g,u))continue;let c;c=(s.getPixel(g,u)?1:0)>0?f._evaluatePaintSource(e,g,u,h,r,i):new t(0,0,0,0);const d=u*n.stride+4*g,m=n.data[d],p=n.data[d+1],_=n.data[d+2],b=n.data[d+3],y=a.blendPixel(o,c.r,c.g,c.b,c.a,m,p,_,b);n.data[d]=y.r,n.data[d+1]=y.g,n.data[d+2]=y.b,n.data[d+3]=y.a}}fill(e,r){this._requireActiveOp();const i=this._currentOp.fillStyle||new t(0,0,0,255),n=r||"nonzero",s=u.flattenPath(e);this._requiresCanvasWideCompositing(this._currentOp.composite)?(f.fillPolygons(this._surface,s,i,n,this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite,this._currentOp.sourceMask),this._performCanvasWideCompositing(i,this._currentOp.globalAlpha,1)):f.fillPolygons(this._surface,s,i,n,this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite)}stroke(e,r){this._requireActiveOp();const i=this._currentOp.strokeStyle||new t(0,0,0,255);let n=r,s=1;r.lineWidth<=1&&(s=0===r.lineWidth?1:r.lineWidth,n={...r,lineWidth:1});const a=g.generateStrokePolygons(e,n);this._requiresCanvasWideCompositing(this._currentOp.composite)?(f.fillPolygons(this._surface,a,i,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,s,this._currentOp.composite,this._currentOp.sourceMask),this._performCanvasWideCompositing(i,this._currentOp.globalAlpha,s)):f.fillPolygons(this._surface,a,i,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,s,this._currentOp.composite)}drawImage(t,e,r,i,n,s,o,h,l){this._requireActiveOp();const c=_.validateAndConvert(t);let u,f,g,d,m,p,b,y;if(3===arguments.length)u=0,f=0,g=c.width,d=c.height,m=e,p=r,b=g,y=d;else if(5===arguments.length)u=0,f=0,g=c.width,d=c.height,m=e,p=r,b=i,y=n;else{if(9!==arguments.length)throw new Error("Invalid number of arguments for drawImage");u=e,f=r,g=i,d=n,m=s,p=o,b=h,y=l}if(u<0||f<0||u+g>c.width||f+d>c.height)throw new Error("Source rectangle is outside image bounds");const w=this._currentOp.transform,x=w.transformPoint({x:m,y:p}),M=w.transformPoint({x:m+b,y:p}),P=w.transformPoint({x:m,y:p+y}),S=w.transformPoint({x:m+b,y:p+y}),C=Math.max(0,Math.floor(Math.min(x.x,M.x,P.x,S.x))),v=Math.min(this._surface.width-1,Math.ceil(Math.max(x.x,M.x,P.x,S.x))),E=Math.max(0,Math.floor(Math.min(x.y,M.y,P.y,S.y))),k=Math.min(this._surface.height-1,Math.ceil(Math.max(x.y,M.y,P.y,S.y))),A=w.invert(),O=this._currentOp.globalAlpha;for(let t=E;t<=k;t++)for(let e=C;e<=v;e++){if(this._currentOp.clipMask&&this._isPixelClipped(e,t))continue;const r=A.transformPoint({x:e,y:t});if(r.x<m||r.x>=m+b||r.y<p||r.y>=p+y)continue;const i=u+(r.x-m)/b*g,n=f+(r.y-p)/y*d,s=Math.floor(i),o=Math.floor(n);if(s<0||o<0||s>=c.width||o>=c.height)continue;const h=4*(o*c.width+s),l=c.data[h],_=c.data[h+1],w=c.data[h+2],x=c.data[h+3]/255*O,M=Math.round(255*x);if(0===M)continue;const P=t*this._surface.stride+4*e,S=this._surface.data[P],C=this._surface.data[P+1],v=this._surface.data[P+2],E=this._surface.data[P+3],k=a.blendPixel(this._currentOp.composite,l,_,w,M,S,C,v,E);this._surface.data[P]=k.r,this._surface.data[P+1]=k.g,this._surface.data[P+2]=k.b,this._surface.data[P+3]=k.a}}}class C{constructor(e){this.surface=e,this.rasterizer=new S(e),this.stateStack=[],this.globalAlpha=1,this.globalCompositeOperation="source-over",this._transform=new i,this._fillStyle=new t(0,0,0,255),this._strokeStyle=new t(0,0,0,255),this.lineWidth=1,this.lineJoin="miter",this.lineCap="butt",this.miterLimit=10,this._lineDash=[],this._originalLineDash=[],this._lineDashOffset=0,this._currentPath=new n,this._clipMask=null}save(){let t=null;this._clipMask&&(t=this._clipMask.clone()),this.stateStack.push({globalAlpha:this.globalAlpha,globalCompositeOperation:this.globalCompositeOperation,transform:new i([this._transform.a,this._transform.b,this._transform.c,this._transform.d,this._transform.e,this._transform.f]),fillStyle:this._fillStyle,strokeStyle:this._strokeStyle,clipMask:t,lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash.slice(),originalLineDash:this._originalLineDash.slice(),lineDashOffset:this._lineDashOffset})}restore(){if(0===this.stateStack.length)return;const t=this.stateStack.pop();this.globalAlpha=t.globalAlpha,this.globalCompositeOperation=t.globalCompositeOperation,this._transform=t.transform,this._fillStyle=t.fillStyle,this._strokeStyle=t.strokeStyle,this._clipMask=t.clipMask,this.lineWidth=t.lineWidth,this.lineJoin=t.lineJoin,this.lineCap=t.lineCap,this.miterLimit=t.miterLimit,this._lineDash=t.lineDash||[],this._originalLineDash=t.originalLineDash||[],this._lineDashOffset=t.lineDashOffset||0}transform(t,e,r,n,s,a){const o=new i([t,e,r,n,s,a]);this._transform=o.multiply(this._transform)}setTransform(t,e,r,n,s,a){this._transform=new i([t,e,r,n,s,a])}resetTransform(){this._transform=new i}translate(t,e){this._transform=(new i).translate(t,e).multiply(this._transform)}scale(t,e){this._transform=(new i).scale(t,e).multiply(this._transform)}rotate(t){this._transform=(new i).rotate(t).multiply(this._transform)}setFillStyle(e,r,i,n){1===arguments.length&&(e instanceof t||e instanceof y||e instanceof w||e instanceof x||e instanceof M||e instanceof P)?this._fillStyle=e:(n=void 0!==n?n:255,this._fillStyle=new t(e,r,i,n))}setStrokeStyle(e,r,i,n){1===arguments.length&&(e instanceof t||e instanceof y||e instanceof w||e instanceof x||e instanceof M||e instanceof P)?this._strokeStyle=e:(n=void 0!==n?n:255,this._strokeStyle=new t(e,r,i,n))}beginPath(){this._currentPath=new n}closePath(){this._currentPath.closePath()}moveTo(t,e){this._currentPath.moveTo(t,e)}lineTo(t,e){this._currentPath.lineTo(t,e)}rect(t,e,r,i){this._currentPath.rect(t,e,r,i)}arc(t,e,r,i,n,s){this._currentPath.arc(t,e,r,i,n,s)}ellipse(t,e,r,i,n,s,a,o){this._currentPath.ellipse(t,e,r,i,n,s,a,o)}arcTo(t,e,r,i,n){this._currentPath.arcTo(t,e,r,i,n)}quadraticCurveTo(t,e,r,i){this._currentPath.quadraticCurveTo(t,e,r,i)}bezierCurveTo(t,e,r,i,n,s){this._currentPath.bezierCurveTo(t,e,r,i,n,s)}fillRect(t,e,r,i){this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,fillStyle:this._fillStyle}),this.rasterizer.fillRect(t,e,r,i,this._fillStyle),this.rasterizer.endOp()}strokeRect(t,e,r,i){const s=new n;s.rect(t,e,r,i),s.closePath(),this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,strokeStyle:this._strokeStyle}),this.rasterizer.stroke(s,{lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit}),this.rasterizer.endOp()}clearRect(t,e,r,i){this._clearRectDirect(t,e,r,i)}_clearRectDirect(t,e,r,i){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("Rectangle coordinates must be numbers");if(r<0||i<0)return;if(0===r||0===i)return;const n=this.surface,s=this._transform,a=s.transformPoint({x:t,y:e}),o=s.transformPoint({x:t+r,y:e}),h=s.transformPoint({x:t,y:e+i}),l=s.transformPoint({x:t+r,y:e+i}),c=Math.floor(Math.min(a.x,o.x,h.x,l.x)),u=Math.ceil(Math.max(a.x,o.x,h.x,l.x)),f=Math.floor(Math.min(a.y,o.y,h.y,l.y)),g=Math.ceil(Math.max(a.y,o.y,h.y,l.y));if(0===s.b&&0===s.c){const a=s.e+t*s.a,o=s.f+e*s.d,h=a+r*s.a,l=o+i*s.d,c=Math.max(0,Math.floor(a)),u=Math.min(n.width-1,Math.floor(h)-1),f=Math.max(0,Math.floor(o)),g=Math.min(n.height-1,Math.floor(l)-1);for(let t=f;t<=g;t++)for(let e=c;e<=u;e++){if(this._clipMask&&this._clipMask.isPixelClipped(e,t))continue;const r=t*n.stride+4*e;n.data[r]=0,n.data[r+1]=0,n.data[r+2]=0,n.data[r+3]=0}}else{const a=s.invert();for(let s=Math.max(0,f);s<=Math.min(n.height-1,g);s++)for(let o=Math.max(0,c);o<=Math.min(n.width-1,u);o++){if(this._clipMask&&this._clipMask.isPixelClipped(o,s))continue;const h=a.transformPoint({x:o+.5,y:s+.5});if(h.x>=t&&h.x<t+r&&h.y>=e&&h.y<e+i){const t=s*n.stride+4*o;n.data[t]=0,n.data[t+1]=0,n.data[t+2]=0,n.data[t+3]=0}}}}fill(t,e){let r,i;0===arguments.length?(r=this._currentPath,i="nonzero"):1===arguments.length?"string"==typeof t?(r=this._currentPath,i=t):(r=t,i="nonzero"):(r=t,i=e),i=i||"nonzero",this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,fillStyle:this._fillStyle}),this.rasterizer.fill(r,i),this.rasterizer.endOp()}stroke(t){const e=t||this._currentPath;this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,strokeStyle:this._strokeStyle}),this.rasterizer.stroke(e,{lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash.slice(),lineDashOffset:this._lineDashOffset}),this.rasterizer.endOp()}isPointInPath(){let t,e,r,i;if(arguments.length<2){const t=new TypeError("Invalid number of arguments for isPointInPath");throw t.message="TypeError: "+t.message,t}if(2===arguments.length)[e,r]=arguments,t=this._currentPath,i="nonzero";else if(3===arguments.length)if("string"==typeof arguments[2])[e,r,i]=arguments,t=this._currentPath;else{if([t,e,r]=arguments,!t||"object"!=typeof t||!t.commands){const t=new TypeError("First argument must be a Path2D object");throw t.message="TypeError: "+t.message,t}i="nonzero"}else if(4===arguments.length){if([t,e,r,i]=arguments,!t||"object"!=typeof t||!t.commands){const t=new TypeError("First argument must be a Path2D object");throw t.message="TypeError: "+t.message,t}}else if(arguments.length>4){const t=new TypeError("Invalid number of arguments for isPointInPath");throw t.message="TypeError: "+t.message,t}if("number"!=typeof e||"number"!=typeof r)return!1;if(!t||!t.commands||0===t.commands.length)return!1;i=i||"nonzero";const n=u.flattenPath(t);if(0===n.length)return!1;const s=n.map(t=>t.map(t=>this._transform.transformPoint(t)));return f.isPointInPolygons(e,r,s,i)}isPointInStroke(){let t,e,r;if(arguments.length<2){const t=new TypeError("Invalid number of arguments for isPointInStroke");throw t.message="TypeError: "+t.message,t}if(2===arguments.length)[e,r]=arguments,t=this._currentPath;else if(3===arguments.length){if([t,e,r]=arguments,!t||"object"!=typeof t||!t.commands){const t=new TypeError("First argument must be a Path2D object");throw t.message="TypeError: "+t.message,t}}else if(arguments.length>3){const t=new TypeError("Invalid number of arguments for isPointInStroke");throw t.message="TypeError: "+t.message,t}if("number"!=typeof e||"number"!=typeof r)return!1;if(!t||!t.commands||0===t.commands.length)return!1;const i={lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash,lineDashOffset:this._lineDashOffset};if(0===i.lineWidth){const i=.5,n=u.flattenPath(t).map(t=>t.map(t=>this._transform.transformPoint(t)));for(const t of n)if(!(t.length<2))for(let n=0;n<t.length-1;n++){const s=t[n],a=t[n+1];if(this._distanceToLineSegment(e,r,s.x,s.y,a.x,a.y)<=i)return!0}return!1}const n=g.generateStrokePolygons(t,i);if(0===n.length)return!1;const s=n.map(t=>t.map(t=>this._transform.transformPoint(t)));return f.isPointInPolygons(e,r,s,"nonzero")}_distanceToLineSegment(t,e,r,i,n,s){const a=n-r,o=s-i;if(0===a&&0===o)return Math.sqrt((t-r)*(t-r)+(e-i)*(e-i));const h=Math.max(0,Math.min(1,((t-r)*a+(e-i)*o)/(a*a+o*o))),l=r+h*a,c=i+h*o;return Math.sqrt((t-l)*(t-l)+(e-c)*(e-c))}clip(t,e){const r=t||this._currentPath,i=e||"nonzero",n=new m(this.surface.width,this.surface.height);n.clipAll();n.createPixelWriter();const s=this._fillStyle;this._fillStyle=[255,255,255,255];const a=u.flattenPath(r);this._fillPolygonsToClipBuffer(a,i,n),this._fillStyle=s,this._clipMask?this._clipMask.intersectWith(n):this._clipMask=n}_fillPolygonsToClipBuffer(t,e,r){if(0===t.length)return;const i=this.surface,n=t.map(t=>t.map(t=>this._transform.transformPoint(t)));let s=1/0,a=-1/0;for(const t of n)for(const e of t)s=Math.min(s,e.y),a=Math.max(a,e.y);s=Math.max(0,Math.floor(s)),a=Math.min(i.height-1,Math.ceil(a));for(let t=s;t<=a;t++){const i=[];for(const e of n)this._findPolygonIntersections(e,t+.5,i);i.sort((t,e)=>t.x-e.x),this._fillClipSpans(t,i,e,r)}}_findPolygonIntersections(t,e,r){for(let i=0;i<t.length;i++){const n=t[i],s=t[(i+1)%t.length];if(Math.abs(n.y-s.y)<1e-10)continue;const a=Math.min(n.y,s.y),o=Math.max(n.y,s.y);if(e>=a&&e<o){const t=(e-n.y)/(s.y-n.y),i=n.x+t*(s.x-n.x),a=s.y>n.y?1:-1;r.push({x:i,winding:a})}}}_fillClipSpans(t,e,r,i){if(0===e.length)return;let n=0,s=!1;for(let a=0;a<e.length;a++){const o=e[a],h=e[a+1];n+=o.winding;if(s="evenodd"===r?n%2!=0:0!==n,s&&h){const e=Math.max(0,Math.ceil(o.x)),r=Math.min(this.surface.width-1,Math.floor(h.x));for(let n=e;n<=r;n++)i.setPixel(n,t,!0)}}}drawImage(t,e,r,n,s,a,o,h,l){if("undefined"!=typeof console&&console.log,!t||"object"!=typeof t)throw new Error("First argument must be an ImageLike object");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("ImageLike must have numeric width and height properties");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageLike data must be a Uint8ClampedArray");this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:new i([this._transform.a,this._transform.b,this._transform.c,this._transform.d,this._transform.e,this._transform.f]),clipMask:this._clipMask}),this.rasterizer.drawImage.apply(this.rasterizer,arguments),this.rasterizer.endOp()}setLineDash(t){if(!Array.isArray(t))throw new Error("setLineDash expects an array");for(let e=0;e<t.length;e++){if("number"!=typeof t[e]||isNaN(t[e]))throw new Error("Dash segments must be numbers");if(t[e]<0)throw new Error("Dash segments must be non-negative")}this._originalLineDash=t.slice(),this._lineDash=t.slice(),this._lineDash.length%2==1&&(this._lineDash=this._lineDash.concat(this._lineDash))}getLineDash(){return this._originalLineDash.slice()}set lineDashOffset(t){"number"!=typeof t||isNaN(t)||(this._lineDashOffset=t)}get lineDashOffset(){return this._lineDashOffset}createLinearGradient(t,e,r,i){return new w(t,e,r,i)}createRadialGradient(t,e,r,i,n,s){return new x(t,e,r,i,n,s)}createConicGradient(t,e,r){return new M(t,e,r)}createPattern(t,e){return new P(t,e)}}class v{constructor(t){this._core=new C(t),this._colorParser=new b,this._fillStyle="#000000",this._strokeStyle="#000000"}_updateSurface(t){this._core=new C(t),this._applyFillStyle(),this._applyStrokeStyle()}get fillStyle(){return this._fillStyle}set fillStyle(t){this._fillStyle=t,this._applyFillStyle()}get strokeStyle(){return this._strokeStyle}set strokeStyle(t){this._strokeStyle=t,this._applyStrokeStyle()}_applyFillStyle(){if(this._fillStyle instanceof y||this._fillStyle instanceof w||this._fillStyle instanceof x||this._fillStyle instanceof M||this._fillStyle instanceof P)this._core.setFillStyle(this._fillStyle);else{const t=this._colorParser.parse(this._fillStyle);this._core.setFillStyle(t.r,t.g,t.b,t.a)}}_applyStrokeStyle(){if(this._strokeStyle instanceof y||this._strokeStyle instanceof w||this._strokeStyle instanceof x||this._strokeStyle instanceof M||this._strokeStyle instanceof P)this._core.setStrokeStyle(this._strokeStyle);else{const t=this._colorParser.parse(this._strokeStyle);this._core.setStrokeStyle(t.r,t.g,t.b,t.a)}}get globalAlpha(){return this._core.globalAlpha}set globalAlpha(t){this._core.globalAlpha=t}get globalCompositeOperation(){return this._core.globalCompositeOperation}set globalCompositeOperation(t){this._core.globalCompositeOperation=t}get lineWidth(){return this._core.lineWidth}set lineWidth(t){this._core.lineWidth=t}get lineJoin(){return this._core.lineJoin}set lineJoin(t){this._core.lineJoin=t}get lineCap(){return this._core.lineCap}set lineCap(t){this._core.lineCap=t}get miterLimit(){return this._core.miterLimit}set miterLimit(t){this._core.miterLimit=t}get lineDashOffset(){return this._core.lineDashOffset}set lineDashOffset(t){this._core.lineDashOffset=t}save(){this._core.save()}restore(){this._core.restore()}transform(t,e,r,i,n,s){this._core.transform(t,e,r,i,n,s)}setTransform(t,e,r,i,n,s){this._core.setTransform(t,e,r,i,n,s)}resetTransform(){this._core.resetTransform()}translate(t,e){this._core.translate(t,e)}scale(t,e){this._core.scale(t,e)}rotate(t){this._core.rotate(t)}beginPath(){this._core.beginPath()}closePath(){this._core.closePath()}moveTo(t,e){this._core.moveTo(t,e)}lineTo(t,e){this._core.lineTo(t,e)}rect(t,e,r,i){this._core.rect(t,e,r,i)}arc(t,e,r,i,n,s=!1){this._core.arc(t,e,r,i,n,s)}ellipse(t,e,r,i,n,s,a,o=!1){this._core.ellipse(t,e,r,i,n,s,a,o)}arcTo(t,e,r,i,n){this._core.arcTo(t,e,r,i,n)}quadraticCurveTo(t,e,r,i){this._core.quadraticCurveTo(t,e,r,i)}bezierCurveTo(t,e,r,i,n,s){this._core.bezierCurveTo(t,e,r,i,n,s)}fillRect(t,e,r,i){this._core.fillRect(t,e,r,i)}strokeRect(t,e,r,i){this._core.strokeRect(t,e,r,i)}clearRect(t,e,r,i){this._core.clearRect(t,e,r,i)}fill(t,e){"string"==typeof t?this._core.fill(t):t&&t instanceof n?this._core.fill(t,e):this._core.fill()}stroke(t){t&&t instanceof n?this._core.stroke(t):this._core.stroke()}isPointInPath(){return this._core.isPointInPath.apply(this._core,arguments)}isPointInStroke(){return this._core.isPointInStroke.apply(this._core,arguments)}setLineDash(t){this._core.setLineDash(t)}getLineDash(){return this._core.getLineDash()}clip(t,e){"string"==typeof t?this._core.clip(t):t&&t instanceof n?this._core.clip(t,e):this._core.clip()}drawImage(t,...e){if("undefined"!=typeof console&&console.log,t&&t instanceof E)this._core.drawImage(t._imageData,...e);else if(t&&"object"==typeof t&&t.getContext&&"function"==typeof t.getContext){const r=t.getContext("2d").getImageData(0,0,t.width,t.height);this._core.drawImage(r,...e)}else t&&"object"==typeof t&&t.width&&t.height&&t.data,this._core.drawImage(t,...e)}createImageData(t,e){if("number"!=typeof t||t<=0||!Number.isInteger(t))throw new Error("Width must be a positive integer");if("number"!=typeof e||e<=0||!Number.isInteger(e))throw new Error("Height must be a positive integer");return{width:t,height:e,data:new Uint8ClampedArray(t*e*4)}}getImageData(t,e,r,i){if("number"!=typeof t||"number"!=typeof e)throw new Error("Coordinates must be numbers");if("number"!=typeof r||r<=0||!Number.isInteger(r))throw new Error("Width must be a positive integer");if("number"!=typeof i||i<=0||!Number.isInteger(i))throw new Error("Height must be a positive integer");const n=this.createImageData(r,i),s=this._core.surface;for(let a=0;a<i;a++){const i=Math.floor(e)+a,o=a;if(i>=0&&i<s.height)for(let e=0;e<r;e++){const a=Math.floor(t)+e,h=e;if(a>=0&&a<s.width){const t=i*s.stride+4*a,e=o*r*4+4*h;n.data[e]=s.data[t],n.data[e+1]=s.data[t+1],n.data[e+2]=s.data[t+2],n.data[e+3]=s.data[t+3]}}}return n}putImageData(t,e,r){if(!t||"object"!=typeof t)throw new Error("ImageData must be an object");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("ImageData must have numeric width and height");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageData data must be a Uint8ClampedArray");if("number"!=typeof e||"number"!=typeof r)throw new Error("Destination coordinates must be numbers");const i=this._core.surface;for(let n=0;n<t.height;n++){const s=Math.floor(r)+n,a=n;if(s>=0&&s<i.height)for(let r=0;r<t.width;r++){const n=Math.floor(e)+r,o=r;if(n>=0&&n<i.width){const e=s*i.stride+4*n,r=a*t.width*4+4*o;i.data[e]=t.data[r],i.data[e+1]=t.data[r+1],i.data[e+2]=t.data[r+2],i.data[e+3]=t.data[r+3]}}}}createLinearGradient(t,e,r,i){return this._core.createLinearGradient(t,e,r,i)}createRadialGradient(t,e,r,i,n,s){return this._core.createRadialGradient(t,e,r,i,n,s)}createConicGradient(t,e,r){return this._core.createConicGradient(t,e,r)}createPattern(t,e){return this._core.createPattern(t,e)}get _coreContext(){return this._core}}class E{constructor(t=300,e=150){this._width=t,this._height=e,this._surface=new s(t,e),this._context=null}get width(){return this._width}set width(t){const e=Math.max(1,Math.floor(t));e!==this._width&&(this._width=e,this._recreateSurface())}get height(){return this._height}set height(t){const e=Math.max(1,Math.floor(t));e!==this._height&&(this._height=e,this._recreateSurface())}getContext(t){if("2d"!==t)throw new Error("SWCanvas only supports 2d context");return this._context||(this._context=new v(this._surface)),this._context}_recreateSurface(){this._surface=new s(this._width,this._height),this._context&&this._context._updateSurface(this._surface)}get _coreSurface(){return this._surface}get _imageData(){return{width:this._width,height:this._height,data:this._surface.data}}get data(){return this._surface.data}toString(){return`[object SWCanvasElement(${this._width}x${this._height})]`}}function k(t=300,e=150){return new E(t,e)}function A(t,e){return new s(t,e)}function O(t,e){if("number"!=typeof t||t<=0||!Number.isInteger(t))throw new Error("Width must be a positive integer");if("number"!=typeof e||e<=0||!Number.isInteger(e))throw new Error("Height must be a positive integer");return{width:t,height:e,data:new Uint8ClampedArray(t*e*4)}}"undefined"!=typeof window?window.SWCanvas={createCanvas:k,createImageData:O,Core:{Surface:A,Context2D:C,Transform2D:i,SWPath2D:n,Color:t,Point:e,Rectangle:r,BitmapEncoder:h,BitmapEncodingOptions:o,PngEncoder:c,PngEncodingOptions:l,BitBuffer:d,ClipMask:m,SourceMask:p,ImageProcessor:_,CompositeOperations:a,Rasterizer:S,PathFlattener:u,PolygonFiller:f,StrokeGenerator:g,Gradient:y,LinearGradient:w,RadialGradient:x,ConicGradient:M,Pattern:P}}:"undefined"!=typeof module&&module.exports&&(module.exports={createCanvas:k,createImageData:O,Core:{Surface:A,Context2D:C,Transform2D:i,SWPath2D:n,Color:t,Point:e,Rectangle:r,BitmapEncoder:h,BitmapEncodingOptions:o,PngEncoder:c,PngEncodingOptions:l,BitBuffer:d,ClipMask:m,SourceMask:p,ImageProcessor:_,CompositeOperations:a,Rasterizer:S,PathFlattener:u,PolygonFiller:f,StrokeGenerator:g,Gradient:y,LinearGradient:w,RadialGradient:x,ConicGradient:M,Pattern:P}})}();
//# sourceMappingURL=swcanvas.min.js.map