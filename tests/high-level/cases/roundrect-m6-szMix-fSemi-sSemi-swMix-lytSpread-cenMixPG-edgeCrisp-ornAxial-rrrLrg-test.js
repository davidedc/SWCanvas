/**
 * TEST SUMMARY:
 * =================
 *
 * Description: Tests rendering of 6 axis-aligned rounded rectangles. Rectangles have a fixed large corner radius, random semi-transparent fills, and fixed semi-transparent strokes. Their size and position are randomized, but dimensions are adjusted to ensure crisp rendering.
 *
 *
 * ---
 *
 * | Facet                  | Value              | Reason
 * |------------------------|--------------------|-----------------------------------------------------------------------------------------------------
 * | Shape category         | `rounded-rects`    | Code calls `ctx.fillAndStrokeRoundRect()` (unified method to prevent speckles).
 * | Count                  | `multi-6`          | The test draws 6 instances in its default visual regression mode.
 * | SizeCategory           | `mixed`            | Rectangle dimensions are randomized in a range `[50, ~410)`, spanning the M, L, and XL size categories.
 * | FillStyle              | `semitransparent`  | Fill color is generated by `getRandomColor("semitransparent")`, resulting in an alpha < 255.
 * | StrokeStyle            | `semitransparent`  | Stroke color is hardcoded to `rgba(0, 0, 0, 50)`, which is semi-transparent.
 * | StrokeThickness        | `mixed`            | Stroke width is a randomized even integer between 2 and 42. As it's a set of discrete values, it's `mixed`.
 * | Layout                 | `spread`           | The 6 rectangles are positioned with random offsets, spreading them across the canvas.
 * | CenteredAt             | `mixed-pixel-grid` | The core positioning logic centers the shape on either a grid line or a pixel center to enable crispness.
 * | EdgeAlignment          | `crisp`            | Code explicitly calls `adjustDimensionsForCrispStrokeRendering()` to ensure sharp edges.
 * | Orientation            | `square`           | The test is for axis-aligned rectangles, meaning no rotation.
 * | ArcAngleExtent         | `N/A`              | Not applicable for rectangle shapes.
 * | RoundRectRadius        | `large-cat`        | The corner radius is a fixed value of `40`, which falls into the "large" category.
 * | ContextTranslation     | `none`             | No `ctx.translate()` calls are made.
 * | ContextRotation        | `none`             | No `ctx.rotate()` calls are made.
 * | ContextScaling         | `none`             | No `ctx.scale()` calls are made.
 * | Clipped on shape       | `none`             | No clipping is applied in this test.
 * | Clipped on shape count | `n/a`              | Not applicable as there is no clipping.
 * | Clipped on shape arrangement | `n/a`        | Not applicable as there is no clipping.
 * | Clipped on shape size  | `n/a`              | Not applicable as there is no clipping.
 * | Clipped on shape edge alignment | `n/a`     | Not applicable as there is no clipping.
 *
 * ---
 *
 * UNCAPTURED ASPECTS IN FILENAME / FACETS ABOVE:
 * ----------------------------------------------
 * - The corner radius is specifically fixed at 40px.
 * - The stroke color is fixed at a semi-transparent black (`rgba(0,0,0,50)`).
 * - While the final layout is a `spread`, the underlying logic first aligns the shape to a crisp
 *   pixel/grid center before applying a final random offset.
 *
 */

/**
 * @fileoverview Test definition for multiple large, transparent-stroked rounded rectangles.
 */

/**
 * Draws multiple large rounded rectangles with transparent strokes.
 *
 * @param {CanvasRenderingContext2D | SWCanvasContext} ctx The rendering context.
 * @param {number} currentIterationNumber The current test iteration (for seeding via RenderTest).
 * @param {?number} instances Optional: Number of instances to draw. Passed by the performance
 *                  testing harness. For visual regression (instances is null/0), 6 rectangles are drawn.
 * @returns {?{logs: string[]}} Logs for single-instance mode, or null for performance mode.
 */
function drawTest(ctx, currentIterationNumber, instances = null) {
    const isPerformanceRun = instances !== null && instances > 0;
    const numToDraw = isPerformanceRun ? instances : 6; // Original test draws 6

    let logs = [];

    const canvasWidth = ctx.canvas.width;
    const canvasHeight = ctx.canvas.height;
    const fixedRadius = 40; // Fixed radius for this test

    for (let i = 0; i < numToDraw; i++) {
        // Calls 1-4 for SeededRandom happen inside calculateCrispFillAndStrokeRectParams
        const placement = calculateCrispFillAndStrokeRectParams({
            canvasWidth,
            canvasHeight,
            minWidth: 50,
            maxWidth: canvasWidth * 0.6,
            minHeight: 50,
            maxHeight: canvasHeight * 0.6,
            maxStrokeWidth: 40,
            ensureEvenStroke: true,
            randomPosition: false          // Test handles the offset separately
        });
        let currentCenter = placement.center;
        const finalRectWidth = placement.adjustedDimensions.width;
        const finalRectHeight = placement.adjustedDimensions.height;
        const strokeWidth = placement.strokeWidth;

        // SeededRandom Call 5: xOffset
        const xOffset = Math.floor(SeededRandom.getRandom() * 100) - 50;
        // SeededRandom Call 6: yOffset
        const yOffset = Math.floor(SeededRandom.getRandom() * 100) - 50;

        const finalCenter = {
            x: currentCenter.x + xOffset,
            y: currentCenter.y + yOffset
        };

        // Fixed stroke color: Black, very transparent (alpha = 50/255 â‰ˆ 0.20)
        const strokeColorStr = 'rgba(0, 0, 0, 0.20)';
        // SeededRandom Call 7: fillColor (semi-transparent)
        const fillColorStr = getRandomColor("semitransparent");

        let geomX = finalCenter.x - finalRectWidth / 2;
        let geomY = finalCenter.y - finalRectHeight / 2;

        if (isPerformanceRun && numToDraw > 1) {
            geomX = Math.random() * Math.max(0, canvasWidth - finalRectWidth);
            geomY = Math.random() * Math.max(0, canvasHeight - finalRectHeight);
        }

        ctx.fillStyle = fillColorStr;
        ctx.strokeStyle = strokeColorStr;
        ctx.lineWidth = strokeWidth;

        // Use SWCanvas unified fillAndStrokeRoundRect to prevent fill/stroke speckles
        if (typeof ctx.fillAndStrokeRoundRect === 'function') {
            ctx.fillAndStrokeRoundRect(geomX, geomY, finalRectWidth, finalRectHeight, fixedRadius);
        } else {
            // Fallback for HTML5 Canvas: use standard path-based approach
            ctx.beginPath();
            ctx.roundRect(geomX, geomY, finalRectWidth, finalRectHeight, fixedRadius);
            ctx.fill();
            if (strokeWidth > 0) {
                ctx.stroke();
            }
        }

        if (!isPerformanceRun) {
            logs.push(
                `LargeTransRRect ${i+1}: center=(${finalCenter.x.toFixed(1)},${finalCenter.y.toFixed(1)}), W/H=(${finalRectWidth},${finalRectHeight}), r=${fixedRadius}, sw=${strokeWidth.toFixed(1)}`
            );
        }
    }

    if (isPerformanceRun) {
        return null;
    }
    return { logs };
}

// Register the test
registerHighLevelTest(
    'roundrect-m6-szMix-fSemi-sSemi-swMix-lytSpread-cenMixPG-edgeCrisp-ornAxial-rrrLrg',
    drawTest,
    'rounded-rects',
    {},
    {
        title: 'Large Transparent-Stroke Rounded Rectangles (Multiple, Random Params)',
        description: 'Tests rendering of multiple large rounded rectangles with transparent strokes, random fills, and fixed large radius.',
        displayName: 'Perf: 6 Large TranspStroke RRects'
    }
);
