!function(){"use strict";class t{constructor(t,e,r,i=255,s=!1){if(t<0||t>255||e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("Color components must be in range 0-255");if(s)this._r=Math.round(t),this._g=Math.round(e),this._b=Math.round(r),this._a=Math.round(i);else{const s=i/255;this._r=Math.round(t*s),this._g=Math.round(e*s),this._b=Math.round(r*s),this._a=Math.round(i)}}static transparent(){return new t(0,0,0,0)}get premultipliedR(){return this._r}get premultipliedG(){return this._g}get premultipliedB(){return this._b}get premultipliedA(){return this._a}get r(){return 0===this._a?0:255===this._a?this._r:Math.round(255*this._r/this._a)}get g(){return 0===this._a?0:255===this._a?this._g:Math.round(255*this._g/this._a)}get b(){return 0===this._a?0:255===this._a?this._b:Math.round(255*this._b/this._a)}get a(){return this._a}toRGBA(){return[this.r,this.g,this.b,this.a]}toPremultipliedRGBA(){return[this._r,this._g,this._b,this._a]}get normalizedAlpha(){return this._a/255}get isTransparent(){return 0===this._a}get isOpaque(){return 255===this._a}withGlobalAlpha(e){if(e<0||e>1)throw new Error("Global alpha must be in range 0-1");const r=this.r,i=this.g,s=this.b,n=this.a,a=Math.round(n*e);return new t(r,i,s,a,!1)}blendOver(e){if(255===this._a)return this;if(0===this._a)return e;const r=1-this.normalizedAlpha,i=Math.round(this._r+e._r*r),s=Math.round(this._g+e._g*r),n=Math.round(this._b+e._b*r),a=Math.round(this._a+e._a*r);return new t(i,s,n,a,!0)}toBMP(){return{r:this.r,g:this.g,b:this.b}}toString(){return`Color(${this.r}, ${this.g}, ${this.b}, ${this.a})`}equals(e){return e instanceof t&&this._r===e._r&&this._g===e._g&&this._b===e._b&&this._a===e._a}}class e{constructor(t,e){if("number"!=typeof t||"number"!=typeof e)throw new Error("Point coordinates must be numbers");if(!isFinite(t)||!isFinite(e))throw new Error("Point coordinates must be finite numbers");this._x=t,this._y=e,Object.freeze(this)}get x(){return this._x}get y(){return this._y}static from(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Object must have numeric x and y properties");return new e(t.x,t.y)}distanceTo(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");const r=this._x-t._x,i=this._y-t._y;return Math.sqrt(r*r+i*i)}translate(t,r){return new e(this._x+t,this._y+r)}add(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return new e(this._x+t._x,this._y+t._y)}subtract(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return new e(this._x-t._x,this._y-t._y)}scale(t){if("number"!=typeof t)throw new Error("Scale factor must be a number");return new e(this._x*t,this._y*t)}scaleXY(t,r){if("number"!=typeof t||"number"!=typeof r)throw new Error("Scale factors must be numbers");return new e(this._x*t,this._y*r)}rotate(t){if("number"!=typeof t)throw new Error("Angle must be a number");const r=Math.cos(t),i=Math.sin(t);return new e(this._x*r-this._y*i,this._x*i+this._y*r)}rotateAround(t,r){if(!(t instanceof e))throw new Error("Center must be a Point instance");return this.subtract(t).rotate(r).add(t)}get magnitude(){return Math.sqrt(this._x*this._x+this._y*this._y)}get magnitudeSquared(){return this._x*this._x+this._y*this._y}normalize(){const t=this.magnitude;return 0===t?new e(0,0):new e(this._x/t,this._y/t)}dot(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return this._x*t._x+this._y*t._y}cross(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return this._x*t._y-this._y*t._x}round(){return new e(Math.round(this._x),Math.round(this._y))}floor(){return new e(Math.floor(this._x),Math.floor(this._y))}ceil(){return new e(Math.ceil(this._x),Math.ceil(this._y))}clamp(t,r,i,s){return new e(Math.max(t,Math.min(i,this._x)),Math.max(r,Math.min(s,this._y)))}lerp(t,r){if(!(t instanceof e))throw new Error("Target must be a Point instance");if("number"!=typeof r||r<0||r>1)throw new Error("Interpolation factor must be between 0 and 1");return new e(this._x+(t._x-this._x)*r,this._y+(t._y-this._y)*r)}toObject(){return{x:this._x,y:this._y}}toArray(){return[this._x,this._y]}equals(t,r=1e-10){return t instanceof e&&Math.abs(this._x-t._x)<r&&Math.abs(this._y-t._y)<r}isOrigin(t=1e-10){return Math.abs(this._x)<t&&Math.abs(this._y)<t}toString(){return`Point(${this._x}, ${this._y})`}}class r{constructor(t,e,r,i){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("Rectangle parameters must be numbers");if(!(isFinite(t)&&isFinite(e)&&isFinite(r)&&isFinite(i)))throw new Error("Rectangle parameters must be finite numbers");if(r<0||i<0)throw new Error("Rectangle dimensions must be non-negative");this._x=t,this._y=e,this._width=r,this._height=i,Object.freeze(this)}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this._x}get top(){return this._y}get right(){return this._x+this._width}get bottom(){return this._y+this._height}static boundingBox(t){if(!Array.isArray(t))throw new Error("Points must be an array");if(0===t.length)return new r(0,0,0,0);for(const r of t)if(!(r instanceof e))throw new Error("All items must be Point instances");let i=1/0,s=1/0,n=-1/0,a=-1/0;for(const e of t)i=Math.min(i,e.x),s=Math.min(s,e.y),n=Math.max(n,e.x),a=Math.max(a,e.y);return new r(i,s,n-i,a-s)}get center(){return new e(this._x+this._width/2,this._y+this._height/2)}get area(){return this._width*this._height}get perimeter(){return 2*(this._width+this._height)}get isEmpty(){return 0===this._width||0===this._height}get isSquare(){return this._width===this._height&&this._width>0}toString(){return`Rectangle(${this._x}, ${this._y}, ${this._width}, ${this._height})`}}class i{constructor(t){if(t&&Array.isArray(t)&&6===t.length){for(let e=0;e<6;e++)if("number"!=typeof t[e]||!isFinite(t[e]))throw new Error(`Transform2D component ${e} must be a finite number`);this.a=t[0],this.b=t[1],this.c=t[2],this.d=t[3],this.e=t[4],this.f=t[5]}else{if(t&&void 0!==t.length)throw new Error("Transform2D initialization array must have exactly 6 elements");this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0}Object.freeze(this)}static translation(t,e){return new i([1,0,0,1,t,e])}static scaling(t,e){return new i([t,0,0,e,0,0])}static rotation(t){const e=Math.cos(t),r=Math.sin(t);return new i([e,r,-r,e,0,0])}multiply(t){if(!(t instanceof i))throw new Error("Can only multiply with another Transform2D");return new i([this.a*t.a+this.b*t.c,this.a*t.b+this.b*t.d,this.c*t.a+this.d*t.c,this.c*t.b+this.d*t.d,this.e*t.a+this.f*t.c+t.e,this.e*t.b+this.f*t.d+t.f])}translate(t,e){const r=i.translation(t,e);return this.multiply(r)}scale(t,e){const r=i.scaling(t,e);return this.multiply(r)}rotate(t){const e=i.rotation(t);return this.multiply(e)}invert(){const t=this.a*this.d-this.b*this.c;if(Math.abs(t)<1e-10)throw new Error("Transform2D matrix is not invertible (determinant ≈ 0)");return new i([this.d/t,-this.b/t,-this.c/t,this.a/t,(this.c*this.f-this.d*this.e)/t,(this.b*this.e-this.a*this.f)/t])}transformPoint(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Point must have numeric x and y properties");return{x:this.a*t.x+this.c*t.y+this.e,y:this.b*t.x+this.d*t.y+this.f}}transformPoints(t){return t.map(t=>this.transformPoint(t))}toArray(){return[this.a,this.b,this.c,this.d,this.e,this.f]}get isIdentity(){return 1===this.a&&0===this.b&&0===this.c&&1===this.d&&0===this.e&&0===this.f}get determinant(){return this.a*this.d-this.b*this.c}equals(t,e=1e-10){return t instanceof i&&Math.abs(this.a-t.a)<e&&Math.abs(this.b-t.b)<e&&Math.abs(this.c-t.c)<e&&Math.abs(this.d-t.d)<e&&Math.abs(this.e-t.e)<e&&Math.abs(this.f-t.f)<e}toString(){return`Transform2D([${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e}, ${this.f}])`}}class s{constructor(){this.commands=[]}closePath(){this.commands.push({type:"closePath"})}moveTo(t,e){this.commands.push({type:"moveTo",x:t,y:e})}lineTo(t,e){this.commands.push({type:"lineTo",x:t,y:e})}bezierCurveTo(t,e,r,i,s,n){this.commands.push({type:"bezierCurveTo",cp1x:t,cp1y:e,cp2x:r,cp2y:i,x:s,y:n})}quadraticCurveTo(t,e,r,i){this.commands.push({type:"quadraticCurveTo",cpx:t,cpy:e,x:r,y:i})}rect(t,e,r,i){this.moveTo(t,e),this.lineTo(t+r,e),this.lineTo(t+r,e+i),this.lineTo(t,e+i),this.closePath()}arc(t,e,r,i,s,n){this.commands.push({type:"arc",x:t,y:e,radius:r,startAngle:i,endAngle:s,counterclockwise:!!n})}ellipse(t,e,r,i,s,n,a,o){this.commands.push({type:"ellipse",x:t,y:e,radiusX:r,radiusY:i,rotation:s,startAngle:n,endAngle:a,counterclockwise:!!o})}arcTo(t,e,r,i,s){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i||"number"!=typeof s){const t=new TypeError("All parameters must be numbers");throw t.message="TypeError: "+t.message,t}if(!(isFinite(t)&&isFinite(e)&&isFinite(r)&&isFinite(i)&&isFinite(s))){const t=new TypeError("All parameters must be finite numbers");throw t.message="TypeError: "+t.message,t}if(s<0){const t=new Error("IndexSizeError");throw t.name="IndexSizeError",t}this.commands.push({type:"arcTo",x1:t,y1:e,x2:r,y2:i,radius:s})}}class n{constructor(t,e){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("Surface width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("Surface height must be a positive integer");if(t*e>268435456)throw new Error("SurfaceTooLarge");const r=16384;if(t>r||e>r)throw new Error("Surface dimensions must be ≤ 16384x16384");Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1}),Object.defineProperty(this,"stride",{value:4*t,writable:!1}),this.data=new Uint8ClampedArray(this.stride*e)}clone(){const t=new n(this.width,this.height);return t.data.set(this.data),t}getPixel(e,r){if(e<0||e>=this.width||r<0||r>=this.height)return null;const i=r*this.stride+4*e;return new t(this.data[i],this.data[i+1],this.data[i+2],this.data[i+3],!1)}setPixel(e,r,i){if(e<0||e>=this.width||r<0||r>=this.height)return;if(!(i instanceof t))throw new Error("Color must be a Color instance");const s=r*this.stride+4*e;this.data[s]=i.r,this.data[s+1]=i.g,this.data[s+2]=i.b,this.data[s+3]=i.a}clear(e=t.transparent()){if(!(e instanceof t))throw new Error("Color must be a Color instance");const r=e.toRGBA();for(let t=0;t<this.data.length;t+=4)this.data[t]=r[0],this.data[t+1]=r[1],this.data[t+2]=r[2],this.data[t+3]=r[3]}getMemoryUsage(){return this.data.byteLength}toString(){const t=(this.getMemoryUsage()/1048576).toFixed(2);return`Surface(${this.width}×${this.height}, ${t}MB)`}}class a{static blendPixel(t,e,r,i,s,n,o,h,l){if(0===s)switch(t){case"destination-out":default:return{r:n,g:o,b:h,a:l};case"destination-atop":case"source-in":case"destination-in":case"source-out":return{r:0,g:0,b:0,a:0};case"copy":return{r:e,g:r,b:i,a:s}}if(0===l)switch(t){case"source-over":case"destination-over":case"destination-atop":case"source-out":case"xor":case"copy":default:return{r:e,g:r,b:i,a:s};case"source-atop":case"destination-out":case"source-in":case"destination-in":return{r:0,g:0,b:0,a:0}}const c=s/255,u=l/255;let f,d,g,m;switch(t){case"source-over":default:return a._sourceOver(e,r,i,s,n,o,h,l);case"destination-over":return a._sourceOver(n,o,h,l,e,r,i,s);case"source-atop":if(m=l,0===l)return{r:0,g:0,b:0,a:0};f=Math.round(c*e+(1-c)*n),d=Math.round(c*r+(1-c)*o),g=Math.round(c*i+(1-c)*h);break;case"destination-atop":if(m=s,0===s)return{r:0,g:0,b:0,a:0};f=Math.round(u*n+(1-u)*e),d=Math.round(u*o+(1-u)*r),g=Math.round(u*h+(1-u)*i);break;case"source-in":if(m=Math.round(s*u),0===m)return{r:0,g:0,b:0,a:0};f=e,d=r,g=i;break;case"destination-in":if(m=Math.round(l*c),0===m)return{r:0,g:0,b:0,a:0};f=n,d=o,g=h;break;case"source-out":if(m=Math.round(s*(1-u)),0===m)return{r:0,g:0,b:0,a:0};f=e,d=r,g=i;break;case"destination-out":if(m=Math.round(l*(1-c)),0===m)return{r:0,g:0,b:0,a:0};f=n,d=o,g=h;break;case"xor":return 0===c&&0===u?{r:0,g:0,b:0,a:0}:0===c?{r:n,g:o,b:h,a:l}:0===u?{r:e,g:r,b:i,a:s}:{r:0,g:0,b:0,a:0};case"copy":return{r:e,g:r,b:i,a:s}}return{r:Math.max(0,Math.min(255,Math.round(f))),g:Math.max(0,Math.min(255,Math.round(d))),b:Math.max(0,Math.min(255,Math.round(g))),a:Math.max(0,Math.min(255,Math.round(m)))}}static _sourceOver(t,e,r,i,s,n,a,o){if(255===i)return{r:t,g:e,b:r,a:i};const h=i/255,l=1-h;return{r:Math.round(t*h+s*l),g:Math.round(e*h+n*l),b:Math.round(r*h+a*l),a:Math.round(i+o*l)}}static getSupportedOperations(){return["source-over","destination-over","source-atop","destination-atop","source-in","destination-in","source-out","destination-out","xor","copy"]}static isSupported(t){return a.getSupportedOperations().includes(t)}}class o{constructor(t={r:255,g:255,b:255}){if(!t||"object"!=typeof t)throw new Error("backgroundColor must be an object with r, g, b properties");const{r:e,g:r,b:i}=t;if("number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("backgroundColor components (r, g, b) must be numbers");if(e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("backgroundColor components must be in range 0-255");this._backgroundColor=Object.freeze({r:Math.round(e),g:Math.round(r),b:Math.round(i)}),Object.freeze(this)}get backgroundColor(){return this._backgroundColor}static withBackgroundColor(t,e,r){return new o({r:t,g:e,b:r})}static withWhiteBackground(){return new o({r:255,g:255,b:255})}static withBlackBackground(){return new o({r:0,g:0,b:0})}static withGrayBackground(t=128){return new o({r:t,g:t,b:t})}equals(t){if(!(t instanceof o))return!1;const e=this._backgroundColor,r=t._backgroundColor;return e.r===r.r&&e.g===r.g&&e.b===r.b}toString(){const t=this._backgroundColor;return`BitmapEncodingOptions(backgroundColor: rgb(${t.r}, ${t.g}, ${t.b}))`}}o.DEFAULT=new o;class h{static encode(t,e=o.DEFAULT){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");const r=t.width,i=t.height,s=t.data,n=r*i*4;if(s.length!==n)throw new Error(`Surface data size mismatch. Expected ${n}, got ${s.length}`);const a=h._calculateDimensions(r,i),l=new ArrayBuffer(a.fileSize),c=new DataView(l),u=new Uint8Array(l);return h._writeBMPHeaders(c,a),h._writePixelData(u,s,t,a,e),l}static _calculateDimensions(t,e){const r=4*Math.floor((3*t+3)/4),i=r*e;return{width:t,height:e,rowSize:r,imageSize:i,fileSize:h.BMP_HEADER_SIZE+i}}static _writeBMPHeaders(t,e){h._writeBMPFileHeader(t,e.fileSize),h._writeBMPInfoHeader(t,e)}static _writeBMPFileHeader(t,e){const r=new Uint8Array(t.buffer);r[0]=66,r[1]=77,t.setUint32(2,e,!0),t.setUint32(6,0,!0),t.setUint32(10,h.BMP_HEADER_SIZE,!0)}static _writeBMPInfoHeader(t,e){t.setUint32(14,40,!0),t.setInt32(18,e.width,!0),t.setInt32(22,-e.height,!0),t.setUint16(26,1,!0),t.setUint16(28,24,!0),t.setUint32(30,0,!0),t.setUint32(34,e.imageSize,!0);t.setInt32(38,2835,!0),t.setInt32(42,2835,!0),t.setUint32(46,0,!0),t.setUint32(50,0,!0)}static _writePixelData(t,e,r,i,s){let n=h.BMP_HEADER_SIZE;for(let a=0;a<i.height;a++){let o=n;for(let n=0;n<i.width;n++){const i=a*r.stride+4*n,l=e[i],c=e[i+1],u=e[i+2],f=e[i+3],d=h._unpremultiplyAlpha(l,c,u,f,s.backgroundColor);t[o]=d.b,t[o+1]=d.g,t[o+2]=d.r,o+=3}for(;o-n<i.rowSize;)t[o]=0,o++;n+=i.rowSize}}static _unpremultiplyAlpha(t,e,r,i,s={r:255,g:255,b:255}){if(0===i)return{r:s.r,g:s.g,b:s.b};if(255===i)return{r:t,g:e,b:r};const n=i/255;return{r:Math.round(t*n+s.r*(1-n)),g:Math.round(e*n+s.g*(1-n)),b:Math.round(r*n+s.b*(1-n))}}static getBMPInfo(t){if(!t||!t.width||!t.height)throw new Error("Invalid surface");const e=h._calculateDimensions(t.width,t.height);return{width:e.width,height:e.height,bitsPerPixel:24,compression:"None",rowSize:e.rowSize,imageSize:e.imageSize,fileSize:e.fileSize,headerSize:h.BMP_HEADER_SIZE}}static canEncode(t){try{if(!t||"object"!=typeof t)return!1;if(!t.width||!t.height||!t.data)return!1;if(t.width<=0||t.height<=0)return!1;if(t.width>h.MAX_DIMENSION||t.height>h.MAX_DIMENSION)return!1;const e=t.width*t.height*4;return t.data.length===e}catch(t){return!1}}static calculateMemoryUsage(t,e){if(t<=0||e<=0)return 0;return h._calculateDimensions(t,e).fileSize}}h.BMP_HEADER_SIZE=54,h.MAX_DIMENSION=65535;class l{constructor(t={}){const{preserveTransparency:e=!0,compressionLevel:r=0}=t;if("boolean"!=typeof e)throw new Error("preserveTransparency must be a boolean");if("number"!=typeof r||r<0||r>9)throw new Error("compressionLevel must be a number between 0-9");if(0!==r)throw new Error("Only compression level 0 (no compression) is currently supported");this._config=Object.freeze({preserveTransparency:e,compressionLevel:r}),Object.freeze(this)}get preserveTransparency(){return this._config.preserveTransparency}get compressionLevel(){return this._config.compressionLevel}static withDefaults(){return new l}static withTransparency(){return new l({preserveTransparency:!0})}static withoutTransparency(){return new l({preserveTransparency:!1})}static withCompressionLevel(t){return new l({compressionLevel:t})}static forMaximumCompatibility(){return new l({preserveTransparency:!0,compressionLevel:0})}equals(t){if(!(t instanceof l))return!1;const e=this._config,r=t._config;return e.preserveTransparency===r.preserveTransparency&&e.compressionLevel===r.compressionLevel}toString(){const t=this._config;return`PngEncodingOptions(transparency: ${t.preserveTransparency}, compression: ${t.compressionLevel})`}withTransparency(t){return new l({preserveTransparency:t,compressionLevel:this._config.compressionLevel})}withCompression(t){return new l({preserveTransparency:this._config.preserveTransparency,compressionLevel:t})}}l.DEFAULT=new l;class c{static encode(t,e=l.DEFAULT){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");const r=t.width,i=t.height,s=t.data,n=r*i*4;if(s.length!==n)throw new Error(`Surface data size mismatch. Expected ${n}, got ${s.length}`);if(r<=0||i<=0)throw new Error("Surface dimensions must be positive");if(r>c.MAX_DIMENSION||i>c.MAX_DIMENSION)throw new Error(`Surface dimensions must be ≤ ${c.MAX_DIMENSION}x${c.MAX_DIMENSION}`);const a=c._createScanlines(r,i,s),o=c._createZlibData(a),h=c._createSignature(),u=c._createIHDRChunk(r,i),f=c._createIDATChunk(o),d=c._createIENDChunk(),g=h.length+u.length+f.length+d.length,m=new Uint8Array(g);let _=0;return m.set(h,_),_+=h.length,m.set(u,_),_+=u.length,m.set(f,_),_+=f.length,m.set(d,_),m.buffer}static _createSignature(){return new Uint8Array([137,80,78,71,13,10,26,10])}static _createScanlines(t,e,r){const i=new Uint8Array((4*t+1)*e);let s=0,n=0;for(let a=0;a<e;a++){i[n++]=0;for(let e=0;e<t;e++)i[n++]=r[s++],i[n++]=r[s++],i[n++]=r[s++],i[n++]=r[s++]}return i}static _createZlibData(t){const e=new Uint8Array([120,1]),r=[];let i=0;for(;i<t.length;){const e=t.length-i,s=Math.min(65535,e),n=i+s===t.length?1:0,a=new Uint8Array(5);a[0]=n,a[1]=255&s,a[2]=s>>>8&255;const o=65535&~s;a[3]=255&o,a[4]=o>>>8&255,r.push(a),r.push(t.subarray(i,i+s)),i+=s}const s=c._calculateAdler32(t),n=c._u32be(s);let a=e.length+n.length;for(const t of r)a+=t.length;const o=new Uint8Array(a);let h=0;o.set(e,h),h+=e.length;for(const t of r)o.set(t,h),h+=t.length;return o.set(n,h),o}static _createIHDRChunk(t,e){const r=new Uint8Array(13),i=c._u32be(t);r.set(i,0);const s=c._u32be(e);return r.set(s,4),r[8]=8,r[9]=6,r[10]=0,r[11]=0,r[12]=0,c._createChunk("IHDR",r)}static _createIDATChunk(t){return c._createChunk("IDAT",t)}static _createIENDChunk(){return c._createChunk("IEND",new Uint8Array(0))}static _createChunk(t,e){if(4!==t.length)throw new Error("Chunk type must be exactly 4 characters");const r=(new TextEncoder).encode(t),i=e.length,s=c._u32be(i),n=new Uint8Array(r.length+e.length);n.set(r,0),n.set(e,r.length);const a=c._calculateCRC32(n),o=c._u32be(a),h=new Uint8Array(8+i+4);let l=0;return h.set(s,l),l+=s.length,h.set(r,l),l+=r.length,h.set(e,l),l+=e.length,h.set(o,l),h}static _u32be(t){const e=new Uint8Array(4);return e[0]=t>>>24&255,e[1]=t>>>16&255,e[2]=t>>>8&255,e[3]=255&t,e}static _calculateCRC32(t){let e=4294967295;for(let r=0;r<t.length;r++){e^=t[r];for(let t=0;t<8;t++)e=e>>>1^3988292384&-(1&e)}return(4294967295^e)>>>0}static _calculateAdler32(t){let e=1,r=0;for(let i=0;i<t.length;i++)e=(e+t[i])%65521,r=(r+e)%65521;return(r<<16|e)>>>0}static getPNGInfo(t){if(!t||!t.width||!t.height)throw new Error("Invalid surface");const e=(4*t.width+1)*t.height,r=e+200;return{width:t.width,height:t.height,colorType:"RGBA (6)",bitDepth:8,compression:"DEFLATE (stored blocks)",filter:"None (0)",interlace:"None (0)",approximateFileSize:r,scanlineBytes:e}}static canEncode(t){try{if(!t||"object"!=typeof t)return!1;if(!t.width||!t.height||!t.data)return!1;if(t.width<=0||t.height<=0)return!1;if(t.width>c.MAX_DIMENSION||t.height>c.MAX_DIMENSION)return!1;const e=t.width*t.height*4;return t.data.length===e}catch(t){return!1}}static calculateMemoryUsage(t,e){return t<=0||e<=0?0:t*e*4+1*e+200}}c.MAX_DIMENSION=65535;class u{static flattenPath(t){const r=[];let i=[],s=new e(0,0),n=new e(0,0);for(const a of t.commands)switch(a.type){case"moveTo":u._handleMoveTo(a,r,i),s=new e(a.x,a.y),n=new e(a.x,a.y),i=[s.toObject()];break;case"lineTo":s=new e(a.x,a.y),i.push(s.toObject());break;case"closePath":u._handleClosePath(i,n,r),i=[];break;case"quadraticCurveTo":const t=u._flattenQuadraticBezier(s.x,s.y,a.cpx,a.cpy,a.x,a.y);u._appendPoints(i,t,1),s=new e(a.x,a.y);break;case"bezierCurveTo":const o=u._flattenCubicBezier(s.x,s.y,a.cp1x,a.cp1y,a.cp2x,a.cp2y,a.x,a.y);u._appendPoints(i,o,1),s=new e(a.x,a.y);break;case"arc":const h=u._handleArc(a,i,s,n);s=h.currentPoint,i=h.currentPoly,h.subpathStart&&(n=h.subpathStart);break;case"ellipse":const l=u._flattenEllipse(a.x,a.y,a.radiusX,a.radiusY,a.rotation,a.startAngle,a.endAngle,a.counterclockwise);u._handleEllipsePoints(l,i,s),l.length>0&&(s=new e(l[l.length-1].x,l[l.length-1].y));break;case"arcTo":const c=u._handleArcTo(a,i,s,n);s=c.currentPoint,i=c.currentPoly,c.subpathStart&&(n=c.subpathStart)}return i.length>0&&r.push(i),r}static _handleMoveTo(t,e,r){r.length>0&&e.push(r)}static _handleClosePath(t,e,r){if(t.length>0){const i=t[t.length-1];i.x===e.x&&i.y===e.y||t.push(e.toObject()),r.push(t)}}static _appendPoints(t,e,r){for(let i=r;i<e.length;i++)t.push(e[i])}static _handleArc(t,r,i,s){const n=u._flattenArc(t.x,t.y,t.radius,t.startAngle,t.endAngle,t.counterclockwise);if(0===n.length)return{currentPoint:i,currentPoly:r,subpathStart:null};const a=new e(n[0].x,n[0].y);if(0===r.length){r.push(a.toObject());const t=a,i=a;return u._appendPoints(r,n,1),{currentPoint:n.length>1?new e(n[n.length-1].x,n[n.length-1].y):t,currentPoly:r,subpathStart:i}}return i.distanceTo(a)>.01&&r.push(a.toObject()),u._appendPoints(r,n,1),{currentPoint:new e(n[n.length-1].x,n[n.length-1].y),currentPoly:r,subpathStart:null}}static _handleEllipsePoints(t,r,i){if(t.length>0){const s=new e(t[0].x,t[0].y);i.distanceTo(s)>.01&&r.push(s.toObject()),u._appendPoints(r,t,1)}}static _flattenQuadraticBezier(t,e,r,i,s,n){const a=[{x:t,y:e}];return u._flattenQuadraticBezierRecursive(t,e,r,i,s,n,a,u.TOLERANCE),a}static _flattenQuadraticBezierRecursive(t,e,r,i,s,n,a,o){const h=s-t,l=n-e;if(Math.abs((r-t)*l-(i-e)*h)/Math.sqrt(h*h+l*l)<=o||a.length>1e3)return void a.push({x:s,y:n});const c=(t+r)/2,f=(e+i)/2,d=(r+s)/2,g=(i+n)/2,m=(c+d)/2,_=(f+g)/2;u._flattenQuadraticBezierRecursive(t,e,c,f,m,_,a,o),u._flattenQuadraticBezierRecursive(m,_,d,g,s,n,a,o)}static _flattenCubicBezier(t,e,r,i,s,n,a,o){const h=[{x:t,y:e}];return u._flattenCubicBezierRecursive(t,e,r,i,s,n,a,o,h,u.TOLERANCE),h}static _flattenCubicBezierRecursive(t,e,r,i,s,n,a,o,h,l){const c=a-t,f=o-e,d=Math.sqrt(c*c+f*f);if(0===d)return void h.push({x:a,y:o});if(Math.abs((r-t)*f-(i-e)*c)/d+Math.abs((s-t)*f-(n-e)*c)/d<=l||h.length>1e3)return void h.push({x:a,y:o});const g=(t+r)/2,m=(e+i)/2,_=(r+s)/2,p=(i+n)/2,b=(s+a)/2,w=(n+o)/2,y=(g+_)/2,x=(m+p)/2,M=(_+b)/2,P=(p+w)/2,S=(y+M)/2,O=(x+P)/2;u._flattenCubicBezierRecursive(t,e,g,m,y,x,S,O,h,l),u._flattenCubicBezierRecursive(S,O,M,P,b,w,a,o,h,l)}static _flattenArc(t,e,r,i,s,n){if(r<=0)return[];let a=i,o=s;!n&&o<a?o+=2*Math.PI:n&&a<o&&(a+=2*Math.PI);const h=Math.abs(o-a),l=2*Math.acos(Math.max(0,1-u.TOLERANCE/r)),c=Math.max(1,Math.ceil(h/l)),f=[],d=(o-a)/c;for(let i=0;i<=c;i++){const s=a+i*d;f.push({x:t+r*Math.cos(s),y:e+r*Math.sin(s)})}return f}static _flattenEllipse(t,e,r,i,s,n,a,o){if(r<=0||i<=0)return[];let h=n,l=a;!o&&l<h?l+=2*Math.PI:o&&h<l&&(h+=2*Math.PI);const c=Math.abs(l-h),f=Math.min(r,i),d=2*Math.acos(Math.max(0,1-u.TOLERANCE/f)),g=Math.max(1,Math.ceil(c/d)),m=[],_=(l-h)/g,p=Math.cos(s),b=Math.sin(s);for(let s=0;s<=g;s++){const n=h+s*_,a=r*Math.cos(n),o=i*Math.sin(n);m.push({x:t+a*p-o*b,y:e+a*b+o*p})}return m}static _flattenArcWithTolerance(t,e,r,i,s,n,a){if(r<=0)return[];let o=i,h=s;!n&&h<o?h+=2*Math.PI:n&&o<h&&(o+=2*Math.PI);const l=Math.abs(h-o),c=2*Math.acos(Math.max(0,1-a/r)),u=Math.ceil(l/(Math.PI/2)*16),f=Math.ceil(l/c),d=Math.max(1,Math.max(u,f)),g=[],m=(h-o)/d;for(let i=0;i<=d;i++){const s=o+i*m;g.push({x:t+r*Math.cos(s),y:e+r*Math.sin(s)})}return g}static _handleArcTo(t,r,i,s){const{x1:n,y1:a,x2:o,y2:h,radius:l}=t;if(0===r.length){const t=new e(n,a);return r.push(t.toObject()),{currentPoint:t,currentPoly:r,subpathStart:t}}if(l<=0){const t=new e(n,a);return r.push(t.toObject()),{currentPoint:t,currentPoly:r,subpathStart:null}}const c=i,f=new e(n,a),d=new e(o,h),g=new e(c.x-f.x,c.y-f.y),m=new e(d.x-f.x,d.y-f.y),_=Math.sqrt(g.x*g.x+g.y*g.y),p=Math.sqrt(m.x*m.x+m.y*m.y);if(_<1e-10||p<1e-10){const t=new e(n,a);return r.push(t.toObject()),{currentPoint:t,currentPoly:r,subpathStart:null}}const b=new e(g.x/_,g.y/_),w=new e(m.x/p,m.y/p),y=b.x*w.x+b.y*w.y,x=b.x*w.y-b.y*w.x,M=Math.max(-1,Math.min(1,y)),P=Math.acos(M);if(Math.abs(Math.sin(P))<1e-10){const t=new e(n,a);return r.push(t.toObject()),{currentPoint:t,currentPoly:r,subpathStart:null}}const S=P/2,O=l/Math.tan(S),C=new e(f.x+b.x*O,f.y+b.y*O),E=new e(f.x+w.x*O,f.y+w.y*O),v=new e(-b.y,b.x),A=(new e(-w.y,w.x),Math.sign(x)),k=new e(C.x+v.x*A*l,C.y+v.y*A*l),B=Math.atan2(C.y-k.y,C.x-k.x),I=Math.atan2(E.y-k.y,E.x-k.x),D=A>0;i.distanceTo(C)>.01&&r.push(C.toObject());const T=Math.min(.1,u.TOLERANCE),X=u._flattenArcWithTolerance(k.x,k.y,l,B,I,D,T);u._appendPoints(r,X,1);return{currentPoint:X.length>0?new e(X[X.length-1].x,X[X.length-1].y):E,currentPoly:r,subpathStart:null}}}u.TOLERANCE=.25;class f{static fillPolygons(t,e,r,i,s,n,a=1,o=1,h="source-over",l=null){if(0===e.length)return;if(!f._isValidPaintSource(r))throw new Error("Paint source must be a Color, Gradient, or Pattern instance");const c=e.map(t=>t.map(t=>s.transformPoint(t))),u=f._calculateBounds(c,t);for(let e=u.minY;e<=u.maxY;e++)f._fillScanline(t,e,c,r,i,n,s,a,o,h,l)}static _calculateBounds(t,e){let r=1/0,i=-1/0;for(const e of t)for(const t of e)r=Math.min(r,t.y),i=Math.max(i,t.y);return{minY:Math.max(0,Math.floor(r)),maxY:Math.min(e.height-1,Math.ceil(i))}}static _fillScanline(t,e,r,i,s,n,a,o,h=1,l="source-over",c=null){const u=[];for(const t of r)f._findPolygonIntersections(t,e+.5,u);u.sort((t,e)=>t.x-e.x),f._fillSpans(t,e,u,i,s,n,a,o,h,l,c)}static _findPolygonIntersections(t,e,r){for(let i=0;i<t.length;i++){const s=t[i],n=t[(i+1)%t.length];if(Math.abs(s.y-n.y)<1e-10)continue;const a=Math.min(s.y,n.y),o=Math.max(s.y,n.y);if(e>=a&&e<o){const t=(e-s.y)/(n.y-s.y),i=s.x+t*(n.x-s.x),a=n.y>s.y?1:-1;r.push({x:i,winding:a})}}}static _fillSpans(t,e,r,i,s,n,a,o,h=1,l="source-over",c=null){if(0===r.length)return;let u=0,d=!1;for(let g=0;g<r.length;g++){const m=r[g],_=r[g+1];if(u+=m.winding,d="evenodd"===s?u%2!=0:0!==u,d&&_){const r=Math.max(0,Math.ceil(m.x)),s=Math.min(t.width-1,Math.floor(_.x));f._fillPixelSpan(t,e,r,s,i,n,a,o,h,l,c)}}}static _fillPixelSpan(t,e,r,i,s,n,a,o,h=1,l="source-over",c=null){for(let u=r;u<=i;u++){if(n&&n.isPixelClipped(u,e))continue;if(c){c.setPixel(u,e,!0);continue}const r=f._evaluatePaintSource(s,u,e,a,o,h),i=e*t.stride+4*u;f._blendPixel(t,i,r,l)}}static _blendPixel(t,e,r,i="source-over"){const s=t.data[e],n=t.data[e+1],o=t.data[e+2],h=t.data[e+3],l=a.blendPixel(i,r.r,r.g,r.b,r.a,s,n,o,h);t.data[e]=l.r,t.data[e+1]=l.g,t.data[e+2]=l.b,t.data[e+3]=l.a}static colorFromRGBA(e){return new t(e[0],e[1],e[2],e[3],!1)}static getPolygonBounds(t){if(0===t.length)return new r(0,0,0,0);const i=t.flat();return r.boundingBox(i.map(t=>new e(t.x,t.y)))}static countVertices(t){return t.reduce((t,e)=>t+e.length,0)}static _isValidPaintSource(e){return e instanceof t||e instanceof x||e instanceof M||e instanceof P||e instanceof S||e instanceof O}static _evaluatePaintSource(e,r,i,s,n,a=1){let o;o=e instanceof t?e:e instanceof x||e instanceof M||e instanceof P||e instanceof S||e instanceof O?e.getColorForPixel(r,i,s):new t(0,0,0,0);let h=o.withGlobalAlpha(n);if(a<1){const e=Math.round(h.a*a);h=new t(h.r,h.g,h.b,e,h.premultiplied)}return h}static isPointInPolygons(t,e,r,i="nonzero"){if(0===r.length)return!1;for(const i of r)if(!(i.length<3))for(let r=0;r<i.length;r++){const s=i[r],n=i[(r+1)%i.length];if(f._isPointOnEdge(t,e,s,n,1e-10))return!0}let s=0;for(const i of r)if(!(i.length<3))for(let r=0;r<i.length;r++){const n=i[r],a=i[(r+1)%i.length];if(Math.abs(n.y-a.y)<1e-10)continue;const o=Math.min(n.y,a.y),h=Math.max(n.y,a.y);if(e>=o&&e<h){const r=(e-n.y)/(a.y-n.y);if(n.x+r*(a.x-n.x)>=t){s+=a.y>n.y?1:-1}}}return"evenodd"===i?s%2!=0:0!==s}static _isPointOnEdge(t,e,r,i,s){const n=i.x-r.x,a=i.y-r.y,o=Math.sqrt(n*n+a*a);if(o<s)return Math.abs(t-r.x)<s&&Math.abs(e-r.y)<s;const h=t-r.x,l=e-r.y;if(Math.abs(h*a-l*n)>s*o)return!1;const c=(h*n+l*a)/(n*n+a*a);return c>=-s&&c<=1+s}}class d{static generateStrokePolygons(t,e){const r=d._validateStrokeProperties(e);if(r.lineWidth<=0)return[];const i=u.flattenPath(t),s=d._applyDashPattern(i,r),n=[];for(const t of s){if(t.length<2)continue;const e=d._generateStrokeForPolygon(t,r);n.push(...e)}return n}static _validateStrokeProperties(t){const e={lineWidth:1,lineJoin:"miter",lineCap:"butt",miterLimit:10,lineDash:[],lineDashOffset:0,...t};if(e.lineWidth<0)throw new Error("lineWidth must not be negative");if(!["miter","round","bevel"].includes(e.lineJoin))throw new Error(`Invalid lineJoin: ${e.lineJoin}`);if(!["butt","round","square"].includes(e.lineCap))throw new Error(`Invalid lineCap: ${e.lineCap}`);if(e.miterLimit<=0)throw new Error("miterLimit must be positive");return e}static _applyDashPattern(t,e){if(!e.lineDash||0===e.lineDash.length)return t;const r=[];for(const i of t){if(i.length<2)continue;const t=d._dashPolygon(i,e.lineDash,e.lineDashOffset);r.push(...t)}return r}static _dashPolygon(t,e,r){if(t.length<2)return[];const i=[],s=e.reduce((t,e)=>t+e,0);if(s<=0)return[t];let n=r%s;n<0&&(n+=s);let a=n,o=0,h=!0,l=0;for(let t=0;t<e.length;t++){if(l+e[t]>n){o=t,a=n-l,h=t%2==0;break}l+=e[t]}let c=[];for(let r=0;r<t.length-1;r++){const s=t[r],n=t[r+1],l=Math.sqrt(Math.pow(n.x-s.x,2)+Math.pow(n.y-s.y,2));if(0===l)continue;const u=d._processSegmentWithDash(s,n,l,e,o,a,h,c,i);o=u.patternIndex,a=u.patternPosition,h=u.isDash,c=u.currentSegment}return c.length>1&&i.push(c),i}static _processSegmentWithDash(t,e,r,i,s,n,a,o,h){let l=r,c=t;for(a&&0===o.length&&o.push({x:t.x,y:t.y});l>0;){const u=i[s],f=u-n,d=Math.min(l,f),g=(r-l+d)/r,m={x:t.x+g*(e.x-t.x),y:t.y+g*(e.y-t.y)};a&&o.push({x:m.x,y:m.y}),l-=d,(n+=d)>=u&&(a&&o.length>1&&(h.push(o),o=[]),s=(s+1)%i.length,n=0,(a=!a)&&l>0&&(o=[{x:m.x,y:m.y}])),c=m}return{patternIndex:s,patternPosition:n,isDash:a,currentSegment:o}}static _generateStrokeForPolygon(t,e){if(t.length<2)return[];const r=[],i=e.lineWidth/2,s=d._isPathClosed(t),n=d._generateSegments(t,i);if(0===n.length)return[];for(const t of n)r.push(t.body);return d._generateJoins(n,r,e,s),!s&&n.length>0&&d._generateCaps(n,r,e,i),r}static _isPathClosed(t){return t.length>2&&Math.abs(t[0].x-t[t.length-1].x)<1e-10&&Math.abs(t[0].y-t[t.length-1].y)<1e-10}static _generateSegments(t,r){const i=[];for(let s=0;s<t.length-1;s++){const n=new e(t[s].x,t[s].y),a=new e(t[s+1].x,t[s+1].y),o=n.distanceTo(a);if(o<1e-10)continue;const h=d._createSegment(n,a,r,o);i.push(h)}return i}static _createSegment(t,r,i,s){const n=r.subtract(t).scale(1/s),a=new e(-n.y,n.x);return{body:[t.add(a.scale(i)).toObject(),r.add(a.scale(i)).toObject(),r.add(a.scale(-i)).toObject(),t.add(a.scale(-i)).toObject()],p1:t,p2:r,tangent:n,normal:a,length:s}}static _generateJoins(t,e,r,i){for(let i=0;i<t.length-1;i++){const s=t[i],n=t[i+1],a=d._generateJoin(s,n,r);e.push(...a)}if(i&&t.length>1){const i=t[t.length-1],s=t[0],n=d._generateJoin(i,s,r);e.push(...n)}}static _generateJoin(t,e,r){const i=e.p1,s=t.tangent.cross(e.tangent);if(Math.abs(s)<1e-10)return d._generateBevelJoin(t,e,i);switch(r.lineJoin){case"miter":return d._generateMiterJoin(t,e,i,r.miterLimit);case"round":return d._generateRoundJoin(t,e,i);default:return d._generateBevelJoin(t,e,i)}}static _generateMiterJoin(t,e,r,i){const s=Math.sqrt(Math.pow(t.body[0].x-t.body[3].x,2)+Math.pow(t.body[0].y-t.body[3].y,2))/2,n=t.tangent.cross(e.tangent);let a,o;n>0?(a=t.body[2],o=e.body[3]):(a=t.body[1],o=e.body[0]);const h={x:a.x+100*t.tangent.x,y:a.y+100*t.tangent.y},l={x:o.x-100*e.tangent.x,y:o.y-100*e.tangent.y},c=d._lineIntersection(a,h,o,l);if(!c)return d._generateBevelJoin(t,e,r);if(Math.sqrt(Math.pow(c.x-r.x,2)+Math.pow(c.y-r.y,2))/s>i)return d._generateBevelJoin(t,e,r);let u,f;return n>0?(u=t.body[1],f=e.body[0]):(u=t.body[2],f=e.body[3]),[[a,c,o],[a,o,f,u]]}static _generateBevelJoin(t,e,r){const i=t.tangent.cross(e.tangent),s=d._getOuterSides(t,e,i),n=d._getInnerSides(t,e,i);return[[s.outer1,s.outer2,n.inner2,n.inner1]]}static _generateRoundJoin(t,e,r){const i=Math.sqrt(Math.pow(t.body[0].x-t.body[3].x,2)+Math.pow(t.body[0].y-t.body[3].y,2))/2;let s,n;t.tangent.cross(e.tangent)>0?(s=t.body[2],n=e.body[3]):(s=t.body[1],n=e.body[0]);let a=Math.atan2(s.y-r.y,s.x-r.x),o=Math.atan2(n.y-r.y,n.x-r.x),h=o-a;if(h>Math.PI?h-=2*Math.PI:h<-Math.PI&&(h+=2*Math.PI),h<0){const t=a;a=o,o=t,h=-h}const l=Math.max(2,Math.ceil(h/(Math.PI/4))),c=h/l,u=[];for(let t=0;t<l;t++){const e=a+t*c,s=a+(t+1)*c,n={x:r.x+i*Math.cos(e),y:r.y+i*Math.sin(e)},o={x:r.x+i*Math.cos(s),y:r.y+i*Math.sin(s)};u.push([r.toObject(),n,o])}return u}static _generateCaps(t,e,r,i){const s=d._generateCap(t[0].p1,t[0].tangent,i,r.lineCap,!0);s&&e.push(...Array.isArray(s[0])?s:[s]);const n=t[t.length-1],a=d._generateCap(n.p2,n.tangent,i,r.lineCap,!1);a&&e.push(...Array.isArray(a[0])?a:[a])}static _generateCap(t,r,i,s,n){const a=new e(-r.y,r.x);switch(s){case"square":return d._generateSquareCap(t,r,a,i,n);case"round":return d._generateRoundCap(t,a,i,n);default:return null}}static _generateSquareCap(t,e,r,i,s){const n=s?t.subtract(e.scale(i)):t.add(e.scale(i));return[[n.add(r.scale(i)).toObject(),n.subtract(r.scale(i)).toObject(),t.subtract(r.scale(i)).toObject(),t.add(r.scale(i)).toObject()]]}static _generateRoundCap(t,e,r,i){const s=Math.atan2(e.y,e.x);return d._generateArcFan(t,r,s,s+Math.PI*(i?1:-1))}static _getOuterSides(t,e,r){return r>0?{outer1:t.body[2],outer2:e.body[3]}:{outer1:t.body[1],outer2:e.body[0]}}static _getInnerSides(t,e,r){return r>0?{inner1:t.body[1],inner2:e.body[0]}:{inner1:t.body[2],inner2:e.body[3]}}static _lineIntersection(t,e,r,i){const s=(t.x-e.x)*(r.y-i.y)-(t.y-e.y)*(r.x-i.x);if(Math.abs(s)<1e-10)return null;const n=((t.x-r.x)*(r.y-i.y)-(t.y-r.y)*(r.x-i.x))/s;return{x:t.x+n*(e.x-t.x),y:t.y+n*(e.y-t.y)}}static _generateArcFan(t,e,r,i){let s=i-r;for(;s>Math.PI;)s-=2*Math.PI;for(;s<-Math.PI;)s+=2*Math.PI;const n=Math.abs(s),a=Math.max(2,Math.ceil(n/(Math.PI/4))),o=s/a,h=[];for(let i=0;i<a;i++){const s=r+i*o,n=r+(i+1)*o,a={x:t.x+e*Math.cos(s),y:t.y+e*Math.sin(s)},l={x:t.x+e*Math.cos(n),y:t.y+e*Math.sin(n)};h.push([t.toObject(),a,l])}return h}}class g{constructor(t,e,r=0){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("BitBuffer width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("BitBuffer height must be a positive integer");if(0!==r&&1!==r)throw new Error("BitBuffer defaultValue must be 0 or 1");this._width=t,this._height=e,this._numPixels=t*e,this._numBytes=Math.ceil(this._numPixels/8),this._defaultValue=r,this._buffer=new Uint8Array(this._numBytes),this._initializeToDefault(),Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}_initializeToDefault(){if(1===this._defaultValue){this._buffer.fill(255);const t=this._numPixels%8;if(0!==t){const e=this._numBytes-1,r=(1<<t)-1;this._buffer[e]=r}}else this._buffer.fill(0)}getPixel(t,e){if(t<0||t>=this._width||e<0||e>=this._height)return!1;const r=e*this._width+t;return 1===this._getBit(r)}setPixel(t,e,r){if(t<0||t>=this._width||e<0||e>=this._height)return;const i=e*this._width+t;this._setBit(i,r?1:0)}clear(){this._buffer.fill(0)}fill(){this._buffer.fill(255);const t=this._numPixels%8;if(0!==t){const e=this._numBytes-1,r=(1<<t)-1;this._buffer[e]=r}}reset(){this._initializeToDefault()}and(t){if(!(t instanceof g))throw new Error("Argument must be a BitBuffer instance");if(t._width!==this._width||t._height!==this._height)throw new Error("BitBuffer dimensions must match for AND operation");for(let e=0;e<this._numBytes;e++)this._buffer[e]&=t._buffer[e]}copyFrom(t){if(!(t instanceof g))throw new Error("Argument must be a BitBuffer instance");if(t._width!==this._width||t._height!==this._height)throw new Error("BitBuffer dimensions must match for copy operation");this._buffer.set(t._buffer)}isFull(){for(let t=0;t<this._numBytes-1;t++)if(255!==this._buffer[t])return!1;const t=this._numPixels%8;if(0===t)return 255===this._buffer[this._numBytes-1];{const e=(1<<t)-1;return this._buffer[this._numBytes-1]===e}}isEmpty(){for(let t=0;t<this._numBytes;t++)if(0!==this._buffer[t])return!1;return!0}getMemoryUsage(){return this._buffer.byteLength}_getBit(t){const e=Math.floor(t/8),r=t%8;return e>=this._buffer.length?0:this._buffer[e]&1<<r?1:0}_setBit(t,e){const r=Math.floor(t/8),i=t%8;r>=this._buffer.length||(e?this._buffer[r]|=1<<i:this._buffer[r]&=~(1<<i))}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this.isEmpty()?"empty":this.isFull()?"full":"mixed";return`BitBuffer(${this._width}×${this._height}, ${t}KB, ${e})`}equals(t){if(!(t instanceof g))return!1;if(t._width!==this._width||t._height!==this._height)return!1;for(let e=0;e<this._numBytes;e++)if(this._buffer[e]!==t._buffer[e])return!1;return!0}}class m{constructor(t,e){this._bitBuffer=new g(t,e,1),Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}getPixel(t,e){return this._bitBuffer.getPixel(t,e)}setPixel(t,e,r){this._bitBuffer.setPixel(t,e,r)}isPixelClipped(t,e){return!this.getPixel(t,e)}clear(){this._bitBuffer.fill()}clipAll(){this._bitBuffer.clear()}intersectWith(t){if(!(t instanceof m))throw new Error("Argument must be a ClipMask instance");this._bitBuffer.and(t._bitBuffer)}clone(){const t=new m(this.width,this.height);return t._bitBuffer.copyFrom(this._bitBuffer),t}createPixelWriter(){return(t,e,r)=>{if(t<0||t>=this._width||e<0||e>=this._height)return;const i=r>.5;this.setPixel(t,e,i)}}getMemoryUsage(){return this._bitBuffer.getMemoryUsage()}hasClipping(){return!this._bitBuffer.isFull()}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this.hasClipping()?"with clipping":"no clipping";return`ClipMask(${this.width}×${this.height}, ${t}KB, ${e})`}equals(t){return t instanceof m&&this._bitBuffer.equals(t._bitBuffer)}}class _{constructor(t,e){this._bitBuffer=new g(t,e,0),this._bounds={minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0,isEmpty:!0},Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}getPixel(t,e){return this._bitBuffer.getPixel(t,e)}setPixel(t,e,r){if(t<0||t>=this.width||e<0||e>=this.height)return;const i=this._bitBuffer.getPixel(t,e);this._bitBuffer.setPixel(t,e,r),r&&!i&&(this._bounds.isEmpty?(this._bounds.minX=t,this._bounds.minY=e,this._bounds.maxX=t,this._bounds.maxY=e,this._bounds.isEmpty=!1):(this._bounds.minX=Math.min(this._bounds.minX,t),this._bounds.minY=Math.min(this._bounds.minY,e),this._bounds.maxX=Math.max(this._bounds.maxX,t),this._bounds.maxY=Math.max(this._bounds.maxY,e)))}clear(){this._bitBuffer.clear(),this._bounds={minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0,isEmpty:!0}}isEmpty(){return this._bounds.isEmpty}getBounds(){return{minX:this._bounds.minX,minY:this._bounds.minY,maxX:this._bounds.maxX,maxY:this._bounds.maxY,isEmpty:this._bounds.isEmpty}}getIterationBounds(t=null,e=!1){if(this._bounds.isEmpty)return{minX:0,minY:0,maxX:-1,maxY:-1,isEmpty:!0};if(e)return t&&t.hasClipping(),{minX:0,minY:0,maxX:this.width-1,maxY:this.height-1,isEmpty:!1};return{minX:Math.max(0,this._bounds.minX),minY:Math.max(0,this._bounds.minY),maxX:Math.min(this.width-1,this._bounds.maxX),maxY:Math.min(this.height-1,this._bounds.maxY),isEmpty:!1}}createPixelWriter(){return(t,e,r)=>{if(t<0||t>=this.width||e<0||e>=this.height)return;const i=r>.5;this.setPixel(t,e,i)}}getMemoryUsage(){return this._bitBuffer.getMemoryUsage()}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this._bounds.isEmpty?"empty":`(${this._bounds.minX},${this._bounds.minY})-(${this._bounds.maxX},${this._bounds.maxY})`;return`SourceMask(${this.width}×${this.height}, ${t}KB, bounds: ${e})`}}class p{constructor(t,e,r=0){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("ShadowBuffer width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("ShadowBuffer height must be a positive integer");if("number"!=typeof r||r<0)throw new Error("ShadowBuffer maxBlurRadius must be a non-negative number");this._originalWidth=t,this._originalHeight=e,this._maxBlurRadius=Math.ceil(r);const i=this._maxBlurRadius;this._extendedWidth=t+2*i,this._extendedHeight=e+2*i,this._extendedOffsetX=i,this._extendedOffsetY=i,this._alphaData={},this._bounds={minX:1/0,maxX:-1/0,minY:1/0,maxY:-1/0,isEmpty:!0},Object.defineProperty(this,"originalWidth",{value:t,writable:!1}),Object.defineProperty(this,"originalHeight",{value:e,writable:!1}),Object.defineProperty(this,"extendedWidth",{value:this._extendedWidth,writable:!1}),Object.defineProperty(this,"extendedHeight",{value:this._extendedHeight,writable:!1}),Object.defineProperty(this,"extendedOffsetX",{value:this._extendedOffsetX,writable:!1}),Object.defineProperty(this,"extendedOffsetY",{value:this._extendedOffsetY,writable:!1})}addAlpha(t,e,r){if(r<=0)return;const i=t+this._extendedOffsetX,s=e+this._extendedOffsetY;if(i<0||i>=this._extendedWidth||s<0||s>=this._extendedHeight)return;const n=`${i},${s}`,a=this._alphaData[n]||0;this._alphaData[n]=Math.min(1,a+r),this._bounds.isEmpty?(this._bounds.minX=this._bounds.maxX=i,this._bounds.minY=this._bounds.maxY=s,this._bounds.isEmpty=!1):(this._bounds.minX=Math.min(this._bounds.minX,i),this._bounds.maxX=Math.max(this._bounds.maxX,i),this._bounds.minY=Math.min(this._bounds.minY,s),this._bounds.maxY=Math.max(this._bounds.maxY,s))}getAlpha(t,e){if(t<0||t>=this._extendedWidth||e<0||e>=this._extendedHeight)return 0;const r=`${t},${e}`;return this._alphaData[r]||0}setAlpha(t,e,r){if(t<0||t>=this._extendedWidth||e<0||e>=this._extendedHeight)return;const i=`${t},${e}`;r<=0?delete this._alphaData[i]:(this._alphaData[i]=Math.min(1,r),this._bounds.isEmpty?(this._bounds.minX=this._bounds.maxX=t,this._bounds.minY=this._bounds.maxY=e,this._bounds.isEmpty=!1):(this._bounds.minX=Math.min(this._bounds.minX,t),this._bounds.maxX=Math.max(this._bounds.maxX,t),this._bounds.minY=Math.min(this._bounds.minY,e),this._bounds.maxY=Math.max(this._bounds.maxY,e)))}clear(){this._alphaData={},this._bounds={minX:1/0,maxX:-1/0,minY:1/0,maxY:-1/0,isEmpty:!0}}getBounds(){return{minX:this._bounds.minX,maxX:this._bounds.maxX,minY:this._bounds.minY,maxY:this._bounds.maxY,isEmpty:this._bounds.isEmpty}}*getPixels(){for(const t in this._alphaData){const e=this._alphaData[t];if(e>0){const r=t.split(","),i=parseInt(r[0],10),s=parseInt(r[1],10);yield{x:i,y:s,alpha:e}}}}getPixelCount(){let t=0;for(const e in this._alphaData)this._alphaData[e]>0&&t++;return t}clone(){const t=new p(this._originalWidth,this._originalHeight,this._maxBlurRadius);for(const e in this._alphaData)t._alphaData[e]=this._alphaData[e];return t._bounds={minX:this._bounds.minX,maxX:this._bounds.maxX,minY:this._bounds.minY,maxY:this._bounds.maxY,isEmpty:this._bounds.isEmpty},t}toDenseArray(){if(this._bounds.isEmpty)return{data:new Float32Array(0),width:0,height:0,offsetX:0,offsetY:0};const t=this._maxBlurRadius,e=Math.max(0,this._bounds.minX-t),r=Math.min(this._extendedWidth-1,this._bounds.maxX+t),i=Math.max(0,this._bounds.minY-t),s=Math.min(this._extendedHeight-1,this._bounds.maxY+t),n=r-e+1,a=s-i+1,o=new Float32Array(n*a);for(let t=i;t<=s;t++)for(let s=e;s<=r;s++){const r=this.getAlpha(s,t);if(r>0){o[(t-i)*n+(s-e)]=r}}return{data:o,width:n,height:a,offsetX:e,offsetY:i}}fromDenseArray(t,e,r,i,s){this.clear();for(let n=0;n<r;n++)for(let r=0;r<e;r++){const a=t[n*e+r];if(a>0){const t=r+i,e=n+s;this.setAlpha(t,e,a)}}}}class b{static blur(t,e,r,i,s=3){if(!(t&&t instanceof Float32Array))throw new Error("BoxBlur requires Float32Array data");if("number"!=typeof e||e<=0||"number"!=typeof r||r<=0)throw new Error("BoxBlur width and height must be positive numbers");if(t.length!==e*r)throw new Error("BoxBlur data length must match width * height");if("number"!=typeof i||i<0)throw new Error("BoxBlur radius must be a non-negative number");if("number"!=typeof s||s<1)throw new Error("BoxBlur passes must be at least 1");if(0===i)return new Float32Array(t);const n=i/2,a=Math.floor(Math.max(Math.sqrt(12*n*n/s+1),3)),o=a%2==0?a+1:a;let h=new Float32Array(t);for(let t=0;t<s;t++)h=b._singleBoxBlurPass(h,e,r,o);return h}static _singleBoxBlurPass(t,e,r,i){const s=Math.floor(i/2),n=b._horizontalBoxBlur(t,e,r,s);return b._verticalBoxBlur(n,e,r,s)}static _horizontalBoxBlur(t,e,r,i){const s=new Float32Array(t.length);for(let n=0;n<r;n++){const r=n*e;let a=0,o=0;for(let s=-i;s<=i;s++){a+=t[r+Math.max(0,Math.min(e-1,s))],o++}s[r]=a/o;for(let n=1;n<e;n++){const h=Math.max(0,Math.min(e-1,n-i-1)),l=Math.max(0,Math.min(e-1,n+i));n-i-1>=0&&(a-=t[r+h],o--),n+i<e&&(a+=t[r+l],o++),s[r+n]=a/o}}return s}static _verticalBoxBlur(t,e,r,i){const s=new Float32Array(t.length);for(let n=0;n<e;n++){let a=0,o=0;for(let s=-i;s<=i;s++){a+=t[Math.max(0,Math.min(r-1,s))*e+n],o++}s[n]=a/o;for(let h=1;h<r;h++){const l=Math.max(0,Math.min(r-1,h-i-1)),c=Math.max(0,Math.min(r-1,h+i));h-i-1>=0&&(a-=t[l*e+n],o--),h+i<r&&(a+=t[c*e+n],o++),s[h*e+n]=a/o}}return s}static _boxBlurWithSAT(t,e,r,i){const s=Math.floor(i/2),n=b._buildSAT(t,e,r),a=new Float32Array(t.length);for(let t=0;t<r;t++)for(let i=0;i<e;i++){const o=Math.max(0,i-s),h=Math.max(0,t-s),l=Math.min(e-1,i+s),c=Math.min(r-1,t+s),u=b._getSATSum(n,e,o,h,l,c),f=(l-o+1)*(c-h+1);a[t*e+i]=u/f}return a}static _buildSAT(t,e,r){const i=new Float32Array(e*r);i[0]=t[0];for(let r=1;r<e;r++)i[r]=t[r]+i[r-1];for(let s=1;s<r;s++){const r=s*e,n=(s-1)*e;i[r]=t[r]+i[n];for(let s=1;s<e;s++)i[r+s]=t[r+s]+i[r+s-1]+i[n+s]-i[n+s-1]}return i}static _getSATSum(t,e,r,i,s,n){if(r>s||i>n)return 0;return t[n*e+s]-(i>0?t[(i-1)*e+s]:0)-(r>0?t[n*e+(r-1)]:0)+(r>0&&i>0?t[(i-1)*e+(r-1)]:0)}static calculateBoxWidth(t,e){const r=Math.floor(Math.sqrt(12*t*t/e+1));return r%2==0?r+1:r}}class w{static validateAndConvert(t){w._validateImageLike(t);const e=t.width*t.height*3,r=t.width*t.height*4;if(t.data.length===e)return w._convertRGBToRGBA(t);if(t.data.length===r)return{width:t.width,height:t.height,data:t.data};throw new Error(`ImageLike data length (${t.data.length}) must match width*height*3 (${e}) for RGB or width*height*4 (${r}) for RGBA`)}static _validateImageLike(t){if(!t||"object"!=typeof t)throw new Error("ImageLike must be an object");if("number"!=typeof t.width||t.width<=0||!Number.isInteger(t.width))throw new Error("ImageLike width must be a positive integer");if("number"!=typeof t.height||t.height<=0||!Number.isInteger(t.height))throw new Error("ImageLike height must be a positive integer");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageLike data must be a Uint8ClampedArray");const e=16384;if(t.width>e||t.height>e)throw new Error("ImageLike dimensions must be ≤ 16384x16384")}static _convertRGBToRGBA(t){const e=t.width*t.height*4,r=new Uint8ClampedArray(e);for(let e=0;e<t.width*t.height;e++){const i=3*e,s=4*e;r[s]=t.data[i],r[s+1]=t.data[i+1],r[s+2]=t.data[i+2],r[s+3]=255}return{width:t.width,height:t.height,data:r}}static surfaceToImageLike(t){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");return{width:t.width,height:t.height,data:new Uint8ClampedArray(t.data)}}static createBlankImage(e,r,i=[0,0,0,255]){if(!Number.isInteger(e)||!Number.isInteger(r)||e<=0||r<=0)throw new Error("Width and height must be positive integers");const s=e*r,n=new Uint8ClampedArray(4*s);let a,o,h,l;if(i instanceof t){const t=i.toRGBA();a=t[0],o=t[1],h=t[2],l=t[3]}else{if(!(Array.isArray(i)&&i.length>=4))throw new Error("fillColor must be a Color instance or RGBA array");a=i[0],o=i[1],h=i[2],l=i[3]}for(let t=0;t<s;t++){const e=4*t;n[e]=a,n[e+1]=o,n[e+2]=h,n[e+3]=l}return{width:e,height:r,data:n}}static extractRegion(t,e,r,i,s){const n=w.validateAndConvert(t);if(e<0||r<0||e+i>n.width||r+s>n.height)throw new Error("Extraction region exceeds source image bounds");if(i<=0||s<=0)throw new Error("Extraction region dimensions must be positive");const a=new Uint8ClampedArray(i*s*4);for(let t=0;t<s;t++){const s=4*((r+t)*n.width+e),o=t*i*4,h=4*i;a.set(n.data.subarray(s,s+h),o)}return{width:i,height:s,data:a}}static scaleImage(t,e,r){const i=w.validateAndConvert(t);if(!Number.isInteger(e)||!Number.isInteger(r)||e<=0||r<=0)throw new Error("Target dimensions must be positive integers");const s=new Uint8ClampedArray(e*r*4),n=i.width/e,a=i.height/r;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const o=Math.floor(r*n),h=Math.floor(t*a),l=Math.min(o,i.width-1),c=4*(Math.min(h,i.height-1)*i.width+l),u=4*(t*e+r);s[u]=i.data[c],s[u+1]=i.data[c+1],s[u+2]=i.data[c+2],s[u+3]=i.data[c+3]}return{width:e,height:r,data:s}}static isImageLike(t){try{w._validateImageLike(t);const e=t.width*t.height*3,r=t.width*t.height*4;return t.data.length===e||t.data.length===r}catch(t){return!1}}static getImageInfo(t){const e=w.validateAndConvert(t),r=t.data.length===t.width*t.height*3;return{width:e.width,height:e.height,pixelCount:e.width*e.height,format:r?"RGB":"RGBA",dataSize:e.data.length,bytesPerPixel:r?3:4,memoryUsage:e.data.byteLength}}static fromCanvas(t){if(!t||"object"!=typeof t)throw new Error("Canvas must be a valid HTMLCanvasElement");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("Canvas must have numeric width and height");if(!t.getContext||"function"!=typeof t.getContext)throw new Error("Canvas must have getContext method");try{const e=t.getContext("2d").getImageData(0,0,t.width,t.height);return{width:t.width,height:t.height,data:new Uint8ClampedArray(e.data)}}catch(t){throw new Error(`Failed to extract canvas data: ${t.message}`)}}}class y{constructor(){this._cache=new Map,this._namedColors={black:{r:0,g:0,b:0},silver:{r:192,g:192,b:192},gray:{r:128,g:128,b:128},white:{r:255,g:255,b:255},maroon:{r:128,g:0,b:0},red:{r:255,g:0,b:0},purple:{r:128,g:0,b:128},fuchsia:{r:255,g:0,b:255},green:{r:0,g:128,b:0},lime:{r:0,g:255,b:0},olive:{r:128,g:128,b:0},yellow:{r:255,g:255,b:0},navy:{r:0,g:0,b:128},blue:{r:0,g:0,b:255},teal:{r:0,g:128,b:128},aqua:{r:0,g:255,b:255},aliceblue:{r:240,g:248,b:255},antiquewhite:{r:250,g:235,b:215},aquamarine:{r:127,g:255,b:212},azure:{r:240,g:255,b:255},beige:{r:245,g:245,b:220},bisque:{r:255,g:228,b:196},blanchedalmond:{r:255,g:235,b:205},blueviolet:{r:138,g:43,b:226},brown:{r:165,g:42,b:42},burlywood:{r:222,g:184,b:135},cadetblue:{r:95,g:158,b:160},chartreuse:{r:127,g:255,b:0},chocolate:{r:210,g:105,b:30},coral:{r:255,g:127,b:80},cornflowerblue:{r:100,g:149,b:237},cornsilk:{r:255,g:248,b:220},crimson:{r:220,g:20,b:60},cyan:{r:0,g:255,b:255},darkblue:{r:0,g:0,b:139},darkcyan:{r:0,g:139,b:139},darkgoldenrod:{r:184,g:134,b:11},darkgray:{r:169,g:169,b:169},darkgreen:{r:0,g:100,b:0},darkgrey:{r:169,g:169,b:169},darkkhaki:{r:189,g:183,b:107},darkmagenta:{r:139,g:0,b:139},darkolivegreen:{r:85,g:107,b:47},darkorange:{r:255,g:140,b:0},darkorchid:{r:153,g:50,b:204},darkred:{r:139,g:0,b:0},darksalmon:{r:233,g:150,b:122},darkseagreen:{r:143,g:188,b:143},darkslateblue:{r:72,g:61,b:139},darkslategray:{r:47,g:79,b:79},darkslategrey:{r:47,g:79,b:79},darkturquoise:{r:0,g:206,b:209},darkviolet:{r:148,g:0,b:211},deeppink:{r:255,g:20,b:147},deepskyblue:{r:0,g:191,b:255},dimgray:{r:105,g:105,b:105},dimgrey:{r:105,g:105,b:105},dodgerblue:{r:30,g:144,b:255},firebrick:{r:178,g:34,b:34},floralwhite:{r:255,g:250,b:240},forestgreen:{r:34,g:139,b:34},gainsboro:{r:220,g:220,b:220},ghostwhite:{r:248,g:248,b:255},gold:{r:255,g:215,b:0},goldenrod:{r:218,g:165,b:32},grey:{r:128,g:128,b:128},greenyellow:{r:173,g:255,b:47},honeydew:{r:240,g:255,b:240},hotpink:{r:255,g:105,b:180},indianred:{r:205,g:92,b:92},indigo:{r:75,g:0,b:130},ivory:{r:255,g:255,b:240},khaki:{r:240,g:230,b:140},lavender:{r:230,g:230,b:250},lavenderblush:{r:255,g:240,b:245},lawngreen:{r:124,g:252,b:0},lemonchiffon:{r:255,g:250,b:205},lightblue:{r:173,g:216,b:230},lightcoral:{r:240,g:128,b:128},lightcyan:{r:224,g:255,b:255},lightgoldenrodyellow:{r:250,g:250,b:210},lightgray:{r:211,g:211,b:211},lightgreen:{r:144,g:238,b:144},lightgrey:{r:211,g:211,b:211},lightpink:{r:255,g:182,b:193},lightsalmon:{r:255,g:160,b:122},lightseagreen:{r:32,g:178,b:170},lightskyblue:{r:135,g:206,b:250},lightslategray:{r:119,g:136,b:153},lightslategrey:{r:119,g:136,b:153},lightsteelblue:{r:176,g:196,b:222},lightyellow:{r:255,g:255,b:224},limegreen:{r:50,g:205,b:50},linen:{r:250,g:240,b:230},magenta:{r:255,g:0,b:255},mediumaquamarine:{r:102,g:205,b:170},mediumblue:{r:0,g:0,b:205},mediumorchid:{r:186,g:85,b:211},mediumpurple:{r:147,g:112,b:219},mediumseagreen:{r:60,g:179,b:113},mediumslateblue:{r:123,g:104,b:238},mediumspringgreen:{r:0,g:250,b:154},mediumturquoise:{r:72,g:209,b:204},mediumvioletred:{r:199,g:21,b:133},midnightblue:{r:25,g:25,b:112},mintcream:{r:245,g:255,b:250},mistyrose:{r:255,g:228,b:225},moccasin:{r:255,g:228,b:181},navajowhite:{r:255,g:222,b:173},oldlace:{r:253,g:245,b:230},olivedrab:{r:107,g:142,b:35},orange:{r:255,g:165,b:0},orangered:{r:255,g:69,b:0},orchid:{r:218,g:112,b:214},palegoldenrod:{r:238,g:232,b:170},palegreen:{r:152,g:251,b:152},paleturquoise:{r:175,g:238,b:238},palevioletred:{r:219,g:112,b:147},papayawhip:{r:255,g:239,b:213},peachpuff:{r:255,g:218,b:185},peru:{r:205,g:133,b:63},pink:{r:255,g:192,b:203},plum:{r:221,g:160,b:221},powderblue:{r:176,g:224,b:230},rebeccapurple:{r:102,g:51,b:153},rosybrown:{r:188,g:143,b:143},royalblue:{r:65,g:105,b:225},saddlebrown:{r:139,g:69,b:19},salmon:{r:250,g:128,b:114},sandybrown:{r:244,g:164,b:96},seagreen:{r:46,g:139,b:87},seashell:{r:255,g:245,b:238},sienna:{r:160,g:82,b:45},skyblue:{r:135,g:206,b:235},slateblue:{r:106,g:90,b:205},slategray:{r:112,g:128,b:144},slategrey:{r:112,g:128,b:144},snow:{r:255,g:250,b:250},springgreen:{r:0,g:255,b:127},steelblue:{r:70,g:130,b:180},tan:{r:210,g:180,b:140},thistle:{r:216,g:191,b:216},tomato:{r:255,g:99,b:71},turquoise:{r:64,g:224,b:208},violet:{r:238,g:130,b:238},wheat:{r:245,g:222,b:179},whitesmoke:{r:245,g:245,b:245},yellowgreen:{r:154,g:205,b:50}}}parse(t){if(this._cache.has(t))return this._cache.get(t);let e;if("string"!=typeof t)e={r:0,g:0,b:0,a:255};else{const r=t.trim().toLowerCase();if(r.startsWith("#"))e=this._parseHex(r);else if(r.startsWith("rgb"))e=this._parseRGB(r);else if(this._namedColors[r]){const t=this._namedColors[r];e={r:t.r,g:t.g,b:t.b,a:255}}else e={r:0,g:0,b:0,a:255}}return this._cache.set(t,e),e}_parseHex(t){if(3===(t=t.substring(1)).length&&(t=t.split("").map(t=>t+t).join("")),6===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:255}}if(8===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:parseInt(t.substring(6,8),16)}}return{r:0,g:0,b:0,a:255}}_parseRGB(t){const e=t.match(/rgba?\s*\(\s*([^)]+)\s*\)/);if(!e)return{r:0,g:0,b:0,a:255};const r=e[1].split(",").map(t=>t.trim());if(r.length<3)return{r:0,g:0,b:0,a:255};const i=Math.max(0,Math.min(255,parseInt(r[0])||0)),s=Math.max(0,Math.min(255,parseInt(r[1])||0)),n=Math.max(0,Math.min(255,parseInt(r[2])||0));let a=255;if(r.length>=4){const t=parseFloat(r[3]);isNaN(t)||(a=Math.max(0,Math.min(255,Math.round(255*t))))}return{r:i,g:s,b:n,a:a}}clearCache(){this._cache.clear()}}class x{constructor(){this._colorStops=[],this._sorted=!1}addColorStop(e,r){if("number"!=typeof e||!isFinite(e))throw new Error("Color stop offset must be a finite number");if(e<0||e>1)throw new Error("Color stop offset must be between 0 and 1");const i=(new y).parse(r),s=new t(i.r,i.g,i.b,i.a);this._colorStops.push({offset:e,color:s}),this._sorted=!1}_getSortedColorStops(){return this._sorted||(this._colorStops.sort((t,e)=>t.offset-e.offset),this._sorted=!0),this._colorStops}_getColorAt(e){const r=this._getSortedColorStops();if(0===r.length)return new t(0,0,0,0);if(1===r.length)return r[0].color;if(e<=r[0].offset)return r[0].color;if(e>=r[r.length-1].offset)return r[r.length-1].color;for(let i=0;i<r.length-1;i++){const s=r[i],n=r[i+1];if(e>=s.offset&&e<=n.offset){const r=n.offset-s.offset;if(0===r)return s.color;const i=(e-s.offset)/r,a=s.color.r,o=s.color.g,h=s.color.b,l=s.color.a,c=n.color.r,u=n.color.g,f=n.color.b,d=n.color.a,g=Math.round(a+(c-a)*i),m=Math.round(o+(u-o)*i),_=Math.round(h+(f-h)*i),p=Math.round(l+(d-l)*i);return new t(g,m,_,p)}}return r[0].color}getColorForPixel(t,e,r){throw new Error("getColorForPixel must be implemented by subclass")}}class M extends x{constructor(t,e,r,i){super(),this._x0=t,this._y0=e,this._x1=r,this._y1=i,this._dx=r-t,this._dy=i-e,this._lengthSquared=this._dx*this._dx+this._dy*this._dy}getColorForPixel(t,r,i){const s=i.transformPoint(new e(this._x0,this._y0)),n=i.transformPoint(new e(this._x1,this._y1)),a=n.x-s.x,o=n.y-s.y,h=a*a+o*o;if(0===h)return this._getColorAt(0);const l=((t-s.x)*a+(r-s.y)*o)/h;return this._getColorAt(l)}}class P extends x{constructor(t,e,r,i,s,n){if(super(),r<0||n<0)throw new Error("Radial gradient radii must be non-negative");if(t===i&&e===s&&r===n)throw new Error("Radial gradient circles must not be identical");this._x0=t,this._y0=e,this._r0=r,this._x1=i,this._y1=s,this._r1=n}getColorForPixel(t,r,i){const s=i.transformPoint(new e(this._x0,this._y0)),n=i.transformPoint(new e(this._x1,this._y1)),a=Math.sqrt((t-s.x)**2+(r-s.y)**2),o=Math.sqrt((t-n.x)**2+(r-n.y)**2),h=Math.sqrt((n.x-s.x)**2+(n.y-s.y)**2)+this._r1;let l;return l=a<=this._r0?0:o>=this._r1?1:(a-this._r0)/(h-this._r0),this._getColorAt(Math.max(0,Math.min(1,l)))}}class S extends x{constructor(t,e,r){super(),this._angle=t,this._x=e,this._y=r}getColorForPixel(t,r,i){const s=i.transformPoint(new e(this._x,this._y));let n=Math.atan2(r-s.y,t-s.x)-this._angle;for(;n<0;)n+=2*Math.PI;for(;n>=2*Math.PI;)n-=2*Math.PI;const a=n/(2*Math.PI);return this._getColorAt(a)}}class O{constructor(t,e="repeat"){this._imageData=w.validateAndConvert(t);const r=["repeat","repeat-x","repeat-y","no-repeat"];if(!r.includes(e))throw new Error(`Invalid repetition mode: ${e}. Must be one of: ${r.join(", ")}`);this._repetition=e,this._patternTransform=new i,Object.freeze(this)}setTransform(t){if(t instanceof i){const e=Object.create(Object.getPrototypeOf(this));return e._imageData=this._imageData,e._repetition=this._repetition,e._patternTransform=t,Object.freeze(e),e}if(t&&"number"==typeof t.a){const e=new i([t.a,t.b,t.c,t.d,t.e,t.f]);return this.setTransform(e)}throw new Error("Pattern transform must be a Transform2D or DOMMatrix-like object")}getColorForPixel(r,i,s){try{const t=s.multiply(this._patternTransform),n=t.invert().transformPoint(new e(r,i));return this._samplePattern(n.x,n.y)}catch(e){return new t(0,0,0,0)}}_samplePattern(e,r){const i=this._imageData.width,s=this._imageData.height;let n,a;switch(this._repetition){case"repeat":n=this._repeatCoordinate(e,i),a=this._repeatCoordinate(r,s);break;case"repeat-x":if(n=this._repeatCoordinate(e,i),a=r,r<0||r>=s)return new t(0,0,0,0);break;case"repeat-y":if(n=e,a=this._repeatCoordinate(r,s),e<0||e>=i)return new t(0,0,0,0);break;case"no-repeat":if(n=e,a=r,e<0||e>=i||r<0||r>=s)return new t(0,0,0,0)}const o=Math.floor(n),h=Math.floor(a),l=Math.max(0,Math.min(i-1,o)),c=4*(Math.max(0,Math.min(s-1,h))*i+l),u=this._imageData.data[c],f=this._imageData.data[c+1],d=this._imageData.data[c+2],g=this._imageData.data[c+3];return new t(u,f,d,g)}_repeatCoordinate(t,e){if(0===e)return 0;let r=t%e;return r<0&&(r+=e),r}getDimensions(){return{width:this._imageData.width,height:this._imageData.height}}getRepetition(){return this._repetition}getTransform(){return this._patternTransform}static fromSurface(t,e="repeat"){const r=w.surfaceToImageLike(t);return new O(r,e)}static createSolid(t,e,r,i="repeat"){const s=w.createBlankImage(t,e,r);return new O(s,i)}}class C{constructor(t){if(!t||"object"!=typeof t)throw new Error("Rasterizer requires a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");this._surface=t,this._currentOp=null}get surface(){return this._surface}get currentOp(){return this._currentOp}beginOp(e={}){this._validateParams(e),this._currentOp={composite:e.composite||"source-over",globalAlpha:void 0!==e.globalAlpha?e.globalAlpha:1,transform:e.transform||new i,clipMask:e.clipMask||null,fillStyle:e.fillStyle||null,strokeStyle:e.strokeStyle||null,sourceMask:null,shadowColor:e.shadowColor||new t(0,0,0,0),shadowBlur:e.shadowBlur||0,shadowOffsetX:e.shadowOffsetX||0,shadowOffsetY:e.shadowOffsetY||0},this._requiresCanvasWideCompositing(this._currentOp.composite)&&(this._currentOp.sourceMask=new _(this._surface.width,this._surface.height))}endOp(){this._currentOp=null}_validateParams(t){if(void 0!==t.globalAlpha&&("number"!=typeof t.globalAlpha||t.globalAlpha<0||t.globalAlpha>1))throw new Error("globalAlpha must be a number between 0 and 1");if(t.composite&&!a.isSupported(t.composite))throw new Error(`Invalid composite operation. Supported: ${a.getSupportedOperations().join(", ")}`);if(t.transform&&!(t.transform instanceof i))throw new Error("transform must be a Transform2D instance")}_requireActiveOp(){if(!this._currentOp)throw new Error("Must call beginOp() before drawing operations")}_requiresCanvasWideCompositing(t){return["destination-atop","destination-in","source-in","source-out","copy"].includes(t)}_isPixelClipped(t,e){return!!this._currentOp?.clipMask&&this._currentOp.clipMask.isPixelClipped(t,e)}_needsShadow(){if(!this._currentOp)return!1;const t=this._currentOp;return t.shadowColor.a>0&&(t.shadowBlur>0||0!==t.shadowOffsetX||0!==t.shadowOffsetY)}_renderWithShadow(t){if(!this._needsShadow())return void t();const e=this._currentOp,r=Math.ceil(e.shadowBlur),i=new p(this._surface.width,this._surface.height,r);this._renderToShadowBuffer(i,t);let s=i;e.shadowBlur>0&&(s=this._applyShadowBlur(i,e.shadowBlur)),this._compositeShadowToSurface(s,e.shadowColor,e.shadowOffsetX,e.shadowOffsetY),t()}_renderToShadowBuffer(e,r){const i=new n(this._surface.width,this._surface.height),s=new C(i),a=Object.assign({},this._currentOp);a.shadowColor=new t(0,0,0,0),a.shadowBlur=0,a.shadowOffsetX=0,a.shadowOffsetY=0,s._currentOp=a;const o=this._surface,h=this._currentOp;this._surface=i,this._currentOp=a;try{r()}finally{this._surface=o,this._currentOp=h}for(let t=0;t<i.height;t++)for(let r=0;r<i.width;r++){const s=t*i.stride+4*r,n=i.data[s+3]/255;n>0&&e.addAlpha(r,t,n)}}_applyShadowBlur(t,e){const r=t.toDenseArray();if(0===r.width||0===r.height)return t;const i=b.blur(r.data,r.width,r.height,e),s=new p(t.originalWidth,t.originalHeight,Math.ceil(e));return s.fromDenseArray(i,r.width,r.height,r.offsetX,r.offsetY),s}_compositeShadowToSurface(t,e,r,i){const s=this._surface,n=this._currentOp.globalAlpha,o=e.withGlobalAlpha(n);for(const e of t.getPixels()){const n=Math.round(e.x-t.extendedOffsetX+r),h=Math.round(e.y-t.extendedOffsetY+i);if(n<0||n>=s.width||h<0||h>=s.height)continue;if(this._isPixelClipped(n,h))continue;const l=Math.min(255,Math.round(e.alpha*o.a*8));if(l<=0)continue;const c=h*s.stride+4*n,u=s.data[c],f=s.data[c+1],d=s.data[c+2],g=s.data[c+3],m=a.blendPixel("source-over",o.r,o.g,o.b,l,u,f,d,g);s.data[c]=m.r,s.data[c+1]=m.g,s.data[c+2]=m.b,s.data[c+3]=m.a}}fillRect(t,e,r,i,s){if(this._requireActiveOp(),"number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("Rectangle coordinates must be numbers");if(r<0||i<0)throw new Error("Rectangle dimensions must be non-negative");0!==r&&0!==i&&this._renderWithShadow(()=>{this._fillRectInternal(t,e,r,i,s)})}_fillRectInternal(e,r,i,n,a){if(this._currentOp.clipMask||this._requiresCanvasWideCompositing(this._currentOp.composite)){const o=new s;o.rect(e,r,i,n);const h=this._currentOp.fillStyle;return a&&Array.isArray(a)&&(this._currentOp.fillStyle=new t(a[0],a[1],a[2],a[3])),this._fillInternal(o,"nonzero"),void(a&&Array.isArray(a)&&(this._currentOp.fillStyle=h))}const o=this._currentOp.transform,h=o.transformPoint({x:e,y:r}),l=o.transformPoint({x:e+i,y:r}),c=o.transformPoint({x:e,y:r+n}),u=o.transformPoint({x:e+i,y:r+n}),d=Math.max(0,Math.floor(Math.min(h.x,l.x,c.x,u.x))),g=Math.min(this._surface.width-1,Math.floor(Math.max(h.x,l.x,c.x,u.x)-1)),m=Math.max(0,Math.floor(Math.min(h.y,l.y,c.y,u.y))),_=Math.min(this._surface.height-1,Math.floor(Math.max(h.y,l.y,c.y,u.y)-1));if(0===this._currentOp.transform.b&&0===this._currentOp.transform.c&&(a instanceof t||Array.isArray(a)))this._fillAxisAlignedRect(d,m,g-d+1,_-m+1,a);else{const s=[{x:e,y:r},{x:e+i,y:r},{x:e+i,y:r+n},{x:e,y:r+n}],o=Array.isArray(a)?new t(a[0],a[1],a[2],a[3]):a;f.fillPolygons(this._surface,[s],o,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite)}}_fillAxisAlignedRect(e,r,i,s,n){const o=this._surface,h=this._currentOp.globalAlpha,l=(Array.isArray(n)?new t(n[0],n[1],n[2],n[3]):n).withGlobalAlpha(h),c=l.r,u=l.g,f=l.b,d=l.a;for(let t=r;t<r+s;t++)if(!(t<0||t>=o.height))for(let r=e;r<e+i;r++){if(r<0||r>=o.width)continue;if(this._currentOp.clipMask&&this._isPixelClipped(r,t))continue;const e=t*o.stride+4*r,i=o.data[e],s=o.data[e+1],n=o.data[e+2],h=o.data[e+3],l=a.blendPixel(this._currentOp.composite,c,u,f,d,i,s,n,h);o.data[e]=l.r,o.data[e+1]=l.g,o.data[e+2]=l.b,o.data[e+3]=l.a}}_performCanvasWideCompositing(e,r=1,i=1){if(!this._currentOp||!this._currentOp.sourceMask)throw new Error("Canvas-wide compositing requires active operation with source mask");const s=this._surface,n=this._currentOp.sourceMask,o=this._currentOp.composite,h=this._currentOp.transform,l=this._currentOp.clipMask,c=n.getIterationBounds(l,!0);if(!c.isEmpty)for(let u=c.minY;u<=c.maxY;u++)for(let d=c.minX;d<=c.maxX;d++){if(l&&l.isPixelClipped(d,u))continue;let c;c=(n.getPixel(d,u)?1:0)>0?f._evaluatePaintSource(e,d,u,h,r,i):new t(0,0,0,0);const g=u*s.stride+4*d,m=s.data[g],_=s.data[g+1],p=s.data[g+2],b=s.data[g+3],w=a.blendPixel(o,c.r,c.g,c.b,c.a,m,_,p,b);s.data[g]=w.r,s.data[g+1]=w.g,s.data[g+2]=w.b,s.data[g+3]=w.a}}fill(t,e){this._requireActiveOp(),this._renderWithShadow(()=>{this._fillInternal(t,e)})}_fillInternal(e,r){const i=this._currentOp.fillStyle||new t(0,0,0,255),s=r||"nonzero",n=u.flattenPath(e);this._requiresCanvasWideCompositing(this._currentOp.composite)?(f.fillPolygons(this._surface,n,i,s,this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite,this._currentOp.sourceMask),this._performCanvasWideCompositing(i,this._currentOp.globalAlpha,1)):f.fillPolygons(this._surface,n,i,s,this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite)}stroke(t,e){this._requireActiveOp(),this._renderWithShadow(()=>{this._strokeInternal(t,e)})}_strokeInternal(e,r){const i=this._currentOp.strokeStyle||new t(0,0,0,255);let s=r,n=1;r.lineWidth<=1&&(n=0===r.lineWidth?1:r.lineWidth,s={...r,lineWidth:1});const a=d.generateStrokePolygons(e,s);this._requiresCanvasWideCompositing(this._currentOp.composite)?(f.fillPolygons(this._surface,a,i,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,n,this._currentOp.composite,this._currentOp.sourceMask),this._performCanvasWideCompositing(i,this._currentOp.globalAlpha,n)):f.fillPolygons(this._surface,a,i,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,n,this._currentOp.composite)}drawImage(t,e,r,i,s,n,a,o,h){this._requireActiveOp(),this._renderWithShadow(()=>{this._drawImageInternal.apply(this,arguments)})}_drawImageInternal(t,e,r,i,s,n,o,h,l){const c=w.validateAndConvert(t);let u,f,d,g,m,_,p,b;if(3===arguments.length)u=0,f=0,d=c.width,g=c.height,m=e,_=r,p=d,b=g;else if(5===arguments.length)u=0,f=0,d=c.width,g=c.height,m=e,_=r,p=i,b=s;else{if(9!==arguments.length)throw new Error("Invalid number of arguments for drawImage");u=e,f=r,d=i,g=s,m=n,_=o,p=h,b=l}if(u<0||f<0||u+d>c.width||f+g>c.height)throw new Error("Source rectangle is outside image bounds");const y=this._currentOp.transform,x=y.transformPoint({x:m,y:_}),M=y.transformPoint({x:m+p,y:_}),P=y.transformPoint({x:m,y:_+b}),S=y.transformPoint({x:m+p,y:_+b}),O=Math.max(0,Math.floor(Math.min(x.x,M.x,P.x,S.x))),C=Math.min(this._surface.width-1,Math.ceil(Math.max(x.x,M.x,P.x,S.x))),E=Math.max(0,Math.floor(Math.min(x.y,M.y,P.y,S.y))),v=Math.min(this._surface.height-1,Math.ceil(Math.max(x.y,M.y,P.y,S.y))),A=y.invert(),k=this._currentOp.globalAlpha;for(let t=E;t<=v;t++)for(let e=O;e<=C;e++){if(this._currentOp.clipMask&&this._isPixelClipped(e,t))continue;const r=A.transformPoint({x:e,y:t});if(r.x<m||r.x>=m+p||r.y<_||r.y>=_+b)continue;const i=u+(r.x-m)/p*d,s=f+(r.y-_)/b*g,n=Math.floor(i),o=Math.floor(s);if(n<0||o<0||n>=c.width||o>=c.height)continue;const h=4*(o*c.width+n),l=c.data[h],w=c.data[h+1],y=c.data[h+2],x=c.data[h+3]/255*k,M=Math.round(255*x);if(0===M)continue;const P=t*this._surface.stride+4*e,S=this._surface.data[P],O=this._surface.data[P+1],C=this._surface.data[P+2],E=this._surface.data[P+3],v=a.blendPixel(this._currentOp.composite,l,w,y,M,S,O,C,E);this._surface.data[P]=v.r,this._surface.data[P+1]=v.g,this._surface.data[P+2]=v.b,this._surface.data[P+3]=v.a}}}class E{constructor(e){this.surface=e,this.rasterizer=new C(e),this.stateStack=[],this.globalAlpha=1,this.globalCompositeOperation="source-over",this._transform=new i,this._fillStyle=new t(0,0,0,255),this._strokeStyle=new t(0,0,0,255),this.lineWidth=1,this.lineJoin="miter",this.lineCap="butt",this.miterLimit=10,this._lineDash=[],this._originalLineDash=[],this._lineDashOffset=0,this.shadowColor=new t(0,0,0,0),this.shadowBlur=0,this.shadowOffsetX=0,this.shadowOffsetY=0,this._currentPath=new s,this._clipMask=null}save(){let t=null;this._clipMask&&(t=this._clipMask.clone()),this.stateStack.push({globalAlpha:this.globalAlpha,globalCompositeOperation:this.globalCompositeOperation,transform:new i([this._transform.a,this._transform.b,this._transform.c,this._transform.d,this._transform.e,this._transform.f]),fillStyle:this._fillStyle,strokeStyle:this._strokeStyle,clipMask:t,lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash.slice(),originalLineDash:this._originalLineDash.slice(),lineDashOffset:this._lineDashOffset,shadowColor:this.shadowColor,shadowBlur:this.shadowBlur,shadowOffsetX:this.shadowOffsetX,shadowOffsetY:this.shadowOffsetY})}restore(){if(0===this.stateStack.length)return;const e=this.stateStack.pop();this.globalAlpha=e.globalAlpha,this.globalCompositeOperation=e.globalCompositeOperation,this._transform=e.transform,this._fillStyle=e.fillStyle,this._strokeStyle=e.strokeStyle,this._clipMask=e.clipMask,this.lineWidth=e.lineWidth,this.lineJoin=e.lineJoin,this.lineCap=e.lineCap,this.miterLimit=e.miterLimit,this._lineDash=e.lineDash||[],this._originalLineDash=e.originalLineDash||[],this._lineDashOffset=e.lineDashOffset||0,this.shadowColor=e.shadowColor||new t(0,0,0,0),this.shadowBlur=e.shadowBlur||0,this.shadowOffsetX=e.shadowOffsetX||0,this.shadowOffsetY=e.shadowOffsetY||0}transform(t,e,r,s,n,a){const o=new i([t,e,r,s,n,a]);this._transform=o.multiply(this._transform)}setTransform(t,e,r,s,n,a){this._transform=new i([t,e,r,s,n,a])}resetTransform(){this._transform=new i}translate(t,e){this._transform=(new i).translate(t,e).multiply(this._transform)}scale(t,e){this._transform=(new i).scale(t,e).multiply(this._transform)}rotate(t){this._transform=(new i).rotate(t).multiply(this._transform)}setFillStyle(e,r,i,s){1===arguments.length&&(e instanceof t||e instanceof x||e instanceof M||e instanceof P||e instanceof S||e instanceof O)?this._fillStyle=e:(s=void 0!==s?s:255,this._fillStyle=new t(e,r,i,s))}setStrokeStyle(e,r,i,s){1===arguments.length&&(e instanceof t||e instanceof x||e instanceof M||e instanceof P||e instanceof S||e instanceof O)?this._strokeStyle=e:(s=void 0!==s?s:255,this._strokeStyle=new t(e,r,i,s))}setShadowColor(e,r,i,s){1===arguments.length&&e instanceof t?this.shadowColor=e:(s=void 0!==s?s:255,this.shadowColor=new t(e,r,i,s))}setShadowBlur(t){if("number"!=typeof t||isNaN(t))throw new Error("Shadow blur must be a number");if(t<0)throw new Error("Shadow blur must be non-negative");this.shadowBlur=t}setShadowOffsetX(t){if("number"!=typeof t||isNaN(t))throw new Error("Shadow offsetX must be a number");this.shadowOffsetX=t}setShadowOffsetY(t){if("number"!=typeof t||isNaN(t))throw new Error("Shadow offsetY must be a number");this.shadowOffsetY=t}beginPath(){this._currentPath=new s}closePath(){this._currentPath.closePath()}moveTo(t,e){this._currentPath.moveTo(t,e)}lineTo(t,e){this._currentPath.lineTo(t,e)}rect(t,e,r,i){this._currentPath.rect(t,e,r,i)}arc(t,e,r,i,s,n){this._currentPath.arc(t,e,r,i,s,n)}ellipse(t,e,r,i,s,n,a,o){this._currentPath.ellipse(t,e,r,i,s,n,a,o)}arcTo(t,e,r,i,s){this._currentPath.arcTo(t,e,r,i,s)}quadraticCurveTo(t,e,r,i){this._currentPath.quadraticCurveTo(t,e,r,i)}bezierCurveTo(t,e,r,i,s,n){this._currentPath.bezierCurveTo(t,e,r,i,s,n)}fillRect(t,e,r,i){this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,fillStyle:this._fillStyle,shadowColor:this.shadowColor,shadowBlur:this.shadowBlur,shadowOffsetX:this.shadowOffsetX,shadowOffsetY:this.shadowOffsetY}),this.rasterizer.fillRect(t,e,r,i,this._fillStyle),this.rasterizer.endOp()}strokeRect(t,e,r,i){const n=new s;n.rect(t,e,r,i),n.closePath(),this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,strokeStyle:this._strokeStyle,shadowColor:this.shadowColor,shadowBlur:this.shadowBlur,shadowOffsetX:this.shadowOffsetX,shadowOffsetY:this.shadowOffsetY}),this.rasterizer.stroke(n,{lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit}),this.rasterizer.endOp()}clearRect(t,e,r,i){this._clearRectDirect(t,e,r,i)}_clearRectDirect(t,e,r,i){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("Rectangle coordinates must be numbers");if(r<0||i<0)return;if(0===r||0===i)return;const s=this.surface,n=this._transform,a=n.transformPoint({x:t,y:e}),o=n.transformPoint({x:t+r,y:e}),h=n.transformPoint({x:t,y:e+i}),l=n.transformPoint({x:t+r,y:e+i}),c=Math.floor(Math.min(a.x,o.x,h.x,l.x)),u=Math.ceil(Math.max(a.x,o.x,h.x,l.x)),f=Math.floor(Math.min(a.y,o.y,h.y,l.y)),d=Math.ceil(Math.max(a.y,o.y,h.y,l.y));if(0===n.b&&0===n.c){const a=n.e+t*n.a,o=n.f+e*n.d,h=a+r*n.a,l=o+i*n.d,c=Math.max(0,Math.floor(a)),u=Math.min(s.width-1,Math.floor(h)-1),f=Math.max(0,Math.floor(o)),d=Math.min(s.height-1,Math.floor(l)-1);for(let t=f;t<=d;t++)for(let e=c;e<=u;e++){if(this._clipMask&&this._clipMask.isPixelClipped(e,t))continue;const r=t*s.stride+4*e;s.data[r]=0,s.data[r+1]=0,s.data[r+2]=0,s.data[r+3]=0}}else{const a=n.invert();for(let n=Math.max(0,f);n<=Math.min(s.height-1,d);n++)for(let o=Math.max(0,c);o<=Math.min(s.width-1,u);o++){if(this._clipMask&&this._clipMask.isPixelClipped(o,n))continue;const h=a.transformPoint({x:o+.5,y:n+.5});if(h.x>=t&&h.x<t+r&&h.y>=e&&h.y<e+i){const t=n*s.stride+4*o;s.data[t]=0,s.data[t+1]=0,s.data[t+2]=0,s.data[t+3]=0}}}}fill(t,e){let r,i;0===arguments.length?(r=this._currentPath,i="nonzero"):1===arguments.length?"string"==typeof t?(r=this._currentPath,i=t):(r=t,i="nonzero"):(r=t,i=e),i=i||"nonzero",this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,fillStyle:this._fillStyle,shadowColor:this.shadowColor,shadowBlur:this.shadowBlur,shadowOffsetX:this.shadowOffsetX,shadowOffsetY:this.shadowOffsetY}),this.rasterizer.fill(r,i),this.rasterizer.endOp()}stroke(t){const e=t||this._currentPath;this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,strokeStyle:this._strokeStyle,shadowColor:this.shadowColor,shadowBlur:this.shadowBlur,shadowOffsetX:this.shadowOffsetX,shadowOffsetY:this.shadowOffsetY}),this.rasterizer.stroke(e,{lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash.slice(),lineDashOffset:this._lineDashOffset}),this.rasterizer.endOp()}isPointInPath(){let t,e,r,i;if(arguments.length<2){const t=new TypeError("Invalid number of arguments for isPointInPath");throw t.message="TypeError: "+t.message,t}if(2===arguments.length)[e,r]=arguments,t=this._currentPath,i="nonzero";else if(3===arguments.length)if("string"==typeof arguments[2])[e,r,i]=arguments,t=this._currentPath;else{if([t,e,r]=arguments,!t||"object"!=typeof t||!t.commands){const t=new TypeError("First argument must be a Path2D object");throw t.message="TypeError: "+t.message,t}i="nonzero"}else if(4===arguments.length){if([t,e,r,i]=arguments,!t||"object"!=typeof t||!t.commands){const t=new TypeError("First argument must be a Path2D object");throw t.message="TypeError: "+t.message,t}}else if(arguments.length>4){const t=new TypeError("Invalid number of arguments for isPointInPath");throw t.message="TypeError: "+t.message,t}if("number"!=typeof e||"number"!=typeof r)return!1;if(!t||!t.commands||0===t.commands.length)return!1;i=i||"nonzero";const s=u.flattenPath(t);if(0===s.length)return!1;const n=s.map(t=>t.map(t=>this._transform.transformPoint(t)));return f.isPointInPolygons(e,r,n,i)}isPointInStroke(){let t,e,r;if(arguments.length<2){const t=new TypeError("Invalid number of arguments for isPointInStroke");throw t.message="TypeError: "+t.message,t}if(2===arguments.length)[e,r]=arguments,t=this._currentPath;else if(3===arguments.length){if([t,e,r]=arguments,!t||"object"!=typeof t||!t.commands){const t=new TypeError("First argument must be a Path2D object");throw t.message="TypeError: "+t.message,t}}else if(arguments.length>3){const t=new TypeError("Invalid number of arguments for isPointInStroke");throw t.message="TypeError: "+t.message,t}if("number"!=typeof e||"number"!=typeof r)return!1;if(!t||!t.commands||0===t.commands.length)return!1;const i={lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash,lineDashOffset:this._lineDashOffset};if(0===i.lineWidth){const i=.5,s=u.flattenPath(t).map(t=>t.map(t=>this._transform.transformPoint(t)));for(const t of s)if(!(t.length<2))for(let s=0;s<t.length-1;s++){const n=t[s],a=t[s+1];if(this._distanceToLineSegment(e,r,n.x,n.y,a.x,a.y)<=i)return!0}return!1}const s=d.generateStrokePolygons(t,i);if(0===s.length)return!1;const n=s.map(t=>t.map(t=>this._transform.transformPoint(t)));return f.isPointInPolygons(e,r,n,"nonzero")}_distanceToLineSegment(t,e,r,i,s,n){const a=s-r,o=n-i;if(0===a&&0===o)return Math.sqrt((t-r)*(t-r)+(e-i)*(e-i));const h=Math.max(0,Math.min(1,((t-r)*a+(e-i)*o)/(a*a+o*o))),l=r+h*a,c=i+h*o;return Math.sqrt((t-l)*(t-l)+(e-c)*(e-c))}clip(t,e){const r=t||this._currentPath,i=e||"nonzero",s=new m(this.surface.width,this.surface.height);s.clipAll();s.createPixelWriter();const n=this._fillStyle;this._fillStyle=[255,255,255,255];const a=u.flattenPath(r);this._fillPolygonsToClipBuffer(a,i,s),this._fillStyle=n,this._clipMask?this._clipMask.intersectWith(s):this._clipMask=s}_fillPolygonsToClipBuffer(t,e,r){if(0===t.length)return;const i=this.surface,s=t.map(t=>t.map(t=>this._transform.transformPoint(t)));let n=1/0,a=-1/0;for(const t of s)for(const e of t)n=Math.min(n,e.y),a=Math.max(a,e.y);n=Math.max(0,Math.floor(n)),a=Math.min(i.height-1,Math.ceil(a));for(let t=n;t<=a;t++){const i=[];for(const e of s)this._findPolygonIntersections(e,t+.5,i);i.sort((t,e)=>t.x-e.x),this._fillClipSpans(t,i,e,r)}}_findPolygonIntersections(t,e,r){for(let i=0;i<t.length;i++){const s=t[i],n=t[(i+1)%t.length];if(Math.abs(s.y-n.y)<1e-10)continue;const a=Math.min(s.y,n.y),o=Math.max(s.y,n.y);if(e>=a&&e<o){const t=(e-s.y)/(n.y-s.y),i=s.x+t*(n.x-s.x),a=n.y>s.y?1:-1;r.push({x:i,winding:a})}}}_fillClipSpans(t,e,r,i){if(0===e.length)return;let s=0,n=!1;for(let a=0;a<e.length;a++){const o=e[a],h=e[a+1];s+=o.winding;if(n="evenodd"===r?s%2!=0:0!==s,n&&h){const e=Math.max(0,Math.ceil(o.x)),r=Math.min(this.surface.width-1,Math.floor(h.x));for(let s=e;s<=r;s++)i.setPixel(s,t,!0)}}}drawImage(t,e,r,s,n,a,o,h,l){if("undefined"!=typeof console&&console.log,!t||"object"!=typeof t)throw new Error("First argument must be an ImageLike object");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("ImageLike must have numeric width and height properties");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageLike data must be a Uint8ClampedArray");this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:new i([this._transform.a,this._transform.b,this._transform.c,this._transform.d,this._transform.e,this._transform.f]),clipMask:this._clipMask,shadowColor:this.shadowColor,shadowBlur:this.shadowBlur,shadowOffsetX:this.shadowOffsetX,shadowOffsetY:this.shadowOffsetY}),this.rasterizer.drawImage.apply(this.rasterizer,arguments),this.rasterizer.endOp()}setLineDash(t){if(!Array.isArray(t))throw new Error("setLineDash expects an array");for(let e=0;e<t.length;e++){if("number"!=typeof t[e]||isNaN(t[e]))throw new Error("Dash segments must be numbers");if(t[e]<0)throw new Error("Dash segments must be non-negative")}this._originalLineDash=t.slice(),this._lineDash=t.slice(),this._lineDash.length%2==1&&(this._lineDash=this._lineDash.concat(this._lineDash))}getLineDash(){return this._originalLineDash.slice()}set lineDashOffset(t){"number"!=typeof t||isNaN(t)||(this._lineDashOffset=t)}get lineDashOffset(){return this._lineDashOffset}createLinearGradient(t,e,r,i){return new M(t,e,r,i)}createRadialGradient(t,e,r,i,s,n){return new P(t,e,r,i,s,n)}createConicGradient(t,e,r){return new S(t,e,r)}createPattern(t,e){return new O(t,e)}}class v{constructor(t){this._core=new E(t),this._colorParser=new y,this._fillStyle="#000000",this._strokeStyle="#000000",this._shadowColor="rgba(0, 0, 0, 0)"}_updateSurface(t){this._core=new E(t),this._applyFillStyle(),this._applyStrokeStyle(),this._applyShadowProperties()}get fillStyle(){return this._fillStyle}set fillStyle(t){this._fillStyle=t,this._applyFillStyle()}get strokeStyle(){return this._strokeStyle}set strokeStyle(t){this._strokeStyle=t,this._applyStrokeStyle()}_applyFillStyle(){if(this._fillStyle instanceof x||this._fillStyle instanceof M||this._fillStyle instanceof P||this._fillStyle instanceof S||this._fillStyle instanceof O)this._core.setFillStyle(this._fillStyle);else{const t=this._colorParser.parse(this._fillStyle);this._core.setFillStyle(t.r,t.g,t.b,t.a)}}_applyStrokeStyle(){if(this._strokeStyle instanceof x||this._strokeStyle instanceof M||this._strokeStyle instanceof P||this._strokeStyle instanceof S||this._strokeStyle instanceof O)this._core.setStrokeStyle(this._strokeStyle);else{const t=this._colorParser.parse(this._strokeStyle);this._core.setStrokeStyle(t.r,t.g,t.b,t.a)}}_applyShadowProperties(){if(this._shadowColor){const t=this._colorParser.parse(this._shadowColor);this._core.setShadowColor(t.r,t.g,t.b,t.a)}}get globalAlpha(){return this._core.globalAlpha}set globalAlpha(t){this._core.globalAlpha=t}get globalCompositeOperation(){return this._core.globalCompositeOperation}set globalCompositeOperation(t){this._core.globalCompositeOperation=t}get lineWidth(){return this._core.lineWidth}set lineWidth(t){this._core.lineWidth=t}get lineJoin(){return this._core.lineJoin}set lineJoin(t){this._core.lineJoin=t}get lineCap(){return this._core.lineCap}set lineCap(t){this._core.lineCap=t}get miterLimit(){return this._core.miterLimit}set miterLimit(t){this._core.miterLimit=t}get lineDashOffset(){return this._core.lineDashOffset}set lineDashOffset(t){this._core.lineDashOffset=t}get shadowColor(){return this._shadowColor}set shadowColor(t){if("string"==typeof t){this._shadowColor=t;const e=this._colorParser.parse(t);this._core.setShadowColor(e.r,e.g,e.b,e.a)}}get shadowBlur(){return this._core.shadowBlur}set shadowBlur(t){"number"==typeof t&&!isNaN(t)&&t>=0&&this._core.setShadowBlur(t)}get shadowOffsetX(){return this._core.shadowOffsetX}set shadowOffsetX(t){"number"!=typeof t||isNaN(t)||this._core.setShadowOffsetX(t)}get shadowOffsetY(){return this._core.shadowOffsetY}set shadowOffsetY(t){"number"!=typeof t||isNaN(t)||this._core.setShadowOffsetY(t)}save(){this._core.save()}restore(){this._core.restore()}transform(t,e,r,i,s,n){this._core.transform(t,e,r,i,s,n)}setTransform(t,e,r,i,s,n){this._core.setTransform(t,e,r,i,s,n)}resetTransform(){this._core.resetTransform()}translate(t,e){this._core.translate(t,e)}scale(t,e){this._core.scale(t,e)}rotate(t){this._core.rotate(t)}beginPath(){this._core.beginPath()}closePath(){this._core.closePath()}moveTo(t,e){this._core.moveTo(t,e)}lineTo(t,e){this._core.lineTo(t,e)}rect(t,e,r,i){this._core.rect(t,e,r,i)}arc(t,e,r,i,s,n=!1){this._core.arc(t,e,r,i,s,n)}ellipse(t,e,r,i,s,n,a,o=!1){this._core.ellipse(t,e,r,i,s,n,a,o)}arcTo(t,e,r,i,s){this._core.arcTo(t,e,r,i,s)}quadraticCurveTo(t,e,r,i){this._core.quadraticCurveTo(t,e,r,i)}bezierCurveTo(t,e,r,i,s,n){this._core.bezierCurveTo(t,e,r,i,s,n)}fillRect(t,e,r,i){this._core.fillRect(t,e,r,i)}strokeRect(t,e,r,i){this._core.strokeRect(t,e,r,i)}clearRect(t,e,r,i){this._core.clearRect(t,e,r,i)}fill(t,e){"string"==typeof t?this._core.fill(t):t&&t instanceof s?this._core.fill(t,e):this._core.fill()}stroke(t){t&&t instanceof s?this._core.stroke(t):this._core.stroke()}isPointInPath(){return this._core.isPointInPath.apply(this._core,arguments)}isPointInStroke(){return this._core.isPointInStroke.apply(this._core,arguments)}setLineDash(t){this._core.setLineDash(t)}getLineDash(){return this._core.getLineDash()}clip(t,e){"string"==typeof t?this._core.clip(t):t&&t instanceof s?this._core.clip(t,e):this._core.clip()}drawImage(t,...e){if("undefined"!=typeof console&&console.log,t&&t instanceof A)this._core.drawImage(t._imageData,...e);else if(t&&"object"==typeof t&&t.getContext&&"function"==typeof t.getContext){const r=t.getContext("2d").getImageData(0,0,t.width,t.height);this._core.drawImage(r,...e)}else t&&"object"==typeof t&&t.width&&t.height&&t.data,this._core.drawImage(t,...e)}createImageData(t,e){if("number"!=typeof t||t<=0||!Number.isInteger(t))throw new Error("Width must be a positive integer");if("number"!=typeof e||e<=0||!Number.isInteger(e))throw new Error("Height must be a positive integer");return{width:t,height:e,data:new Uint8ClampedArray(t*e*4)}}getImageData(t,e,r,i){if("number"!=typeof t||"number"!=typeof e)throw new Error("Coordinates must be numbers");if("number"!=typeof r||r<=0||!Number.isInteger(r))throw new Error("Width must be a positive integer");if("number"!=typeof i||i<=0||!Number.isInteger(i))throw new Error("Height must be a positive integer");const s=this.createImageData(r,i),n=this._core.surface;for(let a=0;a<i;a++){const i=Math.floor(e)+a,o=a;if(i>=0&&i<n.height)for(let e=0;e<r;e++){const a=Math.floor(t)+e,h=e;if(a>=0&&a<n.width){const t=i*n.stride+4*a,e=o*r*4+4*h;s.data[e]=n.data[t],s.data[e+1]=n.data[t+1],s.data[e+2]=n.data[t+2],s.data[e+3]=n.data[t+3]}}}return s}putImageData(t,e,r){if(!t||"object"!=typeof t)throw new Error("ImageData must be an object");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("ImageData must have numeric width and height");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageData data must be a Uint8ClampedArray");if("number"!=typeof e||"number"!=typeof r)throw new Error("Destination coordinates must be numbers");const i=this._core.surface;for(let s=0;s<t.height;s++){const n=Math.floor(r)+s,a=s;if(n>=0&&n<i.height)for(let r=0;r<t.width;r++){const s=Math.floor(e)+r,o=r;if(s>=0&&s<i.width){const e=n*i.stride+4*s,r=a*t.width*4+4*o;i.data[e]=t.data[r],i.data[e+1]=t.data[r+1],i.data[e+2]=t.data[r+2],i.data[e+3]=t.data[r+3]}}}}createLinearGradient(t,e,r,i){return this._core.createLinearGradient(t,e,r,i)}createRadialGradient(t,e,r,i,s,n){return this._core.createRadialGradient(t,e,r,i,s,n)}createConicGradient(t,e,r){return this._core.createConicGradient(t,e,r)}createPattern(t,e){return this._core.createPattern(t,e)}get _coreContext(){return this._core}}class A{constructor(t=300,e=150){this._width=t,this._height=e,this._surface=new n(t,e),this._context=null}get width(){return this._width}set width(t){const e=Math.max(1,Math.floor(t));e!==this._width&&(this._width=e,this._recreateSurface())}get height(){return this._height}set height(t){const e=Math.max(1,Math.floor(t));e!==this._height&&(this._height=e,this._recreateSurface())}getContext(t){if("2d"!==t)throw new Error("SWCanvas only supports 2d context");return this._context||(this._context=new v(this._surface)),this._context}_recreateSurface(){this._surface=new n(this._width,this._height),this._context&&this._context._updateSurface(this._surface)}get _coreSurface(){return this._surface}get _imageData(){return{width:this._width,height:this._height,data:this._surface.data}}get data(){return this._surface.data}toString(){return`[object SWCanvasElement(${this._width}x${this._height})]`}}function k(t=300,e=150){return new A(t,e)}function B(t,e){return new n(t,e)}function I(t,e){if("number"!=typeof t||t<=0||!Number.isInteger(t))throw new Error("Width must be a positive integer");if("number"!=typeof e||e<=0||!Number.isInteger(e))throw new Error("Height must be a positive integer");return{width:t,height:e,data:new Uint8ClampedArray(t*e*4)}}"undefined"!=typeof window?window.SWCanvas={createCanvas:k,createImageData:I,Core:{Surface:B,Context2D:E,Transform2D:i,SWPath2D:s,Color:t,Point:e,Rectangle:r,BitmapEncoder:h,BitmapEncodingOptions:o,PngEncoder:c,PngEncodingOptions:l,BitBuffer:g,ClipMask:m,SourceMask:_,ShadowBuffer:p,BoxBlur:b,ImageProcessor:w,CompositeOperations:a,Rasterizer:C,PathFlattener:u,PolygonFiller:f,StrokeGenerator:d,Gradient:x,LinearGradient:M,RadialGradient:P,ConicGradient:S,Pattern:O}}:"undefined"!=typeof module&&module.exports&&(module.exports={createCanvas:k,createImageData:I,Core:{Surface:B,Context2D:E,Transform2D:i,SWPath2D:s,Color:t,Point:e,Rectangle:r,BitmapEncoder:h,BitmapEncodingOptions:o,PngEncoder:c,PngEncodingOptions:l,BitBuffer:g,ClipMask:m,SourceMask:_,ShadowBuffer:p,BoxBlur:b,ImageProcessor:w,CompositeOperations:a,Rasterizer:C,PathFlattener:u,PolygonFiller:f,StrokeGenerator:d,Gradient:x,LinearGradient:M,RadialGradient:P,ConicGradient:S,Pattern:O}})}();
//# sourceMappingURL=swcanvas.min.js.map