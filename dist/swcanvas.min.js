!function(){"use strict";class t{constructor(t,e,r,i=255,s=!1){if(t<0||t>255||e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("Color components must be in range 0-255");if(s)this._r=Math.round(t),this._g=Math.round(e),this._b=Math.round(r),this._a=Math.round(i);else{const s=i/255;this._r=Math.round(t*s),this._g=Math.round(e*s),this._b=Math.round(r*s),this._a=Math.round(i)}}static transparent(){return new t(0,0,0,0)}get premultipliedR(){return this._r}get premultipliedG(){return this._g}get premultipliedB(){return this._b}get premultipliedA(){return this._a}get r(){return 0===this._a?0:255===this._a?this._r:Math.round(255*this._r/this._a)}get g(){return 0===this._a?0:255===this._a?this._g:Math.round(255*this._g/this._a)}get b(){return 0===this._a?0:255===this._a?this._b:Math.round(255*this._b/this._a)}get a(){return this._a}toRGBA(){return[this.r,this.g,this.b,this.a]}toPremultipliedRGBA(){return[this._r,this._g,this._b,this._a]}get normalizedAlpha(){return this._a/255}get isTransparent(){return 0===this._a}get isOpaque(){return 255===this._a}withGlobalAlpha(e){if(e<0||e>1)throw new Error("Global alpha must be in range 0-1");const r=this.r,i=this.g,s=this.b,n=this.a,a=Math.round(n*e);return new t(r,i,s,a,!1)}blendOver(e){if(255===this._a)return this;if(0===this._a)return e;const r=1-this.normalizedAlpha,i=Math.round(this._r+e._r*r),s=Math.round(this._g+e._g*r),n=Math.round(this._b+e._b*r),a=Math.round(this._a+e._a*r);return new t(i,s,n,a,!0)}toBMP(){return{r:this.r,g:this.g,b:this.b}}toString(){return`Color(${this.r}, ${this.g}, ${this.b}, ${this.a})`}equals(e){return e instanceof t&&this._r===e._r&&this._g===e._g&&this._b===e._b&&this._a===e._a}}class e{constructor(t,e){if("number"!=typeof t||"number"!=typeof e)throw new Error("Point coordinates must be numbers");if(!isFinite(t)||!isFinite(e))throw new Error("Point coordinates must be finite numbers");this._x=t,this._y=e,Object.freeze(this)}get x(){return this._x}get y(){return this._y}static from(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Object must have numeric x and y properties");return new e(t.x,t.y)}distanceTo(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");const r=this._x-t._x,i=this._y-t._y;return Math.sqrt(r*r+i*i)}translate(t,r){return new e(this._x+t,this._y+r)}add(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return new e(this._x+t._x,this._y+t._y)}subtract(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return new e(this._x-t._x,this._y-t._y)}scale(t){if("number"!=typeof t)throw new Error("Scale factor must be a number");return new e(this._x*t,this._y*t)}scaleXY(t,r){if("number"!=typeof t||"number"!=typeof r)throw new Error("Scale factors must be numbers");return new e(this._x*t,this._y*r)}rotate(t){if("number"!=typeof t)throw new Error("Angle must be a number");const r=Math.cos(t),i=Math.sin(t);return new e(this._x*r-this._y*i,this._x*i+this._y*r)}rotateAround(t,r){if(!(t instanceof e))throw new Error("Center must be a Point instance");return this.subtract(t).rotate(r).add(t)}get magnitude(){return Math.sqrt(this._x*this._x+this._y*this._y)}get magnitudeSquared(){return this._x*this._x+this._y*this._y}normalize(){const t=this.magnitude;return 0===t?new e(0,0):new e(this._x/t,this._y/t)}dot(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return this._x*t._x+this._y*t._y}cross(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return this._x*t._y-this._y*t._x}round(){return new e(Math.round(this._x),Math.round(this._y))}floor(){return new e(Math.floor(this._x),Math.floor(this._y))}ceil(){return new e(Math.ceil(this._x),Math.ceil(this._y))}clamp(t,r,i,s){return new e(Math.max(t,Math.min(i,this._x)),Math.max(r,Math.min(s,this._y)))}lerp(t,r){if(!(t instanceof e))throw new Error("Target must be a Point instance");if("number"!=typeof r||r<0||r>1)throw new Error("Interpolation factor must be between 0 and 1");return new e(this._x+(t._x-this._x)*r,this._y+(t._y-this._y)*r)}toObject(){return{x:this._x,y:this._y}}toArray(){return[this._x,this._y]}equals(t,r=1e-10){return t instanceof e&&Math.abs(this._x-t._x)<r&&Math.abs(this._y-t._y)<r}isOrigin(t=1e-10){return Math.abs(this._x)<t&&Math.abs(this._y)<t}toString(){return`Point(${this._x}, ${this._y})`}}class r{constructor(t,e,r,i){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("Rectangle parameters must be numbers");if(!(isFinite(t)&&isFinite(e)&&isFinite(r)&&isFinite(i)))throw new Error("Rectangle parameters must be finite numbers");if(r<0||i<0)throw new Error("Rectangle dimensions must be non-negative");this._x=t,this._y=e,this._width=r,this._height=i,Object.freeze(this)}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this._x}get top(){return this._y}get right(){return this._x+this._width}get bottom(){return this._y+this._height}static boundingBox(t){if(!Array.isArray(t))throw new Error("Points must be an array");if(0===t.length)return new r(0,0,0,0);for(const r of t)if(!(r instanceof e))throw new Error("All items must be Point instances");let i=1/0,s=1/0,n=-1/0,a=-1/0;for(const e of t)i=Math.min(i,e.x),s=Math.min(s,e.y),n=Math.max(n,e.x),a=Math.max(a,e.y);return new r(i,s,n-i,a-s)}get center(){return new e(this._x+this._width/2,this._y+this._height/2)}get area(){return this._width*this._height}get perimeter(){return 2*(this._width+this._height)}get isEmpty(){return 0===this._width||0===this._height}get isSquare(){return this._width===this._height&&this._width>0}toString(){return`Rectangle(${this._x}, ${this._y}, ${this._width}, ${this._height})`}}class i{constructor(t){if(t&&Array.isArray(t)&&6===t.length){for(let e=0;e<6;e++)if("number"!=typeof t[e]||!isFinite(t[e]))throw new Error(`Transform2D component ${e} must be a finite number`);this.a=t[0],this.b=t[1],this.c=t[2],this.d=t[3],this.e=t[4],this.f=t[5]}else{if(t&&void 0!==t.length)throw new Error("Transform2D initialization array must have exactly 6 elements");this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0}Object.freeze(this)}static translation(t,e){return new i([1,0,0,1,t,e])}static scaling(t,e){return new i([t,0,0,e,0,0])}static rotation(t){const e=Math.cos(t),r=Math.sin(t);return new i([e,r,-r,e,0,0])}multiply(t){if(!(t instanceof i))throw new Error("Can only multiply with another Transform2D");return new i([this.a*t.a+this.b*t.c,this.a*t.b+this.b*t.d,this.c*t.a+this.d*t.c,this.c*t.b+this.d*t.d,this.e*t.a+this.f*t.c+t.e,this.e*t.b+this.f*t.d+t.f])}translate(t,e){const r=i.translation(t,e);return this.multiply(r)}scale(t,e){const r=i.scaling(t,e);return this.multiply(r)}rotate(t){const e=i.rotation(t);return this.multiply(e)}invert(){const t=this.a*this.d-this.b*this.c;if(Math.abs(t)<1e-10)throw new Error("Transform2D matrix is not invertible (determinant ≈ 0)");return new i([this.d/t,-this.b/t,-this.c/t,this.a/t,(this.c*this.f-this.d*this.e)/t,(this.b*this.e-this.a*this.f)/t])}transformPoint(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Point must have numeric x and y properties");return{x:this.a*t.x+this.c*t.y+this.e,y:this.b*t.x+this.d*t.y+this.f}}transformPoints(t){return t.map(t=>this.transformPoint(t))}toArray(){return[this.a,this.b,this.c,this.d,this.e,this.f]}get isIdentity(){return 1===this.a&&0===this.b&&0===this.c&&1===this.d&&0===this.e&&0===this.f}get determinant(){return this.a*this.d-this.b*this.c}equals(t,e=1e-10){return t instanceof i&&Math.abs(this.a-t.a)<e&&Math.abs(this.b-t.b)<e&&Math.abs(this.c-t.c)<e&&Math.abs(this.d-t.d)<e&&Math.abs(this.e-t.e)<e&&Math.abs(this.f-t.f)<e}toString(){return`Transform2D([${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e}, ${this.f}])`}}class s{constructor(){this.commands=[]}closePath(){this.commands.push({type:"closePath"})}moveTo(t,e){this.commands.push({type:"moveTo",x:t,y:e})}lineTo(t,e){this.commands.push({type:"lineTo",x:t,y:e})}bezierCurveTo(t,e,r,i,s,n){this.commands.push({type:"bezierCurveTo",cp1x:t,cp1y:e,cp2x:r,cp2y:i,x:s,y:n})}quadraticCurveTo(t,e,r,i){this.commands.push({type:"quadraticCurveTo",cpx:t,cpy:e,x:r,y:i})}rect(t,e,r,i){this.moveTo(t,e),this.lineTo(t+r,e),this.lineTo(t+r,e+i),this.lineTo(t,e+i),this.closePath()}arc(t,e,r,i,s,n){this.commands.push({type:"arc",x:t,y:e,radius:r,startAngle:i,endAngle:s,counterclockwise:!!n})}ellipse(t,e,r,i,s,n,a,o){this.commands.push({type:"ellipse",x:t,y:e,radiusX:r,radiusY:i,rotation:s,startAngle:n,endAngle:a,counterclockwise:!!o})}}class n{constructor(t,e){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("Surface width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("Surface height must be a positive integer");if(t*e>268435456)throw new Error("SurfaceTooLarge");const r=16384;if(t>r||e>r)throw new Error("Surface dimensions must be ≤ 16384x16384");Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1}),Object.defineProperty(this,"stride",{value:4*t,writable:!1}),this.data=new Uint8ClampedArray(this.stride*e)}clone(){const t=new n(this.width,this.height);return t.data.set(this.data),t}getPixel(e,r){if(e<0||e>=this.width||r<0||r>=this.height)return null;const i=r*this.stride+4*e;return new t(this.data[i],this.data[i+1],this.data[i+2],this.data[i+3],!1)}setPixel(e,r,i){if(e<0||e>=this.width||r<0||r>=this.height)return;if(!(i instanceof t))throw new Error("Color must be a Color instance");const s=r*this.stride+4*e;this.data[s]=i.r,this.data[s+1]=i.g,this.data[s+2]=i.b,this.data[s+3]=i.a}clear(e=t.transparent()){if(!(e instanceof t))throw new Error("Color must be a Color instance");const r=e.toRGBA();for(let t=0;t<this.data.length;t+=4)this.data[t]=r[0],this.data[t+1]=r[1],this.data[t+2]=r[2],this.data[t+3]=r[3]}getMemoryUsage(){return this.data.byteLength}toString(){const t=(this.getMemoryUsage()/1048576).toFixed(2);return`Surface(${this.width}×${this.height}, ${t}MB)`}}class a{static blendPixel(t,e,r,i,s,n,o,h,l){if(0===s)switch(t){case"destination-out":default:return{r:n,g:o,b:h,a:l};case"destination-atop":case"source-in":case"destination-in":case"source-out":return{r:0,g:0,b:0,a:0};case"copy":return{r:e,g:r,b:i,a:s}}if(0===l)switch(t){case"source-over":case"destination-over":case"destination-atop":case"source-out":case"xor":case"copy":default:return{r:e,g:r,b:i,a:s};case"source-atop":case"destination-out":case"source-in":case"destination-in":return{r:0,g:0,b:0,a:0}}const c=s/255,u=l/255;let f,g,d,m;switch(t){case"source-over":default:return a._sourceOver(e,r,i,s,n,o,h,l);case"destination-over":return a._sourceOver(n,o,h,l,e,r,i,s);case"source-atop":if(m=l,0===l)return{r:0,g:0,b:0,a:0};f=Math.round(c*e+(1-c)*n),g=Math.round(c*r+(1-c)*o),d=Math.round(c*i+(1-c)*h);break;case"destination-atop":if(m=s,0===s)return{r:0,g:0,b:0,a:0};f=Math.round(u*n+(1-u)*e),g=Math.round(u*o+(1-u)*r),d=Math.round(u*h+(1-u)*i);break;case"source-in":if(m=Math.round(s*u),0===m)return{r:0,g:0,b:0,a:0};f=e,g=r,d=i;break;case"destination-in":if(m=Math.round(l*c),0===m)return{r:0,g:0,b:0,a:0};f=n,g=o,d=h;break;case"source-out":if(m=Math.round(s*(1-u)),0===m)return{r:0,g:0,b:0,a:0};f=e,g=r,d=i;break;case"destination-out":if(m=Math.round(l*(1-c)),0===m)return{r:0,g:0,b:0,a:0};f=n,g=o,d=h;break;case"xor":return 0===c&&0===u?{r:0,g:0,b:0,a:0}:0===c?{r:n,g:o,b:h,a:l}:0===u?{r:e,g:r,b:i,a:s}:{r:0,g:0,b:0,a:0};case"copy":return{r:e,g:r,b:i,a:s}}return{r:Math.max(0,Math.min(255,Math.round(f))),g:Math.max(0,Math.min(255,Math.round(g))),b:Math.max(0,Math.min(255,Math.round(d))),a:Math.max(0,Math.min(255,Math.round(m)))}}static _sourceOver(t,e,r,i,s,n,a,o){if(255===i)return{r:t,g:e,b:r,a:i};const h=i/255,l=1-h;return{r:Math.round(t*h+s*l),g:Math.round(e*h+n*l),b:Math.round(r*h+a*l),a:Math.round(i+o*l)}}static getSupportedOperations(){return["source-over","destination-over","source-atop","destination-atop","source-in","destination-in","source-out","destination-out","xor","copy"]}static isSupported(t){return a.getSupportedOperations().includes(t)}}class o{constructor(t={r:255,g:255,b:255}){if(!t||"object"!=typeof t)throw new Error("backgroundColor must be an object with r, g, b properties");const{r:e,g:r,b:i}=t;if("number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("backgroundColor components (r, g, b) must be numbers");if(e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("backgroundColor components must be in range 0-255");this._backgroundColor=Object.freeze({r:Math.round(e),g:Math.round(r),b:Math.round(i)}),Object.freeze(this)}get backgroundColor(){return this._backgroundColor}static withBackgroundColor(t,e,r){return new o({r:t,g:e,b:r})}static withWhiteBackground(){return new o({r:255,g:255,b:255})}static withBlackBackground(){return new o({r:0,g:0,b:0})}static withGrayBackground(t=128){return new o({r:t,g:t,b:t})}equals(t){if(!(t instanceof o))return!1;const e=this._backgroundColor,r=t._backgroundColor;return e.r===r.r&&e.g===r.g&&e.b===r.b}toString(){const t=this._backgroundColor;return`BitmapEncodingOptions(backgroundColor: rgb(${t.r}, ${t.g}, ${t.b}))`}}o.DEFAULT=new o;class h{static encode(t,e=o.DEFAULT){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");const r=t.width,i=t.height,s=t.data,n=r*i*4;if(s.length!==n)throw new Error(`Surface data size mismatch. Expected ${n}, got ${s.length}`);const a=h._calculateDimensions(r,i),l=new ArrayBuffer(a.fileSize),c=new DataView(l),u=new Uint8Array(l);return h._writeBMPHeaders(c,a),h._writePixelData(u,s,t,a,e),l}static _calculateDimensions(t,e){const r=4*Math.floor((3*t+3)/4),i=r*e;return{width:t,height:e,rowSize:r,imageSize:i,fileSize:h.BMP_HEADER_SIZE+i}}static _writeBMPHeaders(t,e){h._writeBMPFileHeader(t,e.fileSize),h._writeBMPInfoHeader(t,e)}static _writeBMPFileHeader(t,e){const r=new Uint8Array(t.buffer);r[0]=66,r[1]=77,t.setUint32(2,e,!0),t.setUint32(6,0,!0),t.setUint32(10,h.BMP_HEADER_SIZE,!0)}static _writeBMPInfoHeader(t,e){t.setUint32(14,40,!0),t.setInt32(18,e.width,!0),t.setInt32(22,-e.height,!0),t.setUint16(26,1,!0),t.setUint16(28,24,!0),t.setUint32(30,0,!0),t.setUint32(34,e.imageSize,!0);t.setInt32(38,2835,!0),t.setInt32(42,2835,!0),t.setUint32(46,0,!0),t.setUint32(50,0,!0)}static _writePixelData(t,e,r,i,s){let n=h.BMP_HEADER_SIZE;for(let a=0;a<i.height;a++){let o=n;for(let n=0;n<i.width;n++){const i=a*r.stride+4*n,l=e[i],c=e[i+1],u=e[i+2],f=e[i+3],g=h._unpremultiplyAlpha(l,c,u,f,s.backgroundColor);t[o]=g.b,t[o+1]=g.g,t[o+2]=g.r,o+=3}for(;o-n<i.rowSize;)t[o]=0,o++;n+=i.rowSize}}static _unpremultiplyAlpha(t,e,r,i,s={r:255,g:255,b:255}){if(0===i)return{r:s.r,g:s.g,b:s.b};if(255===i)return{r:t,g:e,b:r};const n=i/255;return{r:Math.round(t*n+s.r*(1-n)),g:Math.round(e*n+s.g*(1-n)),b:Math.round(r*n+s.b*(1-n))}}static getBMPInfo(t){if(!t||!t.width||!t.height)throw new Error("Invalid surface");const e=h._calculateDimensions(t.width,t.height);return{width:e.width,height:e.height,bitsPerPixel:24,compression:"None",rowSize:e.rowSize,imageSize:e.imageSize,fileSize:e.fileSize,headerSize:h.BMP_HEADER_SIZE}}static canEncode(t){try{if(!t||"object"!=typeof t)return!1;if(!t.width||!t.height||!t.data)return!1;if(t.width<=0||t.height<=0)return!1;if(t.width>h.MAX_DIMENSION||t.height>h.MAX_DIMENSION)return!1;const e=t.width*t.height*4;return t.data.length===e}catch(t){return!1}}static calculateMemoryUsage(t,e){if(t<=0||e<=0)return 0;return h._calculateDimensions(t,e).fileSize}}h.BMP_HEADER_SIZE=54,h.MAX_DIMENSION=65535;class l{static flattenPath(t){const r=[];let i=[],s=new e(0,0),n=new e(0,0);for(const a of t.commands)switch(a.type){case"moveTo":l._handleMoveTo(a,r,i),s=new e(a.x,a.y),n=new e(a.x,a.y),i=[s.toObject()];break;case"lineTo":s=new e(a.x,a.y),i.push(s.toObject());break;case"closePath":l._handleClosePath(i,n,r),i=[];break;case"quadraticCurveTo":const t=l._flattenQuadraticBezier(s.x,s.y,a.cpx,a.cpy,a.x,a.y);l._appendPoints(i,t,1),s=new e(a.x,a.y);break;case"bezierCurveTo":const o=l._flattenCubicBezier(s.x,s.y,a.cp1x,a.cp1y,a.cp2x,a.cp2y,a.x,a.y);l._appendPoints(i,o,1),s=new e(a.x,a.y);break;case"arc":const h=l._handleArc(a,i,s,n);s=h.currentPoint,i=h.currentPoly,h.subpathStart&&(n=h.subpathStart);break;case"ellipse":const c=l._flattenEllipse(a.x,a.y,a.radiusX,a.radiusY,a.rotation,a.startAngle,a.endAngle,a.counterclockwise);l._handleEllipsePoints(c,i,s),c.length>0&&(s=new e(c[c.length-1].x,c[c.length-1].y))}return i.length>0&&r.push(i),r}static _handleMoveTo(t,e,r){r.length>0&&e.push(r)}static _handleClosePath(t,e,r){if(t.length>0){const i=t[t.length-1];i.x===e.x&&i.y===e.y||t.push(e.toObject()),r.push(t)}}static _appendPoints(t,e,r){for(let i=r;i<e.length;i++)t.push(e[i])}static _handleArc(t,r,i,s){const n=l._flattenArc(t.x,t.y,t.radius,t.startAngle,t.endAngle,t.counterclockwise);if(0===n.length)return{currentPoint:i,currentPoly:r,subpathStart:null};const a=new e(n[0].x,n[0].y);if(0===r.length){r.push(a.toObject());const t=a,i=a;return l._appendPoints(r,n,1),{currentPoint:n.length>1?new e(n[n.length-1].x,n[n.length-1].y):t,currentPoly:r,subpathStart:i}}return i.distanceTo(a)>.01&&r.push(a.toObject()),l._appendPoints(r,n,1),{currentPoint:new e(n[n.length-1].x,n[n.length-1].y),currentPoly:r,subpathStart:null}}static _handleEllipsePoints(t,r,i){if(t.length>0){const s=new e(t[0].x,t[0].y);i.distanceTo(s)>.01&&r.push(s.toObject()),l._appendPoints(r,t,1)}}static _flattenQuadraticBezier(t,e,r,i,s,n){const a=[{x:t,y:e}];return l._flattenQuadraticBezierRecursive(t,e,r,i,s,n,a,l.TOLERANCE),a}static _flattenQuadraticBezierRecursive(t,e,r,i,s,n,a,o){const h=s-t,c=n-e;if(Math.abs((r-t)*c-(i-e)*h)/Math.sqrt(h*h+c*c)<=o||a.length>1e3)return void a.push({x:s,y:n});const u=(t+r)/2,f=(e+i)/2,g=(r+s)/2,d=(i+n)/2,m=(u+g)/2,_=(f+d)/2;l._flattenQuadraticBezierRecursive(t,e,u,f,m,_,a,o),l._flattenQuadraticBezierRecursive(m,_,g,d,s,n,a,o)}static _flattenCubicBezier(t,e,r,i,s,n,a,o){const h=[{x:t,y:e}];return l._flattenCubicBezierRecursive(t,e,r,i,s,n,a,o,h,l.TOLERANCE),h}static _flattenCubicBezierRecursive(t,e,r,i,s,n,a,o,h,c){const u=a-t,f=o-e,g=Math.sqrt(u*u+f*f);if(0===g)return void h.push({x:a,y:o});if(Math.abs((r-t)*f-(i-e)*u)/g+Math.abs((s-t)*f-(n-e)*u)/g<=c||h.length>1e3)return void h.push({x:a,y:o});const d=(t+r)/2,m=(e+i)/2,_=(r+s)/2,b=(i+n)/2,p=(s+a)/2,y=(n+o)/2,w=(d+_)/2,x=(m+b)/2,M=(_+p)/2,P=(b+y)/2,C=(w+M)/2,S=(x+P)/2;l._flattenCubicBezierRecursive(t,e,d,m,w,x,C,S,h,c),l._flattenCubicBezierRecursive(C,S,M,P,p,y,a,o,h,c)}static _flattenArc(t,e,r,i,s,n){if(r<=0)return[];let a=i,o=s;!n&&o<a?o+=2*Math.PI:n&&a<o&&(a+=2*Math.PI);const h=Math.abs(o-a),c=2*Math.acos(Math.max(0,1-l.TOLERANCE/r)),u=Math.max(1,Math.ceil(h/c)),f=[],g=(o-a)/u;for(let i=0;i<=u;i++){const s=a+i*g;f.push({x:t+r*Math.cos(s),y:e+r*Math.sin(s)})}return f}static _flattenEllipse(t,e,r,i,s,n,a,o){if(r<=0||i<=0)return[];let h=n,c=a;!o&&c<h?c+=2*Math.PI:o&&h<c&&(h+=2*Math.PI);const u=Math.abs(c-h),f=Math.min(r,i),g=2*Math.acos(Math.max(0,1-l.TOLERANCE/f)),d=Math.max(1,Math.ceil(u/g)),m=[],_=(c-h)/d,b=Math.cos(s),p=Math.sin(s);for(let s=0;s<=d;s++){const n=h+s*_,a=r*Math.cos(n),o=i*Math.sin(n);m.push({x:t+a*b-o*p,y:e+a*p+o*b})}return m}}l.TOLERANCE=.25;class c{static fillPolygons(t,e,r,i,s,n,a=1,o=1,h="source-over",l=null){if(0===e.length)return;if(!c._isValidPaintSource(r))throw new Error("Paint source must be a Color, Gradient, or Pattern instance");const u=e.map(t=>t.map(t=>s.transformPoint(t))),f=c._calculateBounds(u,t);for(let e=f.minY;e<=f.maxY;e++)c._fillScanline(t,e,u,r,i,n,s,a,o,h,l)}static _calculateBounds(t,e){let r=1/0,i=-1/0;for(const e of t)for(const t of e)r=Math.min(r,t.y),i=Math.max(i,t.y);return{minY:Math.max(0,Math.floor(r)),maxY:Math.min(e.height-1,Math.ceil(i))}}static _fillScanline(t,e,r,i,s,n,a,o,h=1,l="source-over",u=null){const f=[];for(const t of r)c._findPolygonIntersections(t,e+.5,f);f.sort((t,e)=>t.x-e.x),c._fillSpans(t,e,f,i,s,n,a,o,h,l,u)}static _findPolygonIntersections(t,e,r){for(let i=0;i<t.length;i++){const s=t[i],n=t[(i+1)%t.length];if(Math.abs(s.y-n.y)<1e-10)continue;const a=Math.min(s.y,n.y),o=Math.max(s.y,n.y);if(e>=a&&e<o){const t=(e-s.y)/(n.y-s.y),i=s.x+t*(n.x-s.x),a=n.y>s.y?1:-1;r.push({x:i,winding:a})}}}static _fillSpans(t,e,r,i,s,n,a,o,h=1,l="source-over",u=null){if(0===r.length)return;let f=0,g=!1;for(let d=0;d<r.length;d++){const m=r[d],_=r[d+1];if(f+=m.winding,g="evenodd"===s?f%2!=0:0!==f,g&&_){const r=Math.max(0,Math.ceil(m.x)),s=Math.min(t.width-1,Math.floor(_.x));c._fillPixelSpan(t,e,r,s,i,n,a,o,h,l,u)}}}static _fillPixelSpan(t,e,r,i,s,n,a,o,h=1,l="source-over",u=null){for(let f=r;f<=i;f++){if(n&&n.isPixelClipped(f,e))continue;if(u){u.setPixel(f,e,!0);continue}const r=c._evaluatePaintSource(s,f,e,a,o,h),i=e*t.stride+4*f;c._blendPixel(t,i,r,l)}}static _blendPixel(t,e,r,i="source-over"){const s=t.data[e],n=t.data[e+1],o=t.data[e+2],h=t.data[e+3],l=a.blendPixel(i,r.r,r.g,r.b,r.a,s,n,o,h);t.data[e]=l.r,t.data[e+1]=l.g,t.data[e+2]=l.b,t.data[e+3]=l.a}static colorFromRGBA(e){return new t(e[0],e[1],e[2],e[3],!1)}static getPolygonBounds(t){if(0===t.length)return new r(0,0,0,0);const i=t.flat();return r.boundingBox(i.map(t=>new e(t.x,t.y)))}static countVertices(t){return t.reduce((t,e)=>t+e.length,0)}static _isValidPaintSource(e){return e instanceof t||e instanceof b||e instanceof p||e instanceof y||e instanceof w||e instanceof x}static _evaluatePaintSource(e,r,i,s,n,a=1){let o;o=e instanceof t?e:e instanceof b||e instanceof p||e instanceof y||e instanceof w||e instanceof x?e.getColorForPixel(r,i,s):new t(0,0,0,0);let h=o.withGlobalAlpha(n);if(a<1){const e=Math.round(h.a*a);h=new t(h.r,h.g,h.b,e,h.premultiplied)}return h}}class u{static generateStrokePolygons(t,e){const r=u._validateStrokeProperties(e);if(r.lineWidth<=0)return[];const i=l.flattenPath(t),s=u._applyDashPattern(i,r),n=[];for(const t of s){if(t.length<2)continue;const e=u._generateStrokeForPolygon(t,r);n.push(...e)}return n}static _validateStrokeProperties(t){const e={lineWidth:1,lineJoin:"miter",lineCap:"butt",miterLimit:10,lineDash:[],lineDashOffset:0,...t};if(e.lineWidth<0)throw new Error("lineWidth must not be negative");if(!["miter","round","bevel"].includes(e.lineJoin))throw new Error(`Invalid lineJoin: ${e.lineJoin}`);if(!["butt","round","square"].includes(e.lineCap))throw new Error(`Invalid lineCap: ${e.lineCap}`);if(e.miterLimit<=0)throw new Error("miterLimit must be positive");return e}static _applyDashPattern(t,e){if(!e.lineDash||0===e.lineDash.length)return t;const r=[];for(const i of t){if(i.length<2)continue;const t=u._dashPolygon(i,e.lineDash,e.lineDashOffset);r.push(...t)}return r}static _dashPolygon(t,e,r){if(t.length<2)return[];const i=[],s=e.reduce((t,e)=>t+e,0);if(s<=0)return[t];let n=r%s;n<0&&(n+=s);let a=n,o=0,h=!0,l=0;for(let t=0;t<e.length;t++){if(l+e[t]>n){o=t,a=n-l,h=t%2==0;break}l+=e[t]}let c=[];for(let r=0;r<t.length-1;r++){const s=t[r],n=t[r+1],l=Math.sqrt(Math.pow(n.x-s.x,2)+Math.pow(n.y-s.y,2));if(0===l)continue;const f=u._processSegmentWithDash(s,n,l,e,o,a,h,c,i);o=f.patternIndex,a=f.patternPosition,h=f.isDash,c=f.currentSegment}return c.length>1&&i.push(c),i}static _processSegmentWithDash(t,e,r,i,s,n,a,o,h){let l=r,c=t;for(a&&0===o.length&&o.push({x:t.x,y:t.y});l>0;){const u=i[s],f=u-n,g=Math.min(l,f),d=(r-l+g)/r,m={x:t.x+d*(e.x-t.x),y:t.y+d*(e.y-t.y)};a&&o.push({x:m.x,y:m.y}),l-=g,(n+=g)>=u&&(a&&o.length>1&&(h.push(o),o=[]),s=(s+1)%i.length,n=0,(a=!a)&&l>0&&(o=[{x:m.x,y:m.y}])),c=m}return{patternIndex:s,patternPosition:n,isDash:a,currentSegment:o}}static _generateStrokeForPolygon(t,e){if(t.length<2)return[];const r=[],i=e.lineWidth/2,s=u._isPathClosed(t),n=u._generateSegments(t,i);if(0===n.length)return[];for(const t of n)r.push(t.body);return u._generateJoins(n,r,e,s),!s&&n.length>0&&u._generateCaps(n,r,e,i),r}static _isPathClosed(t){return t.length>2&&Math.abs(t[0].x-t[t.length-1].x)<1e-10&&Math.abs(t[0].y-t[t.length-1].y)<1e-10}static _generateSegments(t,r){const i=[];for(let s=0;s<t.length-1;s++){const n=new e(t[s].x,t[s].y),a=new e(t[s+1].x,t[s+1].y),o=n.distanceTo(a);if(o<1e-10)continue;const h=u._createSegment(n,a,r,o);i.push(h)}return i}static _createSegment(t,r,i,s){const n=r.subtract(t).scale(1/s),a=new e(-n.y,n.x);return{body:[t.add(a.scale(i)).toObject(),r.add(a.scale(i)).toObject(),r.add(a.scale(-i)).toObject(),t.add(a.scale(-i)).toObject()],p1:t,p2:r,tangent:n,normal:a,length:s}}static _generateJoins(t,e,r,i){for(let i=0;i<t.length-1;i++){const s=t[i],n=t[i+1],a=u._generateJoin(s,n,r);e.push(...a)}if(i&&t.length>1){const i=t[t.length-1],s=t[0],n=u._generateJoin(i,s,r);e.push(...n)}}static _generateJoin(t,e,r){const i=e.p1,s=t.tangent.cross(e.tangent);if(Math.abs(s)<1e-10)return u._generateBevelJoin(t,e,i);switch(r.lineJoin){case"miter":return u._generateMiterJoin(t,e,i,r.miterLimit);case"round":return u._generateRoundJoin(t,e,i);default:return u._generateBevelJoin(t,e,i)}}static _generateMiterJoin(t,e,r,i){const s=Math.sqrt(Math.pow(t.body[0].x-t.body[3].x,2)+Math.pow(t.body[0].y-t.body[3].y,2))/2,n=t.tangent.cross(e.tangent);let a,o;n>0?(a=t.body[2],o=e.body[3]):(a=t.body[1],o=e.body[0]);const h={x:a.x+100*t.tangent.x,y:a.y+100*t.tangent.y},l={x:o.x-100*e.tangent.x,y:o.y-100*e.tangent.y},c=u._lineIntersection(a,h,o,l);if(!c)return u._generateBevelJoin(t,e,r);if(Math.sqrt(Math.pow(c.x-r.x,2)+Math.pow(c.y-r.y,2))/s>i)return u._generateBevelJoin(t,e,r);let f,g;return n>0?(f=t.body[1],g=e.body[0]):(f=t.body[2],g=e.body[3]),[[a,c,o],[a,o,g,f]]}static _generateBevelJoin(t,e,r){const i=t.tangent.cross(e.tangent),s=u._getOuterSides(t,e,i),n=u._getInnerSides(t,e,i);return[[s.outer1,s.outer2,n.inner2,n.inner1]]}static _generateRoundJoin(t,e,r){const i=Math.sqrt(Math.pow(t.body[0].x-t.body[3].x,2)+Math.pow(t.body[0].y-t.body[3].y,2))/2;let s,n;t.tangent.cross(e.tangent)>0?(s=t.body[2],n=e.body[3]):(s=t.body[1],n=e.body[0]);let a=Math.atan2(s.y-r.y,s.x-r.x),o=Math.atan2(n.y-r.y,n.x-r.x),h=o-a;if(h>Math.PI?h-=2*Math.PI:h<-Math.PI&&(h+=2*Math.PI),h<0){const t=a;a=o,o=t,h=-h}const l=Math.max(2,Math.ceil(h/(Math.PI/4))),c=h/l,u=[];for(let t=0;t<l;t++){const e=a+t*c,s=a+(t+1)*c,n={x:r.x+i*Math.cos(e),y:r.y+i*Math.sin(e)},o={x:r.x+i*Math.cos(s),y:r.y+i*Math.sin(s)};u.push([r.toObject(),n,o])}return u}static _generateCaps(t,e,r,i){const s=u._generateCap(t[0].p1,t[0].tangent,i,r.lineCap,!0);s&&e.push(...Array.isArray(s[0])?s:[s]);const n=t[t.length-1],a=u._generateCap(n.p2,n.tangent,i,r.lineCap,!1);a&&e.push(...Array.isArray(a[0])?a:[a])}static _generateCap(t,r,i,s,n){const a=new e(-r.y,r.x);switch(s){case"square":return u._generateSquareCap(t,r,a,i,n);case"round":return u._generateRoundCap(t,a,i,n);default:return null}}static _generateSquareCap(t,e,r,i,s){const n=s?t.subtract(e.scale(i)):t.add(e.scale(i));return[[n.add(r.scale(i)).toObject(),n.subtract(r.scale(i)).toObject(),t.subtract(r.scale(i)).toObject(),t.add(r.scale(i)).toObject()]]}static _generateRoundCap(t,e,r,i){const s=Math.atan2(e.y,e.x);return u._generateArcFan(t,r,s,s+Math.PI*(i?1:-1))}static _getOuterSides(t,e,r){return r>0?{outer1:t.body[2],outer2:e.body[3]}:{outer1:t.body[1],outer2:e.body[0]}}static _getInnerSides(t,e,r){return r>0?{inner1:t.body[1],inner2:e.body[0]}:{inner1:t.body[2],inner2:e.body[3]}}static _lineIntersection(t,e,r,i){const s=(t.x-e.x)*(r.y-i.y)-(t.y-e.y)*(r.x-i.x);if(Math.abs(s)<1e-10)return null;const n=((t.x-r.x)*(r.y-i.y)-(t.y-r.y)*(r.x-i.x))/s;return{x:t.x+n*(e.x-t.x),y:t.y+n*(e.y-t.y)}}static _generateArcFan(t,e,r,i){let s=i-r;for(;s>Math.PI;)s-=2*Math.PI;for(;s<-Math.PI;)s+=2*Math.PI;const n=Math.abs(s),a=Math.max(2,Math.ceil(n/(Math.PI/4))),o=s/a,h=[];for(let i=0;i<a;i++){const s=r+i*o,n=r+(i+1)*o,a={x:t.x+e*Math.cos(s),y:t.y+e*Math.sin(s)},l={x:t.x+e*Math.cos(n),y:t.y+e*Math.sin(n)};h.push([t.toObject(),a,l])}return h}}class f{constructor(t,e,r=0){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("BitBuffer width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("BitBuffer height must be a positive integer");if(0!==r&&1!==r)throw new Error("BitBuffer defaultValue must be 0 or 1");this._width=t,this._height=e,this._numPixels=t*e,this._numBytes=Math.ceil(this._numPixels/8),this._defaultValue=r,this._buffer=new Uint8Array(this._numBytes),this._initializeToDefault(),Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}_initializeToDefault(){if(1===this._defaultValue){this._buffer.fill(255);const t=this._numPixels%8;if(0!==t){const e=this._numBytes-1,r=(1<<t)-1;this._buffer[e]=r}}else this._buffer.fill(0)}getPixel(t,e){if(t<0||t>=this._width||e<0||e>=this._height)return!1;const r=e*this._width+t;return 1===this._getBit(r)}setPixel(t,e,r){if(t<0||t>=this._width||e<0||e>=this._height)return;const i=e*this._width+t;this._setBit(i,r?1:0)}clear(){this._buffer.fill(0)}fill(){this._buffer.fill(255);const t=this._numPixels%8;if(0!==t){const e=this._numBytes-1,r=(1<<t)-1;this._buffer[e]=r}}reset(){this._initializeToDefault()}and(t){if(!(t instanceof f))throw new Error("Argument must be a BitBuffer instance");if(t._width!==this._width||t._height!==this._height)throw new Error("BitBuffer dimensions must match for AND operation");for(let e=0;e<this._numBytes;e++)this._buffer[e]&=t._buffer[e]}copyFrom(t){if(!(t instanceof f))throw new Error("Argument must be a BitBuffer instance");if(t._width!==this._width||t._height!==this._height)throw new Error("BitBuffer dimensions must match for copy operation");this._buffer.set(t._buffer)}isFull(){for(let t=0;t<this._numBytes-1;t++)if(255!==this._buffer[t])return!1;const t=this._numPixels%8;if(0===t)return 255===this._buffer[this._numBytes-1];{const e=(1<<t)-1;return this._buffer[this._numBytes-1]===e}}isEmpty(){for(let t=0;t<this._numBytes;t++)if(0!==this._buffer[t])return!1;return!0}getMemoryUsage(){return this._buffer.byteLength}_getBit(t){const e=Math.floor(t/8),r=t%8;return e>=this._buffer.length?0:this._buffer[e]&1<<r?1:0}_setBit(t,e){const r=Math.floor(t/8),i=t%8;r>=this._buffer.length||(e?this._buffer[r]|=1<<i:this._buffer[r]&=~(1<<i))}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this.isEmpty()?"empty":this.isFull()?"full":"mixed";return`BitBuffer(${this._width}×${this._height}, ${t}KB, ${e})`}equals(t){if(!(t instanceof f))return!1;if(t._width!==this._width||t._height!==this._height)return!1;for(let e=0;e<this._numBytes;e++)if(this._buffer[e]!==t._buffer[e])return!1;return!0}}class g{constructor(t,e){this._bitBuffer=new f(t,e,1),Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}getPixel(t,e){return this._bitBuffer.getPixel(t,e)}setPixel(t,e,r){this._bitBuffer.setPixel(t,e,r)}isPixelClipped(t,e){return!this.getPixel(t,e)}clear(){this._bitBuffer.fill()}clipAll(){this._bitBuffer.clear()}intersectWith(t){if(!(t instanceof g))throw new Error("Argument must be a ClipMask instance");this._bitBuffer.and(t._bitBuffer)}clone(){const t=new g(this.width,this.height);return t._bitBuffer.copyFrom(this._bitBuffer),t}createPixelWriter(){return(t,e,r)=>{if(t<0||t>=this._width||e<0||e>=this._height)return;const i=r>.5;this.setPixel(t,e,i)}}getMemoryUsage(){return this._bitBuffer.getMemoryUsage()}hasClipping(){return!this._bitBuffer.isFull()}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this.hasClipping()?"with clipping":"no clipping";return`ClipMask(${this.width}×${this.height}, ${t}KB, ${e})`}equals(t){return t instanceof g&&this._bitBuffer.equals(t._bitBuffer)}}class d{constructor(t,e){this._bitBuffer=new f(t,e,0),this._bounds={minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0,isEmpty:!0},Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}getPixel(t,e){return this._bitBuffer.getPixel(t,e)}setPixel(t,e,r){if(t<0||t>=this.width||e<0||e>=this.height)return;const i=this._bitBuffer.getPixel(t,e);this._bitBuffer.setPixel(t,e,r),r&&!i&&(this._bounds.isEmpty?(this._bounds.minX=t,this._bounds.minY=e,this._bounds.maxX=t,this._bounds.maxY=e,this._bounds.isEmpty=!1):(this._bounds.minX=Math.min(this._bounds.minX,t),this._bounds.minY=Math.min(this._bounds.minY,e),this._bounds.maxX=Math.max(this._bounds.maxX,t),this._bounds.maxY=Math.max(this._bounds.maxY,e)))}clear(){this._bitBuffer.clear(),this._bounds={minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0,isEmpty:!0}}isEmpty(){return this._bounds.isEmpty}getBounds(){return{minX:this._bounds.minX,minY:this._bounds.minY,maxX:this._bounds.maxX,maxY:this._bounds.maxY,isEmpty:this._bounds.isEmpty}}getIterationBounds(t=null,e=!1){if(this._bounds.isEmpty)return{minX:0,minY:0,maxX:-1,maxY:-1,isEmpty:!0};if(e)return t&&t.hasClipping(),{minX:0,minY:0,maxX:this.width-1,maxY:this.height-1,isEmpty:!1};return{minX:Math.max(0,this._bounds.minX),minY:Math.max(0,this._bounds.minY),maxX:Math.min(this.width-1,this._bounds.maxX),maxY:Math.min(this.height-1,this._bounds.maxY),isEmpty:!1}}createPixelWriter(){return(t,e,r)=>{if(t<0||t>=this.width||e<0||e>=this.height)return;const i=r>.5;this.setPixel(t,e,i)}}getMemoryUsage(){return this._bitBuffer.getMemoryUsage()}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this._bounds.isEmpty?"empty":`(${this._bounds.minX},${this._bounds.minY})-(${this._bounds.maxX},${this._bounds.maxY})`;return`SourceMask(${this.width}×${this.height}, ${t}KB, bounds: ${e})`}}class m{static validateAndConvert(t){m._validateImageLike(t);const e=t.width*t.height*3,r=t.width*t.height*4;if(t.data.length===e)return m._convertRGBToRGBA(t);if(t.data.length===r)return{width:t.width,height:t.height,data:t.data};throw new Error(`ImageLike data length (${t.data.length}) must match width*height*3 (${e}) for RGB or width*height*4 (${r}) for RGBA`)}static _validateImageLike(t){if(!t||"object"!=typeof t)throw new Error("ImageLike must be an object");if("number"!=typeof t.width||t.width<=0||!Number.isInteger(t.width))throw new Error("ImageLike width must be a positive integer");if("number"!=typeof t.height||t.height<=0||!Number.isInteger(t.height))throw new Error("ImageLike height must be a positive integer");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageLike data must be a Uint8ClampedArray");const e=16384;if(t.width>e||t.height>e)throw new Error("ImageLike dimensions must be ≤ 16384x16384")}static _convertRGBToRGBA(t){const e=t.width*t.height*4,r=new Uint8ClampedArray(e);for(let e=0;e<t.width*t.height;e++){const i=3*e,s=4*e;r[s]=t.data[i],r[s+1]=t.data[i+1],r[s+2]=t.data[i+2],r[s+3]=255}return{width:t.width,height:t.height,data:r}}static surfaceToImageLike(t){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");return{width:t.width,height:t.height,data:new Uint8ClampedArray(t.data)}}static createBlankImage(e,r,i=[0,0,0,255]){if(!Number.isInteger(e)||!Number.isInteger(r)||e<=0||r<=0)throw new Error("Width and height must be positive integers");const s=e*r,n=new Uint8ClampedArray(4*s);let a,o,h,l;if(i instanceof t){const t=i.toRGBA();a=t[0],o=t[1],h=t[2],l=t[3]}else{if(!(Array.isArray(i)&&i.length>=4))throw new Error("fillColor must be a Color instance or RGBA array");a=i[0],o=i[1],h=i[2],l=i[3]}for(let t=0;t<s;t++){const e=4*t;n[e]=a,n[e+1]=o,n[e+2]=h,n[e+3]=l}return{width:e,height:r,data:n}}static extractRegion(t,e,r,i,s){const n=m.validateAndConvert(t);if(e<0||r<0||e+i>n.width||r+s>n.height)throw new Error("Extraction region exceeds source image bounds");if(i<=0||s<=0)throw new Error("Extraction region dimensions must be positive");const a=new Uint8ClampedArray(i*s*4);for(let t=0;t<s;t++){const s=4*((r+t)*n.width+e),o=t*i*4,h=4*i;a.set(n.data.subarray(s,s+h),o)}return{width:i,height:s,data:a}}static scaleImage(t,e,r){const i=m.validateAndConvert(t);if(!Number.isInteger(e)||!Number.isInteger(r)||e<=0||r<=0)throw new Error("Target dimensions must be positive integers");const s=new Uint8ClampedArray(e*r*4),n=i.width/e,a=i.height/r;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const o=Math.floor(r*n),h=Math.floor(t*a),l=Math.min(o,i.width-1),c=4*(Math.min(h,i.height-1)*i.width+l),u=4*(t*e+r);s[u]=i.data[c],s[u+1]=i.data[c+1],s[u+2]=i.data[c+2],s[u+3]=i.data[c+3]}return{width:e,height:r,data:s}}static isImageLike(t){try{m._validateImageLike(t);const e=t.width*t.height*3,r=t.width*t.height*4;return t.data.length===e||t.data.length===r}catch(t){return!1}}static getImageInfo(t){const e=m.validateAndConvert(t),r=t.data.length===t.width*t.height*3;return{width:e.width,height:e.height,pixelCount:e.width*e.height,format:r?"RGB":"RGBA",dataSize:e.data.length,bytesPerPixel:r?3:4,memoryUsage:e.data.byteLength}}static fromCanvas(t){if(!t||"object"!=typeof t)throw new Error("Canvas must be a valid HTMLCanvasElement");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("Canvas must have numeric width and height");if(!t.getContext||"function"!=typeof t.getContext)throw new Error("Canvas must have getContext method");try{const e=t.getContext("2d").getImageData(0,0,t.width,t.height);return{width:t.width,height:t.height,data:new Uint8ClampedArray(e.data)}}catch(t){throw new Error(`Failed to extract canvas data: ${t.message}`)}}}class _{constructor(){this._cache=new Map,this._namedColors={black:{r:0,g:0,b:0},silver:{r:192,g:192,b:192},gray:{r:128,g:128,b:128},white:{r:255,g:255,b:255},maroon:{r:128,g:0,b:0},red:{r:255,g:0,b:0},purple:{r:128,g:0,b:128},fuchsia:{r:255,g:0,b:255},green:{r:0,g:128,b:0},lime:{r:0,g:255,b:0},olive:{r:128,g:128,b:0},yellow:{r:255,g:255,b:0},navy:{r:0,g:0,b:128},blue:{r:0,g:0,b:255},teal:{r:0,g:128,b:128},aqua:{r:0,g:255,b:255},aliceblue:{r:240,g:248,b:255},antiquewhite:{r:250,g:235,b:215},aquamarine:{r:127,g:255,b:212},azure:{r:240,g:255,b:255},beige:{r:245,g:245,b:220},bisque:{r:255,g:228,b:196},blanchedalmond:{r:255,g:235,b:205},blueviolet:{r:138,g:43,b:226},brown:{r:165,g:42,b:42},burlywood:{r:222,g:184,b:135},cadetblue:{r:95,g:158,b:160},chartreuse:{r:127,g:255,b:0},chocolate:{r:210,g:105,b:30},coral:{r:255,g:127,b:80},cornflowerblue:{r:100,g:149,b:237},cornsilk:{r:255,g:248,b:220},crimson:{r:220,g:20,b:60},cyan:{r:0,g:255,b:255},darkblue:{r:0,g:0,b:139},darkcyan:{r:0,g:139,b:139},darkgoldenrod:{r:184,g:134,b:11},darkgray:{r:169,g:169,b:169},darkgreen:{r:0,g:100,b:0},darkgrey:{r:169,g:169,b:169},darkkhaki:{r:189,g:183,b:107},darkmagenta:{r:139,g:0,b:139},darkolivegreen:{r:85,g:107,b:47},darkorange:{r:255,g:140,b:0},darkorchid:{r:153,g:50,b:204},darkred:{r:139,g:0,b:0},darksalmon:{r:233,g:150,b:122},darkseagreen:{r:143,g:188,b:143},darkslateblue:{r:72,g:61,b:139},darkslategray:{r:47,g:79,b:79},darkslategrey:{r:47,g:79,b:79},darkturquoise:{r:0,g:206,b:209},darkviolet:{r:148,g:0,b:211},deeppink:{r:255,g:20,b:147},deepskyblue:{r:0,g:191,b:255},dimgray:{r:105,g:105,b:105},dimgrey:{r:105,g:105,b:105},dodgerblue:{r:30,g:144,b:255},firebrick:{r:178,g:34,b:34},floralwhite:{r:255,g:250,b:240},forestgreen:{r:34,g:139,b:34},gainsboro:{r:220,g:220,b:220},ghostwhite:{r:248,g:248,b:255},gold:{r:255,g:215,b:0},goldenrod:{r:218,g:165,b:32},grey:{r:128,g:128,b:128},greenyellow:{r:173,g:255,b:47},honeydew:{r:240,g:255,b:240},hotpink:{r:255,g:105,b:180},indianred:{r:205,g:92,b:92},indigo:{r:75,g:0,b:130},ivory:{r:255,g:255,b:240},khaki:{r:240,g:230,b:140},lavender:{r:230,g:230,b:250},lavenderblush:{r:255,g:240,b:245},lawngreen:{r:124,g:252,b:0},lemonchiffon:{r:255,g:250,b:205},lightblue:{r:173,g:216,b:230},lightcoral:{r:240,g:128,b:128},lightcyan:{r:224,g:255,b:255},lightgoldenrodyellow:{r:250,g:250,b:210},lightgray:{r:211,g:211,b:211},lightgreen:{r:144,g:238,b:144},lightgrey:{r:211,g:211,b:211},lightpink:{r:255,g:182,b:193},lightsalmon:{r:255,g:160,b:122},lightseagreen:{r:32,g:178,b:170},lightskyblue:{r:135,g:206,b:250},lightslategray:{r:119,g:136,b:153},lightslategrey:{r:119,g:136,b:153},lightsteelblue:{r:176,g:196,b:222},lightyellow:{r:255,g:255,b:224},limegreen:{r:50,g:205,b:50},linen:{r:250,g:240,b:230},magenta:{r:255,g:0,b:255},mediumaquamarine:{r:102,g:205,b:170},mediumblue:{r:0,g:0,b:205},mediumorchid:{r:186,g:85,b:211},mediumpurple:{r:147,g:112,b:219},mediumseagreen:{r:60,g:179,b:113},mediumslateblue:{r:123,g:104,b:238},mediumspringgreen:{r:0,g:250,b:154},mediumturquoise:{r:72,g:209,b:204},mediumvioletred:{r:199,g:21,b:133},midnightblue:{r:25,g:25,b:112},mintcream:{r:245,g:255,b:250},mistyrose:{r:255,g:228,b:225},moccasin:{r:255,g:228,b:181},navajowhite:{r:255,g:222,b:173},oldlace:{r:253,g:245,b:230},olivedrab:{r:107,g:142,b:35},orange:{r:255,g:165,b:0},orangered:{r:255,g:69,b:0},orchid:{r:218,g:112,b:214},palegoldenrod:{r:238,g:232,b:170},palegreen:{r:152,g:251,b:152},paleturquoise:{r:175,g:238,b:238},palevioletred:{r:219,g:112,b:147},papayawhip:{r:255,g:239,b:213},peachpuff:{r:255,g:218,b:185},peru:{r:205,g:133,b:63},pink:{r:255,g:192,b:203},plum:{r:221,g:160,b:221},powderblue:{r:176,g:224,b:230},rebeccapurple:{r:102,g:51,b:153},rosybrown:{r:188,g:143,b:143},royalblue:{r:65,g:105,b:225},saddlebrown:{r:139,g:69,b:19},salmon:{r:250,g:128,b:114},sandybrown:{r:244,g:164,b:96},seagreen:{r:46,g:139,b:87},seashell:{r:255,g:245,b:238},sienna:{r:160,g:82,b:45},skyblue:{r:135,g:206,b:235},slateblue:{r:106,g:90,b:205},slategray:{r:112,g:128,b:144},slategrey:{r:112,g:128,b:144},snow:{r:255,g:250,b:250},springgreen:{r:0,g:255,b:127},steelblue:{r:70,g:130,b:180},tan:{r:210,g:180,b:140},thistle:{r:216,g:191,b:216},tomato:{r:255,g:99,b:71},turquoise:{r:64,g:224,b:208},violet:{r:238,g:130,b:238},wheat:{r:245,g:222,b:179},whitesmoke:{r:245,g:245,b:245},yellowgreen:{r:154,g:205,b:50}}}parse(t){if(this._cache.has(t))return this._cache.get(t);let e;if("string"!=typeof t)e={r:0,g:0,b:0,a:255};else{const r=t.trim().toLowerCase();if(r.startsWith("#"))e=this._parseHex(r);else if(r.startsWith("rgb"))e=this._parseRGB(r);else if(this._namedColors[r]){const t=this._namedColors[r];e={r:t.r,g:t.g,b:t.b,a:255}}else e={r:0,g:0,b:0,a:255}}return this._cache.set(t,e),e}_parseHex(t){if(3===(t=t.substring(1)).length&&(t=t.split("").map(t=>t+t).join("")),6===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:255}}if(8===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:parseInt(t.substring(6,8),16)}}return{r:0,g:0,b:0,a:255}}_parseRGB(t){const e=t.match(/rgba?\s*\(\s*([^)]+)\s*\)/);if(!e)return{r:0,g:0,b:0,a:255};const r=e[1].split(",").map(t=>t.trim());if(r.length<3)return{r:0,g:0,b:0,a:255};const i=Math.max(0,Math.min(255,parseInt(r[0])||0)),s=Math.max(0,Math.min(255,parseInt(r[1])||0)),n=Math.max(0,Math.min(255,parseInt(r[2])||0));let a=255;if(r.length>=4){const t=parseFloat(r[3]);isNaN(t)||(a=Math.max(0,Math.min(255,Math.round(255*t))))}return{r:i,g:s,b:n,a:a}}clearCache(){this._cache.clear()}}class b{constructor(){this._colorStops=[],this._sorted=!1}addColorStop(e,r){if("number"!=typeof e||!isFinite(e))throw new Error("Color stop offset must be a finite number");if(e<0||e>1)throw new Error("Color stop offset must be between 0 and 1");const i=(new _).parse(r),s=new t(i.r,i.g,i.b,i.a);this._colorStops.push({offset:e,color:s}),this._sorted=!1}_getSortedColorStops(){return this._sorted||(this._colorStops.sort((t,e)=>t.offset-e.offset),this._sorted=!0),this._colorStops}_getColorAt(e){const r=this._getSortedColorStops();if(0===r.length)return new t(0,0,0,0);if(1===r.length)return r[0].color;if(e<=r[0].offset)return r[0].color;if(e>=r[r.length-1].offset)return r[r.length-1].color;for(let i=0;i<r.length-1;i++){const s=r[i],n=r[i+1];if(e>=s.offset&&e<=n.offset){const r=n.offset-s.offset;if(0===r)return s.color;const i=(e-s.offset)/r,a=s.color.r,o=s.color.g,h=s.color.b,l=s.color.a,c=n.color.r,u=n.color.g,f=n.color.b,g=n.color.a,d=Math.round(a+(c-a)*i),m=Math.round(o+(u-o)*i),_=Math.round(h+(f-h)*i),b=Math.round(l+(g-l)*i);return new t(d,m,_,b)}}return r[0].color}getColorForPixel(t,e,r){throw new Error("getColorForPixel must be implemented by subclass")}}class p extends b{constructor(t,e,r,i){super(),this._x0=t,this._y0=e,this._x1=r,this._y1=i,this._dx=r-t,this._dy=i-e,this._lengthSquared=this._dx*this._dx+this._dy*this._dy}getColorForPixel(t,r,i){const s=i.transformPoint(new e(this._x0,this._y0)),n=i.transformPoint(new e(this._x1,this._y1)),a=n.x-s.x,o=n.y-s.y,h=a*a+o*o;if(0===h)return this._getColorAt(0);const l=((t-s.x)*a+(r-s.y)*o)/h;return this._getColorAt(l)}}class y extends b{constructor(t,e,r,i,s,n){if(super(),r<0||n<0)throw new Error("Radial gradient radii must be non-negative");if(t===i&&e===s&&r===n)throw new Error("Radial gradient circles must not be identical");this._x0=t,this._y0=e,this._r0=r,this._x1=i,this._y1=s,this._r1=n}getColorForPixel(t,r,i){const s=i.transformPoint(new e(this._x0,this._y0)),n=i.transformPoint(new e(this._x1,this._y1)),a=Math.sqrt((t-s.x)**2+(r-s.y)**2),o=Math.sqrt((t-n.x)**2+(r-n.y)**2),h=Math.sqrt((n.x-s.x)**2+(n.y-s.y)**2)+this._r1;let l;return l=a<=this._r0?0:o>=this._r1?1:(a-this._r0)/(h-this._r0),this._getColorAt(Math.max(0,Math.min(1,l)))}}class w extends b{constructor(t,e,r){super(),this._angle=t,this._x=e,this._y=r}getColorForPixel(t,r,i){const s=i.transformPoint(new e(this._x,this._y));let n=Math.atan2(r-s.y,t-s.x)-this._angle;for(;n<0;)n+=2*Math.PI;for(;n>=2*Math.PI;)n-=2*Math.PI;const a=n/(2*Math.PI);return this._getColorAt(a)}}class x{constructor(t,e="repeat"){this._imageData=m.validateAndConvert(t);const r=["repeat","repeat-x","repeat-y","no-repeat"];if(!r.includes(e))throw new Error(`Invalid repetition mode: ${e}. Must be one of: ${r.join(", ")}`);this._repetition=e,this._patternTransform=new i,Object.freeze(this)}setTransform(t){if(t instanceof i){const e=Object.create(Object.getPrototypeOf(this));return e._imageData=this._imageData,e._repetition=this._repetition,e._patternTransform=t,Object.freeze(e),e}if(t&&"number"==typeof t.a){const e=new i([t.a,t.b,t.c,t.d,t.e,t.f]);return this.setTransform(e)}throw new Error("Pattern transform must be a Transform2D or DOMMatrix-like object")}getColorForPixel(r,i,s){try{const t=s.multiply(this._patternTransform),n=t.invert().transformPoint(new e(r,i));return this._samplePattern(n.x,n.y)}catch(e){return new t(0,0,0,0)}}_samplePattern(e,r){const i=this._imageData.width,s=this._imageData.height;let n,a;switch(this._repetition){case"repeat":n=this._repeatCoordinate(e,i),a=this._repeatCoordinate(r,s);break;case"repeat-x":if(n=this._repeatCoordinate(e,i),a=r,r<0||r>=s)return new t(0,0,0,0);break;case"repeat-y":if(n=e,a=this._repeatCoordinate(r,s),e<0||e>=i)return new t(0,0,0,0);break;case"no-repeat":if(n=e,a=r,e<0||e>=i||r<0||r>=s)return new t(0,0,0,0)}const o=Math.floor(n),h=Math.floor(a),l=Math.max(0,Math.min(i-1,o)),c=4*(Math.max(0,Math.min(s-1,h))*i+l),u=this._imageData.data[c],f=this._imageData.data[c+1],g=this._imageData.data[c+2],d=this._imageData.data[c+3];return new t(u,f,g,d)}_repeatCoordinate(t,e){if(0===e)return 0;let r=t%e;return r<0&&(r+=e),r}getDimensions(){return{width:this._imageData.width,height:this._imageData.height}}getRepetition(){return this._repetition}getTransform(){return this._patternTransform}static fromSurface(t,e="repeat"){const r=m.surfaceToImageLike(t);return new x(r,e)}static createSolid(t,e,r,i="repeat"){const s=m.createBlankImage(t,e,r);return new x(s,i)}}class M{constructor(t){if(!t||"object"!=typeof t)throw new Error("Rasterizer requires a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");this._surface=t,this._currentOp=null}get surface(){return this._surface}get currentOp(){return this._currentOp}beginOp(t={}){this._validateParams(t),this._currentOp={composite:t.composite||"source-over",globalAlpha:void 0!==t.globalAlpha?t.globalAlpha:1,transform:t.transform||new i,clipMask:t.clipMask||null,fillStyle:t.fillStyle||null,strokeStyle:t.strokeStyle||null,sourceMask:null},this._requiresCanvasWideCompositing(this._currentOp.composite)&&(this._currentOp.sourceMask=new d(this._surface.width,this._surface.height))}endOp(){this._currentOp=null}_validateParams(t){if(void 0!==t.globalAlpha&&("number"!=typeof t.globalAlpha||t.globalAlpha<0||t.globalAlpha>1))throw new Error("globalAlpha must be a number between 0 and 1");if(t.composite&&!a.isSupported(t.composite))throw new Error(`Invalid composite operation. Supported: ${a.getSupportedOperations().join(", ")}`);if(t.transform&&!(t.transform instanceof i))throw new Error("transform must be a Transform2D instance")}_requireActiveOp(){if(!this._currentOp)throw new Error("Must call beginOp() before drawing operations")}_requiresCanvasWideCompositing(t){return["destination-atop","destination-in","source-in","source-out","copy"].includes(t)}_isPixelClipped(t,e){return!!this._currentOp?.clipMask&&this._currentOp.clipMask.isPixelClipped(t,e)}fillRect(e,r,i,n,a){if(this._requireActiveOp(),"number"!=typeof e||"number"!=typeof r||"number"!=typeof i||"number"!=typeof n)throw new Error("Rectangle coordinates must be numbers");if(i<0||n<0)throw new Error("Rectangle dimensions must be non-negative");if(0===i||0===n)return;if(this._currentOp.clipMask||this._requiresCanvasWideCompositing(this._currentOp.composite)){const o=new s;o.rect(e,r,i,n);const h=this._currentOp.fillStyle;return a&&Array.isArray(a)&&(this._currentOp.fillStyle=new t(a[0],a[1],a[2],a[3])),this.fill(o,"nonzero"),void(a&&Array.isArray(a)&&(this._currentOp.fillStyle=h))}const o=this._currentOp.transform,h=o.transformPoint({x:e,y:r}),l=o.transformPoint({x:e+i,y:r}),u=o.transformPoint({x:e,y:r+n}),f=o.transformPoint({x:e+i,y:r+n}),g=Math.max(0,Math.floor(Math.min(h.x,l.x,u.x,f.x))),d=Math.min(this._surface.width-1,Math.floor(Math.max(h.x,l.x,u.x,f.x)-1)),m=Math.max(0,Math.floor(Math.min(h.y,l.y,u.y,f.y))),_=Math.min(this._surface.height-1,Math.floor(Math.max(h.y,l.y,u.y,f.y)-1));if(0===this._currentOp.transform.b&&0===this._currentOp.transform.c&&(a instanceof t||Array.isArray(a)))this._fillAxisAlignedRect(g,m,d-g+1,_-m+1,a);else{const s=[{x:e,y:r},{x:e+i,y:r},{x:e+i,y:r+n},{x:e,y:r+n}],o=Array.isArray(a)?new t(a[0],a[1],a[2],a[3]):a;c.fillPolygons(this._surface,[s],o,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite)}}_fillAxisAlignedRect(e,r,i,s,n){const o=this._surface,h=this._currentOp.globalAlpha,l=(Array.isArray(n)?new t(n[0],n[1],n[2],n[3]):n).withGlobalAlpha(h),c=l.r,u=l.g,f=l.b,g=l.a;for(let t=r;t<r+s;t++)if(!(t<0||t>=o.height))for(let r=e;r<e+i;r++){if(r<0||r>=o.width)continue;if(this._currentOp.clipMask&&this._isPixelClipped(r,t))continue;const e=t*o.stride+4*r,i=o.data[e],s=o.data[e+1],n=o.data[e+2],h=o.data[e+3],l=a.blendPixel(this._currentOp.composite,c,u,f,g,i,s,n,h);o.data[e]=l.r,o.data[e+1]=l.g,o.data[e+2]=l.b,o.data[e+3]=l.a}}_performCanvasWideCompositing(e,r=1,i=1){if(!this._currentOp||!this._currentOp.sourceMask)throw new Error("Canvas-wide compositing requires active operation with source mask");const s=this._surface,n=this._currentOp.sourceMask,o=this._currentOp.composite,h=this._currentOp.transform,l=this._currentOp.clipMask,u=n.getIterationBounds(l,!0);if(!u.isEmpty)for(let f=u.minY;f<=u.maxY;f++)for(let g=u.minX;g<=u.maxX;g++){if(l&&l.isPixelClipped(g,f))continue;let u;u=(n.getPixel(g,f)?1:0)>0?c._evaluatePaintSource(e,g,f,h,r,i):new t(0,0,0,0);const d=f*s.stride+4*g,m=s.data[d],_=s.data[d+1],b=s.data[d+2],p=s.data[d+3],y=a.blendPixel(o,u.r,u.g,u.b,u.a,m,_,b,p);s.data[d]=y.r,s.data[d+1]=y.g,s.data[d+2]=y.b,s.data[d+3]=y.a}}fill(e,r){this._requireActiveOp();const i=this._currentOp.fillStyle||new t(0,0,0,255),s=r||"nonzero",n=l.flattenPath(e);this._requiresCanvasWideCompositing(this._currentOp.composite)?(c.fillPolygons(this._surface,n,i,s,this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite,this._currentOp.sourceMask),this._performCanvasWideCompositing(i,this._currentOp.globalAlpha,1)):c.fillPolygons(this._surface,n,i,s,this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite)}stroke(e,r){this._requireActiveOp();const i=this._currentOp.strokeStyle||new t(0,0,0,255);let s=r,n=1;r.lineWidth<=1&&(n=0===r.lineWidth?1:r.lineWidth,s={...r,lineWidth:1});const a=u.generateStrokePolygons(e,s);this._requiresCanvasWideCompositing(this._currentOp.composite)?(c.fillPolygons(this._surface,a,i,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,n,this._currentOp.composite,this._currentOp.sourceMask),this._performCanvasWideCompositing(i,this._currentOp.globalAlpha,n)):c.fillPolygons(this._surface,a,i,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,n,this._currentOp.composite)}drawImage(t,e,r,i,s,n,o,h,l){this._requireActiveOp();const c=m.validateAndConvert(t);let u,f,g,d,_,b,p,y;if(3===arguments.length)u=0,f=0,g=c.width,d=c.height,_=e,b=r,p=g,y=d;else if(5===arguments.length)u=0,f=0,g=c.width,d=c.height,_=e,b=r,p=i,y=s;else{if(9!==arguments.length)throw new Error("Invalid number of arguments for drawImage");u=e,f=r,g=i,d=s,_=n,b=o,p=h,y=l}if(u<0||f<0||u+g>c.width||f+d>c.height)throw new Error("Source rectangle is outside image bounds");const w=this._currentOp.transform,x=w.transformPoint({x:_,y:b}),M=w.transformPoint({x:_+p,y:b}),P=w.transformPoint({x:_,y:b+y}),C=w.transformPoint({x:_+p,y:b+y}),S=Math.max(0,Math.floor(Math.min(x.x,M.x,P.x,C.x))),k=Math.min(this._surface.width-1,Math.ceil(Math.max(x.x,M.x,P.x,C.x))),v=Math.max(0,Math.floor(Math.min(x.y,M.y,P.y,C.y))),O=Math.min(this._surface.height-1,Math.ceil(Math.max(x.y,M.y,P.y,C.y))),E=w.invert(),A=this._currentOp.globalAlpha;for(let t=v;t<=O;t++)for(let e=S;e<=k;e++){if(this._currentOp.clipMask&&this._isPixelClipped(e,t))continue;const r=E.transformPoint({x:e,y:t});if(r.x<_||r.x>=_+p||r.y<b||r.y>=b+y)continue;const i=u+(r.x-_)/p*g,s=f+(r.y-b)/y*d,n=Math.floor(i),o=Math.floor(s);if(n<0||o<0||n>=c.width||o>=c.height)continue;const h=4*(o*c.width+n),l=c.data[h],m=c.data[h+1],w=c.data[h+2],x=c.data[h+3]/255*A,M=Math.round(255*x);if(0===M)continue;const P=t*this._surface.stride+4*e,C=this._surface.data[P],S=this._surface.data[P+1],k=this._surface.data[P+2],v=this._surface.data[P+3],O=a.blendPixel(this._currentOp.composite,l,m,w,M,C,S,k,v);this._surface.data[P]=O.r,this._surface.data[P+1]=O.g,this._surface.data[P+2]=O.b,this._surface.data[P+3]=O.a}}}class P{constructor(e){this.surface=e,this.rasterizer=new M(e),this.stateStack=[],this.globalAlpha=1,this.globalCompositeOperation="source-over",this._transform=new i,this._fillStyle=new t(0,0,0,255),this._strokeStyle=new t(0,0,0,255),this.lineWidth=1,this.lineJoin="miter",this.lineCap="butt",this.miterLimit=10,this._lineDash=[],this._originalLineDash=[],this._lineDashOffset=0,this._currentPath=new s,this._clipMask=null}get composite(){return this.globalCompositeOperation}set composite(t){this.globalCompositeOperation=t}save(){let t=null;this._clipMask&&(t=this._clipMask.clone()),this.stateStack.push({globalAlpha:this.globalAlpha,globalCompositeOperation:this.globalCompositeOperation,transform:new i([this._transform.a,this._transform.b,this._transform.c,this._transform.d,this._transform.e,this._transform.f]),fillStyle:this._fillStyle,strokeStyle:this._strokeStyle,clipMask:t,lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash.slice(),originalLineDash:this._originalLineDash.slice(),lineDashOffset:this._lineDashOffset})}restore(){if(0===this.stateStack.length)return;const t=this.stateStack.pop();this.globalAlpha=t.globalAlpha,this.globalCompositeOperation=t.globalCompositeOperation,this._transform=t.transform,this._fillStyle=t.fillStyle,this._strokeStyle=t.strokeStyle,this._clipMask=t.clipMask,this.lineWidth=t.lineWidth,this.lineJoin=t.lineJoin,this.lineCap=t.lineCap,this.miterLimit=t.miterLimit,this._lineDash=t.lineDash||[],this._originalLineDash=t.originalLineDash||[],this._lineDashOffset=t.lineDashOffset||0}transform(t,e,r,s,n,a){const o=new i([t,e,r,s,n,a]);this._transform=o.multiply(this._transform)}setTransform(t,e,r,s,n,a){this._transform=new i([t,e,r,s,n,a])}resetTransform(){this._transform=new i}translate(t,e){this._transform=(new i).translate(t,e).multiply(this._transform)}scale(t,e){this._transform=(new i).scale(t,e).multiply(this._transform)}rotate(t){this._transform=(new i).rotate(t).multiply(this._transform)}setFillStyle(e,r,i,s){1===arguments.length&&(e instanceof t||e instanceof b||e instanceof p||e instanceof y||e instanceof w||e instanceof x)?this._fillStyle=e:(s=void 0!==s?s:255,this._fillStyle=new t(e,r,i,s))}setStrokeStyle(e,r,i,s){1===arguments.length&&(e instanceof t||e instanceof b||e instanceof p||e instanceof y||e instanceof w||e instanceof x)?this._strokeStyle=e:(s=void 0!==s?s:255,this._strokeStyle=new t(e,r,i,s))}beginPath(){this._currentPath=new s}closePath(){this._currentPath.closePath()}moveTo(t,e){this._currentPath.moveTo(t,e)}lineTo(t,e){this._currentPath.lineTo(t,e)}rect(t,e,r,i){this._currentPath.rect(t,e,r,i)}arc(t,e,r,i,s,n){this._currentPath.arc(t,e,r,i,s,n)}quadraticCurveTo(t,e,r,i){this._currentPath.quadraticCurveTo(t,e,r,i)}bezierCurveTo(t,e,r,i,s,n){this._currentPath.bezierCurveTo(t,e,r,i,s,n)}fillRect(t,e,r,i){this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,fillStyle:this._fillStyle}),this.rasterizer.fillRect(t,e,r,i,this._fillStyle),this.rasterizer.endOp()}strokeRect(t,e,r,i){const n=new s;n.rect(t,e,r,i),n.closePath(),this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,strokeStyle:this._strokeStyle}),this.rasterizer.stroke(n,{lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit}),this.rasterizer.endOp()}clearRect(t,e,r,i){this._clearRectDirect(t,e,r,i)}_clearRectDirect(t,e,r,i){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("Rectangle coordinates must be numbers");if(r<0||i<0)return;if(0===r||0===i)return;const s=this.surface,n=this._transform,a=n.transformPoint({x:t,y:e}),o=n.transformPoint({x:t+r,y:e}),h=n.transformPoint({x:t,y:e+i}),l=n.transformPoint({x:t+r,y:e+i}),c=Math.floor(Math.min(a.x,o.x,h.x,l.x)),u=Math.ceil(Math.max(a.x,o.x,h.x,l.x)),f=Math.floor(Math.min(a.y,o.y,h.y,l.y)),g=Math.ceil(Math.max(a.y,o.y,h.y,l.y));if(0===n.b&&0===n.c){const a=n.e+t*n.a,o=n.f+e*n.d,h=a+r*n.a,l=o+i*n.d,c=Math.max(0,Math.floor(a)),u=Math.min(s.width-1,Math.floor(h)-1),f=Math.max(0,Math.floor(o)),g=Math.min(s.height-1,Math.floor(l)-1);for(let t=f;t<=g;t++)for(let e=c;e<=u;e++){if(this._clipMask&&this._clipMask.isPixelClipped(e,t))continue;const r=t*s.stride+4*e;s.data[r]=0,s.data[r+1]=0,s.data[r+2]=0,s.data[r+3]=0}}else{const a=n.invert();for(let n=Math.max(0,f);n<=Math.min(s.height-1,g);n++)for(let o=Math.max(0,c);o<=Math.min(s.width-1,u);o++){if(this._clipMask&&this._clipMask.isPixelClipped(o,n))continue;const h=a.transformPoint({x:o+.5,y:n+.5});if(h.x>=t&&h.x<t+r&&h.y>=e&&h.y<e+i){const t=n*s.stride+4*o;s.data[t]=0,s.data[t+1]=0,s.data[t+2]=0,s.data[t+3]=0}}}}fill(t,e){let r,i;0===arguments.length?(r=this._currentPath,i="nonzero"):1===arguments.length?"string"==typeof t?(r=this._currentPath,i=t):(r=t,i="nonzero"):(r=t,i=e),i=i||"nonzero",this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,fillStyle:this._fillStyle}),this.rasterizer.fill(r,i),this.rasterizer.endOp()}stroke(t){const e=t||this._currentPath;this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,strokeStyle:this._strokeStyle}),this.rasterizer.stroke(e,{lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash.slice(),lineDashOffset:this._lineDashOffset}),this.rasterizer.endOp()}clip(t,e){const r=t||this._currentPath,i=e||"nonzero",s=new g(this.surface.width,this.surface.height);s.clipAll();s.createPixelWriter();const n=this._fillStyle;this._fillStyle=[255,255,255,255];const a=l.flattenPath(r);this._fillPolygonsToClipBuffer(a,i,s),this._fillStyle=n,this._clipMask?this._clipMask.intersectWith(s):this._clipMask=s}_fillPolygonsToClipBuffer(t,e,r){if(0===t.length)return;const i=this.surface,s=t.map(t=>t.map(t=>this._transform.transformPoint(t)));let n=1/0,a=-1/0;for(const t of s)for(const e of t)n=Math.min(n,e.y),a=Math.max(a,e.y);n=Math.max(0,Math.floor(n)),a=Math.min(i.height-1,Math.ceil(a));for(let t=n;t<=a;t++){const i=[];for(const e of s)this._findPolygonIntersections(e,t+.5,i);i.sort((t,e)=>t.x-e.x),this._fillClipSpans(t,i,e,r)}}_findPolygonIntersections(t,e,r){for(let i=0;i<t.length;i++){const s=t[i],n=t[(i+1)%t.length];if(Math.abs(s.y-n.y)<1e-10)continue;const a=Math.min(s.y,n.y),o=Math.max(s.y,n.y);if(e>=a&&e<o){const t=(e-s.y)/(n.y-s.y),i=s.x+t*(n.x-s.x),a=n.y>s.y?1:-1;r.push({x:i,winding:a})}}}_fillClipSpans(t,e,r,i){if(0===e.length)return;let s=0,n=!1;for(let a=0;a<e.length;a++){const o=e[a],h=e[a+1];s+=o.winding;if(n="evenodd"===r?s%2!=0:0!==s,n&&h){const e=Math.max(0,Math.ceil(o.x)),r=Math.min(this.surface.width-1,Math.floor(h.x));for(let s=e;s<=r;s++)i.setPixel(s,t,!0)}}}drawImage(t,e,r,s,n,a,o,h,l){if("undefined"!=typeof console&&console.log,!t||"object"!=typeof t)throw new Error("First argument must be an ImageLike object");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("ImageLike must have numeric width and height properties");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageLike data must be a Uint8ClampedArray");this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:new i([this._transform.a,this._transform.b,this._transform.c,this._transform.d,this._transform.e,this._transform.f]),clipMask:this._clipMask}),this.rasterizer.drawImage.apply(this.rasterizer,arguments),this.rasterizer.endOp()}setLineDash(t){if(!Array.isArray(t))throw new Error("setLineDash expects an array");for(let e=0;e<t.length;e++){if("number"!=typeof t[e]||isNaN(t[e]))throw new Error("Dash segments must be numbers");if(t[e]<0)throw new Error("Dash segments must be non-negative")}this._originalLineDash=t.slice(),this._lineDash=t.slice(),this._lineDash.length%2==1&&(this._lineDash=this._lineDash.concat(this._lineDash))}getLineDash(){return this._originalLineDash.slice()}set lineDashOffset(t){"number"!=typeof t||isNaN(t)||(this._lineDashOffset=t)}get lineDashOffset(){return this._lineDashOffset}createLinearGradient(t,e,r,i){return new p(t,e,r,i)}createRadialGradient(t,e,r,i,s,n){return new y(t,e,r,i,s,n)}createConicGradient(t,e,r){return new w(t,e,r)}createPattern(t,e){return new x(t,e)}}class C{constructor(t){this._core=new P(t),this._colorParser=new _,this._fillStyle="#000000",this._strokeStyle="#000000"}_updateSurface(t){this._core=new P(t),this._applyFillStyle(),this._applyStrokeStyle()}get fillStyle(){return this._fillStyle}set fillStyle(t){this._fillStyle=t,this._applyFillStyle()}get strokeStyle(){return this._strokeStyle}set strokeStyle(t){this._strokeStyle=t,this._applyStrokeStyle()}_applyFillStyle(){if(this._fillStyle instanceof b||this._fillStyle instanceof p||this._fillStyle instanceof y||this._fillStyle instanceof w||this._fillStyle instanceof x)this._core.setFillStyle(this._fillStyle);else{const t=this._colorParser.parse(this._fillStyle);this._core.setFillStyle(t.r,t.g,t.b,t.a)}}_applyStrokeStyle(){if(this._strokeStyle instanceof b||this._strokeStyle instanceof p||this._strokeStyle instanceof y||this._strokeStyle instanceof w||this._strokeStyle instanceof x)this._core.setStrokeStyle(this._strokeStyle);else{const t=this._colorParser.parse(this._strokeStyle);this._core.setStrokeStyle(t.r,t.g,t.b,t.a)}}get globalAlpha(){return this._core.globalAlpha}set globalAlpha(t){this._core.globalAlpha=t}get globalCompositeOperation(){return this._core.globalCompositeOperation}set globalCompositeOperation(t){this._core.globalCompositeOperation=t}get lineWidth(){return this._core.lineWidth}set lineWidth(t){this._core.lineWidth=t}get lineJoin(){return this._core.lineJoin}set lineJoin(t){this._core.lineJoin=t}get lineCap(){return this._core.lineCap}set lineCap(t){this._core.lineCap=t}get miterLimit(){return this._core.miterLimit}set miterLimit(t){this._core.miterLimit=t}get lineDashOffset(){return this._core.lineDashOffset}set lineDashOffset(t){this._core.lineDashOffset=t}save(){this._core.save()}restore(){this._core.restore()}transform(t,e,r,i,s,n){this._core.transform(t,e,r,i,s,n)}setTransform(t,e,r,i,s,n){this._core.setTransform(t,e,r,i,s,n)}resetTransform(){this._core.resetTransform()}translate(t,e){this._core.translate(t,e)}scale(t,e){this._core.scale(t,e)}rotate(t){this._core.rotate(t)}beginPath(){this._core.beginPath()}closePath(){this._core.closePath()}moveTo(t,e){this._core.moveTo(t,e)}lineTo(t,e){this._core.lineTo(t,e)}rect(t,e,r,i){this._core.rect(t,e,r,i)}arc(t,e,r,i,s,n=!1){this._core.arc(t,e,r,i,s,n)}quadraticCurveTo(t,e,r,i){this._core.quadraticCurveTo(t,e,r,i)}bezierCurveTo(t,e,r,i,s,n){this._core.bezierCurveTo(t,e,r,i,s,n)}fillRect(t,e,r,i){this._core.fillRect(t,e,r,i)}strokeRect(t,e,r,i){this._core.strokeRect(t,e,r,i)}clearRect(t,e,r,i){this._core.clearRect(t,e,r,i)}fill(t,e){"string"==typeof t?this._core.fill(t):t&&t instanceof s?this._core.fill(t,e):this._core.fill()}stroke(t){t&&t instanceof s?this._core.stroke(t):this._core.stroke()}setLineDash(t){this._core.setLineDash(t)}getLineDash(){return this._core.getLineDash()}clip(t,e){"string"==typeof t?this._core.clip(t):t&&t instanceof s?this._core.clip(t,e):this._core.clip()}drawImage(t,...e){if("undefined"!=typeof console&&console.log,t&&t instanceof S)this._core.drawImage(t._imageData,...e);else if(t&&"object"==typeof t&&t.getContext&&"function"==typeof t.getContext){const r=t.getContext("2d").getImageData(0,0,t.width,t.height);this._core.drawImage(r,...e)}else t&&"object"==typeof t&&t.width&&t.height&&t.data,this._core.drawImage(t,...e)}createImageData(t,e){if("number"!=typeof t||t<=0||!Number.isInteger(t))throw new Error("Width must be a positive integer");if("number"!=typeof e||e<=0||!Number.isInteger(e))throw new Error("Height must be a positive integer");return{width:t,height:e,data:new Uint8ClampedArray(t*e*4)}}getImageData(t,e,r,i){if("number"!=typeof t||"number"!=typeof e)throw new Error("Coordinates must be numbers");if("number"!=typeof r||r<=0||!Number.isInteger(r))throw new Error("Width must be a positive integer");if("number"!=typeof i||i<=0||!Number.isInteger(i))throw new Error("Height must be a positive integer");const s=this.createImageData(r,i),n=this._core.surface;for(let a=0;a<i;a++){const i=Math.floor(e)+a,o=a;if(i>=0&&i<n.height)for(let e=0;e<r;e++){const a=Math.floor(t)+e,h=e;if(a>=0&&a<n.width){const t=i*n.stride+4*a,e=o*r*4+4*h;s.data[e]=n.data[t],s.data[e+1]=n.data[t+1],s.data[e+2]=n.data[t+2],s.data[e+3]=n.data[t+3]}}}return s}putImageData(t,e,r){if(!t||"object"!=typeof t)throw new Error("ImageData must be an object");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("ImageData must have numeric width and height");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageData data must be a Uint8ClampedArray");if("number"!=typeof e||"number"!=typeof r)throw new Error("Destination coordinates must be numbers");const i=this._core.surface;for(let s=0;s<t.height;s++){const n=Math.floor(r)+s,a=s;if(n>=0&&n<i.height)for(let r=0;r<t.width;r++){const s=Math.floor(e)+r,o=r;if(s>=0&&s<i.width){const e=n*i.stride+4*s,r=a*t.width*4+4*o;i.data[e]=t.data[r],i.data[e+1]=t.data[r+1],i.data[e+2]=t.data[r+2],i.data[e+3]=t.data[r+3]}}}}createLinearGradient(t,e,r,i){return this._core.createLinearGradient(t,e,r,i)}createRadialGradient(t,e,r,i,s,n){return this._core.createRadialGradient(t,e,r,i,s,n)}createConicGradient(t,e,r){return this._core.createConicGradient(t,e,r)}createPattern(t,e){return this._core.createPattern(t,e)}get _coreContext(){return this._core}}class S{constructor(t=300,e=150){this._width=t,this._height=e,this._surface=new n(t,e),this._context=null}get width(){return this._width}set width(t){const e=Math.max(1,Math.floor(t));e!==this._width&&(this._width=e,this._recreateSurface())}get height(){return this._height}set height(t){const e=Math.max(1,Math.floor(t));e!==this._height&&(this._height=e,this._recreateSurface())}getContext(t){if("2d"!==t)throw new Error("SWCanvas only supports 2d context");return this._context||(this._context=new C(this._surface)),this._context}_recreateSurface(){this._surface=new n(this._width,this._height),this._context&&this._context._updateSurface(this._surface)}get _coreSurface(){return this._surface}get _imageData(){return{width:this._width,height:this._height,data:this._surface.data}}get data(){return this._surface.data}toString(){return`[object SWCanvasElement(${this._width}x${this._height})]`}}function k(t=300,e=150){return new S(t,e)}function v(t,e){return new n(t,e)}function O(t,e){if("number"!=typeof t||t<=0||!Number.isInteger(t))throw new Error("Width must be a positive integer");if("number"!=typeof e||e<=0||!Number.isInteger(e))throw new Error("Height must be a positive integer");return{width:t,height:e,data:new Uint8ClampedArray(t*e*4)}}"undefined"!=typeof window?window.SWCanvas={createCanvas:k,createImageData:O,Core:{Surface:v,Context2D:P,Transform2D:i,Path2D:s,Color:t,Point:e,Rectangle:r,BitmapEncoder:h,BitmapEncodingOptions:o,BitBuffer:f,ClipMask:g,SourceMask:d,ImageProcessor:m,CompositeOperations:a,Rasterizer:M,PathFlattener:l,PolygonFiller:c,StrokeGenerator:u,Gradient:b,LinearGradient:p,RadialGradient:y,ConicGradient:w,Pattern:x}}:"undefined"!=typeof module&&module.exports&&(module.exports={createCanvas:k,createImageData:O,Core:{Surface:v,Context2D:P,Transform2D:i,Path2D:s,Color:t,Point:e,Rectangle:r,BitmapEncoder:h,BitmapEncodingOptions:o,BitBuffer:f,ClipMask:g,SourceMask:d,ImageProcessor:m,CompositeOperations:a,Rasterizer:M,PathFlattener:l,PolygonFiller:c,StrokeGenerator:u,Gradient:b,LinearGradient:p,RadialGradient:y,ConicGradient:w,Pattern:x}})}();
//# sourceMappingURL=swcanvas.min.js.map