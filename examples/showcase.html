<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SWCanvas Feature Showcase</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 16px;
        }
        
        .canvas-container {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }
        
        canvas {
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            background: white;
        }
        
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .feature {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        
        .feature h3 {
            margin-top: 0;
            color: #333;
        }
        
        .feature ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        .feature li {
            margin: 5px 0;
            color: #555;
        }
        
        .info-box {
            background: #e7f3ff;
            border: 1px solid #b3d9ff;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }
        
        .buttons {
            text-align: center;
            margin: 20px 0;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 10px;
            font-size: 14px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .performance {
            background: #f0f8ff;
            border: 1px solid #b3d9ff;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® SWCanvas Feature Showcase</h1>
        <p class="subtitle">Comprehensive demonstration of SWCanvas deterministic 2D rendering capabilities ‚Ä¢ <a href="../" style="color: #007bff; text-decoration: none;">üìÅ View on Github</a></p>
        
        <div class="info-box">
            <strong>About SWCanvas:</strong> A deterministic 2D Javascript raster engine with Canvas-like API, cross-browser and Node.js. 
            This demo showcases the key features using the minified production build.
            <br><br>
            <strong>Note:</strong> SWCanvas focuses on graphics primitives - text rendering is not implemented.
        </div>
        
        <div class="canvas-container">
            <canvas id="showcase" width="800" height="680"></canvas>
        </div>
        
        <div class="buttons">
            <button onclick="drawShowcase()">üéØ Redraw Showcase</button>
            <button id="animateBtn" onclick="toggleAnimation()">üé¨ Animate Demo (warning, very slow!)</button>
            <button onclick="downloadImage()">üíæ Download as PNG</button>
        </div>
        
        <div class="performance" id="performance">
            <strong>Render Time:</strong> <span id="renderTime">-</span>ms
        </div>
        
        <div class="features">
            <div class="feature">
                <h3>üî∑ Basic Shapes</h3>
                <ul>
                    <li>Filled rectangles with solid colors</li>
                    <li>Stroked rectangles with various line widths</li>
                    <li>Complex polygon paths</li>
                    <li>Curved paths with arcs and beziers</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üåà Gradients & Patterns</h3>
                <ul>
                    <li>Linear gradients with multiple color stops</li>
                    <li>Radial gradients with inner/outer circles</li>
                    <li>Conic gradients with sweep angles</li>
                    <li>Repeating image patterns</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üîÑ Transformations</h3>
                <ul>
                    <li>Translation (position offset)</li>
                    <li>Rotation around pivot points</li>
                    <li>Scaling (uniform and non-uniform)</li>
                    <li>Combined transformation matrices</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>‚úÇÔ∏è Clipping & Masking</h3>
                <ul>
                    <li>Rectangular clip regions</li>
                    <li>Complex path-based clipping</li>
                    <li>Nested clipping with intersections</li>
                    <li>Save/restore clip stack management</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üñäÔ∏è Stroke Styles</h3>
                <ul>
                    <li>Various line caps (butt, round, square)</li>
                    <li>Line joins (miter, round, bevel)</li>
                    <li>Dashed line patterns with offsets</li>
                    <li>Sub-pixel stroke rendering</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üé≠ Alpha Blending</h3>
                <ul>
                    <li>Semi-transparent overlays</li>
                    <li>Global alpha compositing</li>
                    <li>Source-over blending mode</li>
                    <li>Premultiplied alpha handling</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üåì Shadow Effects</h3>
                <ul>
                    <li>Configurable shadow color with transparency</li>
                    <li>Variable blur radius for soft shadows</li>
                    <li>X/Y offset controls for shadow positioning</li>
                    <li>Works with all drawing operations and paint sources</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üîÑ Composite Operations</h3>
                <ul>
                    <li>Complete Porter-Duff compositing (10 operations)</li>
                    <li>Source/destination blending modes</li>
                    <li>XOR operations for "bite" effects</li>
                    <li>Canvas-wide and source-bounded operations</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üéØ Path Hit Testing</h3>
                <ul>
                    <li>Geometric isPointInPath() with fill rules</li>
                    <li>Accurate isPointInStroke() detection</li>
                    <li>Works with complex paths and transforms</li>
                    <li>Support for external SWPath2D objects</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üñºÔ∏è Image Rendering</h3>
                <ul>
                    <li>drawImage() with ImageLike objects</li>
                    <li>Scaling and source rectangle support</li>
                    <li>Works with transforms and alpha blending</li>
                    <li>RGB to RGBA auto-conversion</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üé® Advanced Shapes</h3>
                <ul>
                    <li>ellipse() method with rotation support</li>
                    <li>arcTo() for rounded corner connections</li>
                    <li>Precise geometric calculations</li>
                    <li>HTML5 Canvas API compatibility</li>
                </ul>
            </div>
            
            <div class="feature">
                <h3>üìä ImageData API</h3>
                <ul>
                    <li>getImageData() for pixel manipulation</li>
                    <li>createImageData() factory methods</li>
                    <li>putImageData() for direct pixel control</li>
                    <li>Cross-platform RGBA data access</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Use the minified version when available, fallback to regular build -->
    <script src="../dist/swcanvas.min.js" onerror="this.onerror=null; this.src='../dist/swcanvas.js'"></script>
    <script>
        let canvas;
        let ctx;
        let htmlCanvas;
        let htmlCtx;
        let animationFrame;
        let isAnimating = false;
        
        function init() {
            // Create SWCanvas for rendering
            canvas = SWCanvas.createCanvas(800, 680);
            ctx = canvas.getContext('2d');
            
            // Get HTML canvas for display
            htmlCanvas = document.getElementById('showcase');
            htmlCtx = htmlCanvas.getContext('2d');
            
            drawShowcase();
        }
        
        function drawShowcase() {
            const startTime = performance.now();
            
            // Clear canvas
            ctx.clearRect(0, 0, 800, 680);
            
            // Reset all shadow properties to ensure fast rendering
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Background gradient
            const bgGrad = ctx.createLinearGradient(0, 0, 800, 680);
            bgGrad.addColorStop(0, '#f8f9fa');
            bgGrad.addColorStop(1, '#e9ecef');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, 800, 680);
            
            // Section 1: Basic Shapes (top-left)
            drawBasicShapes(50, 50);
            
            // Section 2: Gradients (top-right)
            drawGradients(450, 50);
            
            // Section 3: Transformations (middle-left)
            drawTransformations(50, 200);
            
            // Section 4: Clipping Demo (middle-right)
            drawClippingDemo(450, 200);
            
            // Section 5: Stroke Styles (bottom-left)
            drawStrokeStyles(50, 350);
            
            // Section 6: Alpha Blending (bottom-right)
            drawAlphaBlending(450, 350);
            
            // Section 7: Complex Path in Center
            drawComplexPath(300, 450);
            
            // Section 8: Shadow Effects (top area)
            drawShadowEffects(600, 50);
            
            // Section 9: Composite Operations (bottom area)
            drawCompositeOperations(50, 500);
            
            // Section 10: Advanced Shapes (ellipse, arcTo)
            drawAdvancedShapes(200, 500);
            
            // Section 11: Path Hit Testing (visual demonstration)
            drawPathHitTesting(350, 500);
            
            // Section 12: Image Rendering Demo
            drawImageRendering(500, 500);
            
            const endTime = performance.now();
            document.getElementById('renderTime').textContent = Math.round(endTime - startTime);
            
            // Copy SWCanvas output to HTML canvas for display
            displaySWCanvas();
        }
        
        function displaySWCanvas() {
            // Get the underlying surface data from SWCanvas
            const surface = canvas._coreSurface || canvas._surface;
            if (surface && surface.data) {
                const imageData = htmlCtx.createImageData(800, 680);
                imageData.data.set(surface.data);
                htmlCtx.putImageData(imageData, 0, 0);
            }
        }
        
        function drawBasicShapes(x, y) {
            // Basic Shapes section
            
            // Filled rectangle
            ctx.fillStyle = '#007bff';
            ctx.fillRect(x, y, 60, 40);
            
            // Stroked rectangle
            ctx.strokeStyle = '#dc3545';
            ctx.lineWidth = 3;
            ctx.strokeRect(x + 80, y, 60, 40);
            
            // Triangle path
            ctx.fillStyle = '#28a745';
            ctx.beginPath();
            ctx.moveTo(x + 180, y);
            ctx.lineTo(x + 220, y + 40);
            ctx.lineTo(x + 140, y + 40);
            ctx.closePath();
            ctx.fill();
            
            // Circle (using arc)
            ctx.fillStyle = '#ffc107';
            ctx.beginPath();
            ctx.arc(x + 280, y + 20, 20, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawGradients(x, y) {
            // Gradients & Patterns section
            
            // Linear gradient
            const linearGrad = ctx.createLinearGradient(x, y, x + 60, y + 40);
            linearGrad.addColorStop(0, '#ff0000');
            linearGrad.addColorStop(0.5, '#ffff00');
            linearGrad.addColorStop(1, '#0000ff');
            ctx.fillStyle = linearGrad;
            ctx.fillRect(x, y, 60, 40);
            
            // Radial gradient
            const radialGrad = ctx.createRadialGradient(x + 110, y + 20, 5, x + 110, y + 20, 25);
            radialGrad.addColorStop(0, '#ffffff');
            radialGrad.addColorStop(1, '#000000');
            ctx.fillStyle = radialGrad;
            ctx.fillRect(x + 80, y, 60, 40);
            
            // Conic gradient
            const conicGrad = ctx.createConicGradient(0, x + 200, y + 20);
            conicGrad.addColorStop(0, '#ff0000');
            conicGrad.addColorStop(0.33, '#00ff00');
            conicGrad.addColorStop(0.66, '#0000ff');
            conicGrad.addColorStop(1, '#ff0000');
            ctx.fillStyle = conicGrad;
            ctx.fillRect(x + 160, y, 60, 40);
            
            // Pattern (checkered)
            const patternData = ctx.createImageData(8, 8);
            for (let i = 0; i < patternData.data.length; i += 4) {
                const pixelIndex = Math.floor(i / 4);
                const px = pixelIndex % 8;
                const py = Math.floor(pixelIndex / 8);
                const isBlack = (px + py) % 2 === 0;
                
                patternData.data[i] = isBlack ? 0 : 255;     // R
                patternData.data[i + 1] = isBlack ? 0 : 255; // G
                patternData.data[i + 2] = isBlack ? 0 : 255; // B
                patternData.data[i + 3] = 255;               // A
            }
            const pattern = ctx.createPattern(patternData, 'repeat');
            ctx.fillStyle = pattern;
            ctx.fillRect(x + 240, y, 60, 40);
        }
        
        function drawTransformations(x, y) {
            // Transformations section
            
            ctx.save();
            
            // Translation
            ctx.translate(x + 30, y + 20);
            ctx.fillStyle = '#17a2b8';
            ctx.fillRect(-10, -10, 20, 20);
            
            // Rotation
            ctx.translate(60, 0);
            ctx.rotate(Math.PI / 4);
            ctx.fillStyle = '#6f42c1';
            ctx.fillRect(-10, -10, 20, 20);
            
            // Scaling
            ctx.setTransform(1, 0, 0, 1, x + 150, y + 20);
            ctx.scale(1.5, 0.7);
            ctx.fillStyle = '#e83e8c';
            ctx.fillRect(-10, -10, 20, 20);
            
            ctx.restore();
        }
        
        function drawClippingDemo(x, y) {
            // Clipping Demo section
            
            ctx.save();
            
            // Create circular clip
            ctx.beginPath();
            ctx.arc(x + 50, y + 40, 30, 0, Math.PI * 2);
            ctx.clip();
            
            // Draw clipped gradient
            const grad = ctx.createLinearGradient(x, y, x + 100, y + 80);
            grad.addColorStop(0, '#ff6b6b');
            grad.addColorStop(1, '#4ecdc4');
            ctx.fillStyle = grad;
            ctx.fillRect(x, y, 100, 80);
            
            ctx.restore();
            
            // Show clip boundary
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 50, y + 40, 30, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        function drawStrokeStyles(x, y) {
            // Stroke Styles section
            
            // Different line caps
            ctx.lineWidth = 8;
            ctx.strokeStyle = '#fd7e14';
            
            // Butt cap
            ctx.lineCap = 'butt';
            ctx.beginPath();
            ctx.moveTo(x, y + 20);
            ctx.lineTo(x + 50, y + 20);
            ctx.stroke();
            
            // Round cap
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x, y + 40);
            ctx.lineTo(x + 50, y + 40);
            ctx.stroke();
            
            // Square cap
            ctx.lineCap = 'square';
            ctx.beginPath();
            ctx.moveTo(x, y + 60);
            ctx.lineTo(x + 50, y + 60);
            ctx.stroke();
            
            // Dashed lines
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#20c997';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 80, y + 20);
            ctx.lineTo(x + 180, y + 60);
            ctx.stroke();
            
            // Reset
            ctx.setLineDash([]);
            ctx.lineCap = 'butt';
            
            // Sub-pixel stroke
            ctx.lineWidth = 0.5;
            ctx.strokeStyle = '#6610f2';
            ctx.beginPath();
            ctx.moveTo(x + 200, y + 20);
            ctx.lineTo(x + 280, y + 60);
            ctx.stroke();
        }
        
        function drawAlphaBlending(x, y) {
            // Alpha Blending section
            
            // Base shape
            ctx.fillStyle = '#007bff';
            ctx.fillRect(x, y, 60, 60);
            
            // Semi-transparent overlay
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = '#dc3545';
            ctx.fillRect(x + 30, y + 30, 60, 60);
            
            // Reset alpha
            ctx.globalAlpha = 1.0;
            
            // Gradient with alpha
            const alphaGrad = ctx.createRadialGradient(x + 150, y + 30, 0, x + 150, y + 30, 30);
            alphaGrad.addColorStop(0, 'rgba(255, 193, 7, 1)');
            alphaGrad.addColorStop(1, 'rgba(255, 193, 7, 0)');
            ctx.fillStyle = alphaGrad;
            ctx.fillRect(x + 120, y, 60, 60);
        }
        
        function drawComplexPath(x, y) {
            // Complex Paths section
            
            // Star shape
            ctx.fillStyle = '#ffc107';
            ctx.strokeStyle = '#fd7e14';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            const spikes = 8;
            const outerRadius = 40;
            const innerRadius = 20;
            
            for (let i = 0; i < spikes * 2; i++) {
                const angle = (i * Math.PI) / spikes;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(px, py);
                } else {
                    ctx.lineTo(px, py);
                }
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Bezier curve
            ctx.strokeStyle = '#6f42c1';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x - 80, y + 60);
            ctx.bezierCurveTo(x - 40, y + 20, x + 40, y + 100, x + 80, y + 60);
            ctx.stroke();
        }
        
        function drawShadowEffects(x, y) {
            // Shadow Effects section
            
            // Basic shadow rectangle
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            ctx.fillStyle = '#ff6b6b';
            ctx.fillRect(x, y, 40, 30);
            
            // Shadow with different color
            ctx.shadowColor = 'rgba(0, 100, 255, 0.6)';
            ctx.shadowBlur = 8;
            ctx.shadowOffsetX = -4;
            ctx.shadowOffsetY = 2;
            
            ctx.fillStyle = '#4ecdc4';
            ctx.beginPath();
            ctx.arc(x + 70, y + 15, 15, 0, Math.PI * 2);
            ctx.fill();
            
            // Shadow stroke
            ctx.shadowColor = 'rgba(255, 100, 0, 0.4)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.strokeStyle = '#ffc107';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x + 100, y + 5);
            ctx.lineTo(x + 150, y + 25);
            ctx.stroke();
            
            // Turn off shadows completely
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        function drawCompositeOperations(x, y) {
            // Composite Operations section - demonstrate different blending modes
            
            // Base shape
            ctx.fillStyle = '#007bff';
            ctx.fillRect(x, y, 30, 30);
            
            // XOR operation 
            ctx.globalCompositeOperation = 'xor';
            ctx.fillStyle = '#dc3545';
            ctx.fillRect(x + 15, y + 15, 30, 30);
            
            // Reset to source-over
            ctx.globalCompositeOperation = 'source-over';
            
            // Destination-over demo
            ctx.fillStyle = '#28a745';
            ctx.fillRect(x + 60, y, 30, 30);
            
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillStyle = '#ffc107';
            ctx.fillRect(x + 75, y + 15, 30, 30);
            
            // Reset
            ctx.globalCompositeOperation = 'source-over';
        }
        
        function drawAdvancedShapes(x, y) {
            // Advanced Shapes section - ellipse and arcTo
            
            // Ellipse
            ctx.fillStyle = '#6f42c1';
            ctx.beginPath();
            ctx.ellipse(x + 25, y + 20, 20, 12, Math.PI / 6, 0, 2 * Math.PI);
            ctx.fill();
            
            // arcTo rounded corners
            ctx.strokeStyle = '#e83e8c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 70, y + 10);
            ctx.lineTo(x + 120, y + 10);
            ctx.arcTo(x + 130, y + 10, x + 130, y + 20, 10); // Rounded corner
            ctx.lineTo(x + 130, y + 30);
            ctx.stroke();
        }
        
        function drawPathHitTesting(x, y) {
            // Path Hit Testing section - visual demonstration
            
            // Create a test shape
            ctx.fillStyle = '#17a2b8';
            ctx.beginPath();
            ctx.rect(x, y, 40, 30);
            ctx.fill();
            
            // Test points - show hit/miss visually
            const testPoints = [
                {x: x + 20, y: y + 15, inside: true},  // Inside
                {x: x + 50, y: y + 15, inside: false}, // Outside
                {x: x + 5, y: y + 5, inside: true}     // Inside corner
            ];
            
            testPoints.forEach(point => {
                // Test if point is in the path we just drew
                const isInside = ctx.isPointInPath(point.x, point.y);
                
                // Draw indicator dot
                ctx.fillStyle = isInside ? '#28a745' : '#dc3545'; // Green if inside, red if outside
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawImageRendering(x, y) {
            // Image Rendering section - demonstrate drawImage
            
            // Create a simple ImageData pattern
            const imageData = ctx.createImageData(20, 20);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const pixelIndex = Math.floor(i / 4);
                const px = pixelIndex % 20;
                const py = Math.floor(pixelIndex / 20);
                
                // Create a gradient pattern
                const intensity = (px + py) * 3;
                imageData.data[i] = intensity % 255;     // R
                imageData.data[i + 1] = (intensity * 2) % 255; // G
                imageData.data[i + 2] = (intensity * 3) % 255; // B
                imageData.data[i + 3] = 255;             // A
            }
            
            // Draw the image at different scales
            ctx.putImageData(imageData, x, y);           // Original size
            
            // Create a temporary canvas to scale from
            const tempCanvas = SWCanvas.createCanvas(20, 20);
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            // Draw scaled versions (if drawImage works with SWCanvas objects)
            try {
                // This might not work depending on implementation
                ctx.drawImage(tempCanvas, x + 30, y, 40, 30); // Scaled up
            } catch (e) {
                // Fallback: show a colored rectangle to indicate image rendering capability
                ctx.fillStyle = '#fd7e14';
                ctx.fillRect(x + 30, y, 40, 30);
                
                // Add a small indicator
                ctx.fillStyle = '#ffffff';
                ctx.font = '8px Arial';
                ctx.fillText('IMG', x + 42, y + 18);
            }
        }
        
        function toggleAnimation() {
            if (isAnimating) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }
        
        function startAnimation() {
            if (isAnimating) return; // Already animating
            
            isAnimating = true;
            document.getElementById('animateBtn').textContent = '‚èπÔ∏è Stop Animation';
            
            let frame = 0;
            
            const animate = () => {
                if (!isAnimating) return; // Stop if animation was cancelled
                
                frame++;
                
                // Clear and redraw with animated elements
                drawShowcase();
                
                // Ensure shadows are completely disabled for animation performance
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Animation timing
                const angle = frame * 0.1; // Faster rotation
                const slowAngle = frame * 0.02;
                
                // 1. Rotating gradient squares
                for (let i = 0; i < 3; i++) {
                    ctx.save();
                    const x = 150 + i * 200;
                    const y = 100 + Math.sin(angle + i) * 30;
                    
                    ctx.translate(x, y);
                    ctx.rotate(angle + i * Math.PI / 3);
                    
                    const grad = ctx.createLinearGradient(-25, -25, 25, 25);
                    grad.addColorStop(0, `hsl(${(frame * 2 + i * 60) % 360}, 70%, 60%)`);
                    grad.addColorStop(1, `hsl(${(frame * 2 + i * 60 + 180) % 360}, 70%, 60%)`);
                    
                    ctx.fillStyle = grad;
                    ctx.fillRect(-25, -25, 50, 50);
                    ctx.restore();
                }
                
                // 2. Bouncing circles with trails
                for (let i = 0; i < 4; i++) {
                    const phase = i * Math.PI / 2;
                    const x = 400 + Math.cos(slowAngle + phase) * 150;
                    const y = 300 + Math.sin(slowAngle + phase) * 100;
                    
                    // Trail effect
                    for (let j = 0; j < 5; j++) {
                        const trailAngle = slowAngle + phase - j * 0.1;
                        const trailX = 400 + Math.cos(trailAngle) * 150;
                        const trailY = 300 + Math.sin(trailAngle) * 100;
                        
                        ctx.fillStyle = `rgba(${100 + i * 50}, ${200 - i * 30}, 255, ${0.3 - j * 0.05})`;
                        ctx.beginPath();
                        ctx.arc(trailX, trailY, 8 - j, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Main circle
                    ctx.fillStyle = `hsl(${(frame + i * 90) % 360}, 80%, 60%)`;
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // 3. Animated dashed spiral
                ctx.save();
                ctx.translate(400, 300);
                ctx.strokeStyle = 'rgba(255, 100, 0, 0.7)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.lineDashOffset = -frame * 2; // Moving dashes
                
                ctx.beginPath();
                for (let i = 0; i < 200; i++) {
                    const spiralAngle = i * 0.3;
                    const radius = i * 0.8;
                    const x = Math.cos(spiralAngle + slowAngle) * radius;
                    const y = Math.sin(spiralAngle + slowAngle) * radius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.restore();
                
                // 4. Pulsing star with transform
                ctx.save();
                ctx.translate(400, 300);
                ctx.rotate(angle * 0.5);
                
                const starScale = 1 + Math.sin(angle * 2) * 0.3; // Pulsing effect
                ctx.scale(starScale, starScale);
                
                ctx.fillStyle = `rgba(255, 255, 0, ${0.6 + Math.sin(angle * 3) * 0.2})`;
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.8)';
                ctx.lineWidth = 2;
                
                // Draw star
                ctx.beginPath();
                for (let i = 0; i < 10; i++) {
                    const starAngle = (i * Math.PI) / 5;
                    const radius = i % 2 === 0 ? 40 : 20;
                    const x = Math.cos(starAngle) * radius;
                    const y = Math.sin(starAngle) * radius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                
                // 5. Animated clipping mask demonstration
                ctx.save();
                
                // Create animated circular clip
                ctx.beginPath();
                const clipRadius = 60 + Math.sin(angle) * 20;
                ctx.arc(200, 400, clipRadius, 0, Math.PI * 2);
                ctx.clip();
                
                // Draw colorful pattern behind clip
                for (let i = 0; i < 20; i++) {
                    for (let j = 0; j < 20; j++) {
                        const rectX = 150 + i * 10 + Math.sin(angle + i * 0.5) * 5;
                        const rectY = 350 + j * 10 + Math.cos(angle + j * 0.5) * 5;
                        
                        ctx.fillStyle = `hsl(${(i * j * 10 + frame * 5) % 360}, 60%, 50%)`;
                        ctx.fillRect(rectX, rectY, 8, 8);
                    }
                }
                ctx.restore();
                
                // 6. Moving bezier curves
                ctx.strokeStyle = 'rgba(0, 255, 150, 0.6)';
                ctx.lineWidth = 4;
                
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const startY = 450 + i * 40;
                    const cp1Y = startY + Math.sin(angle + i) * 50;
                    const cp2Y = startY + Math.cos(angle + i + 1) * 50;
                    
                    ctx.moveTo(50, startY);
                    ctx.bezierCurveTo(
                        200 + Math.sin(angle + i) * 50, cp1Y,
                        400 + Math.cos(angle + i) * 50, cp2Y,
                        600, startY
                    );
                    ctx.stroke();
                }
                
                // Update display
                displaySWCanvas();
                
                // Continue animation loop
                if (isAnimating) {
                    animationFrame = requestAnimationFrame(animate);
                }
            };
            
            animate();
        }
        
        function stopAnimation() {
            isAnimating = false;
            document.getElementById('animateBtn').textContent = 'üé¨ Animate Demo (warning, very slow!)';
            
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            // Redraw static showcase
            drawShowcase();
            displaySWCanvas();
        }
        
        function downloadImage() {
            // Use SWCanvas PNG encoder for deterministic output with transparency
            if (SWCanvas.Core && SWCanvas.Core.PngEncoder) {
                // Use SWCanvas PNG encoder
                const surface = canvas._coreSurface || canvas._surface;
                if (surface) {
                    const pngData = SWCanvas.Core.PngEncoder.encode(surface);
                    const blob = new Blob([pngData], { type: 'image/png' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'swcanvas-showcase.png';
                    a.click();
                    URL.revokeObjectURL(url);
                }
            } else {
                alert('Download not supported in this environment');
            }
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>