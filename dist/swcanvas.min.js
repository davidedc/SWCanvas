!function(){"use strict";class t{constructor(t,e,r,i=255,n=!1){if(t<0||t>255||e<0||e>255||r<0||r>255||i<0||i>255)throw new Error("Color components must be in range 0-255");if(n)this._r=Math.round(t),this._g=Math.round(e),this._b=Math.round(r),this._a=Math.round(i);else{const n=i/255;this._r=Math.round(t*n),this._g=Math.round(e*n),this._b=Math.round(r*n),this._a=Math.round(i)}}static transparent(){return new t(0,0,0,0)}get premultipliedR(){return this._r}get premultipliedG(){return this._g}get premultipliedB(){return this._b}get premultipliedA(){return this._a}get r(){return 0===this._a?0:255===this._a?this._r:Math.round(255*this._r/this._a)}get g(){return 0===this._a?0:255===this._a?this._g:Math.round(255*this._g/this._a)}get b(){return 0===this._a?0:255===this._a?this._b:Math.round(255*this._b/this._a)}get a(){return this._a}toRGBA(){return[this.r,this.g,this.b,this.a]}toPremultipliedRGBA(){return[this._r,this._g,this._b,this._a]}get normalizedAlpha(){return this._a/255}get isTransparent(){return 0===this._a}get isOpaque(){return 255===this._a}withGlobalAlpha(e){if(e<0||e>1)throw new Error("Global alpha must be in range 0-1");const r=this.r,i=this.g,n=this.b,s=this.a,a=Math.round(s*e);return new t(r,i,n,a,!1)}blendOver(e){if(255===this._a)return this;if(0===this._a)return e;const r=1-this.normalizedAlpha,i=Math.round(this._r+e._r*r),n=Math.round(this._g+e._g*r),s=Math.round(this._b+e._b*r),a=Math.round(this._a+e._a*r);return new t(i,n,s,a,!0)}toBMP(){return{r:this.r,g:this.g,b:this.b}}toString(){return`Color(${this.r}, ${this.g}, ${this.b}, ${this.a})`}equals(e){return e instanceof t&&this._r===e._r&&this._g===e._g&&this._b===e._b&&this._a===e._a}}class e{constructor(t,e){if("number"!=typeof t||"number"!=typeof e)throw new Error("Point coordinates must be numbers");if(!isFinite(t)||!isFinite(e))throw new Error("Point coordinates must be finite numbers");this._x=t,this._y=e,Object.freeze(this)}get x(){return this._x}get y(){return this._y}static from(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Object must have numeric x and y properties");return new e(t.x,t.y)}distanceTo(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");const r=this._x-t._x,i=this._y-t._y;return Math.sqrt(r*r+i*i)}translate(t,r){return new e(this._x+t,this._y+r)}add(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return new e(this._x+t._x,this._y+t._y)}subtract(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return new e(this._x-t._x,this._y-t._y)}scale(t){if("number"!=typeof t)throw new Error("Scale factor must be a number");return new e(this._x*t,this._y*t)}scaleXY(t,r){if("number"!=typeof t||"number"!=typeof r)throw new Error("Scale factors must be numbers");return new e(this._x*t,this._y*r)}rotate(t){if("number"!=typeof t)throw new Error("Angle must be a number");const r=Math.cos(t),i=Math.sin(t);return new e(this._x*r-this._y*i,this._x*i+this._y*r)}rotateAround(t,r){if(!(t instanceof e))throw new Error("Center must be a Point instance");return this.subtract(t).rotate(r).add(t)}get magnitude(){return Math.sqrt(this._x*this._x+this._y*this._y)}get magnitudeSquared(){return this._x*this._x+this._y*this._y}normalize(){const t=this.magnitude;return 0===t?new e(0,0):new e(this._x/t,this._y/t)}dot(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return this._x*t._x+this._y*t._y}cross(t){if(!(t instanceof e))throw new Error("Argument must be a Point instance");return this._x*t._y-this._y*t._x}round(){return new e(Math.round(this._x),Math.round(this._y))}floor(){return new e(Math.floor(this._x),Math.floor(this._y))}ceil(){return new e(Math.ceil(this._x),Math.ceil(this._y))}clamp(t,r,i,n){return new e(Math.max(t,Math.min(i,this._x)),Math.max(r,Math.min(n,this._y)))}lerp(t,r){if(!(t instanceof e))throw new Error("Target must be a Point instance");if("number"!=typeof r||r<0||r>1)throw new Error("Interpolation factor must be between 0 and 1");return new e(this._x+(t._x-this._x)*r,this._y+(t._y-this._y)*r)}toObject(){return{x:this._x,y:this._y}}toArray(){return[this._x,this._y]}equals(t,r=1e-10){return t instanceof e&&Math.abs(this._x-t._x)<r&&Math.abs(this._y-t._y)<r}isOrigin(t=1e-10){return Math.abs(this._x)<t&&Math.abs(this._y)<t}toString(){return`Point(${this._x}, ${this._y})`}}class r{constructor(t,e,r,i){if("number"!=typeof t||"number"!=typeof e||"number"!=typeof r||"number"!=typeof i)throw new Error("Rectangle parameters must be numbers");if(!(isFinite(t)&&isFinite(e)&&isFinite(r)&&isFinite(i)))throw new Error("Rectangle parameters must be finite numbers");if(r<0||i<0)throw new Error("Rectangle dimensions must be non-negative");this._x=t,this._y=e,this._width=r,this._height=i,Object.freeze(this)}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this._x}get top(){return this._y}get right(){return this._x+this._width}get bottom(){return this._y+this._height}static boundingBox(t){if(!Array.isArray(t))throw new Error("Points must be an array");if(0===t.length)return new r(0,0,0,0);for(const r of t)if(!(r instanceof e))throw new Error("All items must be Point instances");let i=1/0,n=1/0,s=-1/0,a=-1/0;for(const e of t)i=Math.min(i,e.x),n=Math.min(n,e.y),s=Math.max(s,e.x),a=Math.max(a,e.y);return new r(i,n,s-i,a-n)}get center(){return new e(this._x+this._width/2,this._y+this._height/2)}get area(){return this._width*this._height}get perimeter(){return 2*(this._width+this._height)}get isEmpty(){return 0===this._width||0===this._height}get isSquare(){return this._width===this._height&&this._width>0}toString(){return`Rectangle(${this._x}, ${this._y}, ${this._width}, ${this._height})`}}class i{constructor(t){if(t&&Array.isArray(t)&&6===t.length){for(let e=0;e<6;e++)if("number"!=typeof t[e]||!isFinite(t[e]))throw new Error(`Transform2D component ${e} must be a finite number`);this.a=t[0],this.b=t[1],this.c=t[2],this.d=t[3],this.e=t[4],this.f=t[5]}else{if(t&&void 0!==t.length)throw new Error("Transform2D initialization array must have exactly 6 elements");this.a=1,this.b=0,this.c=0,this.d=1,this.e=0,this.f=0}Object.freeze(this)}static translation(t,e){return new i([1,0,0,1,t,e])}static scaling(t,e){return new i([t,0,0,e,0,0])}static rotation(t){const e=Math.cos(t),r=Math.sin(t);return new i([e,r,-r,e,0,0])}multiply(t){if(!(t instanceof i))throw new Error("Can only multiply with another Transform2D");return new i([this.a*t.a+this.b*t.c,this.a*t.b+this.b*t.d,this.c*t.a+this.d*t.c,this.c*t.b+this.d*t.d,this.e*t.a+this.f*t.c+t.e,this.e*t.b+this.f*t.d+t.f])}translate(t,e){const r=i.translation(t,e);return this.multiply(r)}scale(t,e){const r=i.scaling(t,e);return this.multiply(r)}rotate(t){const e=i.rotation(t);return this.multiply(e)}invert(){const t=this.a*this.d-this.b*this.c;if(Math.abs(t)<1e-10)throw new Error("Transform2D matrix is not invertible (determinant ≈ 0)");return new i([this.d/t,-this.b/t,-this.c/t,this.a/t,(this.c*this.f-this.d*this.e)/t,(this.b*this.e-this.a*this.f)/t])}transformPoint(t){if(!t||"number"!=typeof t.x||"number"!=typeof t.y)throw new Error("Point must have numeric x and y properties");return{x:this.a*t.x+this.c*t.y+this.e,y:this.b*t.x+this.d*t.y+this.f}}transformPoints(t){return t.map(t=>this.transformPoint(t))}toArray(){return[this.a,this.b,this.c,this.d,this.e,this.f]}get isIdentity(){return 1===this.a&&0===this.b&&0===this.c&&1===this.d&&0===this.e&&0===this.f}get determinant(){return this.a*this.d-this.b*this.c}equals(t,e=1e-10){return t instanceof i&&Math.abs(this.a-t.a)<e&&Math.abs(this.b-t.b)<e&&Math.abs(this.c-t.c)<e&&Math.abs(this.d-t.d)<e&&Math.abs(this.e-t.e)<e&&Math.abs(this.f-t.f)<e}toString(){return`Transform2D([${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e}, ${this.f}])`}}class n{constructor(){this.commands=[]}closePath(){this.commands.push({type:"closePath"})}moveTo(t,e){this.commands.push({type:"moveTo",x:t,y:e})}lineTo(t,e){this.commands.push({type:"lineTo",x:t,y:e})}bezierCurveTo(t,e,r,i,n,s){this.commands.push({type:"bezierCurveTo",cp1x:t,cp1y:e,cp2x:r,cp2y:i,x:n,y:s})}quadraticCurveTo(t,e,r,i){this.commands.push({type:"quadraticCurveTo",cpx:t,cpy:e,x:r,y:i})}rect(t,e,r,i){this.moveTo(t,e),this.lineTo(t+r,e),this.lineTo(t+r,e+i),this.lineTo(t,e+i),this.closePath()}arc(t,e,r,i,n,s){this.commands.push({type:"arc",x:t,y:e,radius:r,startAngle:i,endAngle:n,counterclockwise:!!s})}ellipse(t,e,r,i,n,s,a,o){this.commands.push({type:"ellipse",x:t,y:e,radiusX:r,radiusY:i,rotation:n,startAngle:s,endAngle:a,counterclockwise:!!o})}}class s{constructor(t,e){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("Surface width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("Surface height must be a positive integer");if(t*e>268435456)throw new Error("SurfaceTooLarge");const r=16384;if(t>r||e>r)throw new Error("Surface dimensions must be ≤ 16384x16384");Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1}),Object.defineProperty(this,"stride",{value:4*t,writable:!1}),this.data=new Uint8ClampedArray(this.stride*e)}clone(){const t=new s(this.width,this.height);return t.data.set(this.data),t}getPixel(e,r){if(e<0||e>=this.width||r<0||r>=this.height)return null;const i=r*this.stride+4*e;return new t(this.data[i],this.data[i+1],this.data[i+2],this.data[i+3],!1)}setPixel(e,r,i){if(e<0||e>=this.width||r<0||r>=this.height)return;if(!(i instanceof t))throw new Error("Color must be a Color instance");const n=r*this.stride+4*e;this.data[n]=i.r,this.data[n+1]=i.g,this.data[n+2]=i.b,this.data[n+3]=i.a}clear(e=t.transparent()){if(!(e instanceof t))throw new Error("Color must be a Color instance");const r=e.toRGBA();for(let t=0;t<this.data.length;t+=4)this.data[t]=r[0],this.data[t+1]=r[1],this.data[t+2]=r[2],this.data[t+3]=r[3]}getMemoryUsage(){return this.data.byteLength}toString(){const t=(this.getMemoryUsage()/1048576).toFixed(2);return`Surface(${this.width}×${this.height}, ${t}MB)`}}class a{static blendPixel(t,e,r,i,n,s,o,h,l){if(0===n)switch(t){case"destination-out":default:return{r:s,g:o,b:h,a:l};case"destination-atop":case"source-in":case"destination-in":return{r:0,g:0,b:0,a:0}}if(0===l)switch(t){case"source-over":case"destination-over":case"destination-atop":case"source-out":case"xor":case"copy":default:return{r:e,g:r,b:i,a:n};case"source-atop":case"destination-out":case"source-in":case"destination-in":return{r:0,g:0,b:0,a:0}}const c=n/255,u=l/255;let g,f,d,_;switch(t){case"source-over":default:return a._sourceOver(e,r,i,n,s,o,h,l);case"destination-over":return a._sourceOver(s,o,h,l,e,r,i,n);case"source-atop":if(_=l,0===l)return{r:0,g:0,b:0,a:0};g=Math.round(c*e+(1-c)*s),f=Math.round(c*r+(1-c)*o),d=Math.round(c*i+(1-c)*h);break;case"destination-atop":if(_=n,0===n)return{r:0,g:0,b:0,a:0};g=Math.round(u*s+(1-u)*e),f=Math.round(u*o+(1-u)*r),d=Math.round(u*h+(1-u)*i);break;case"source-in":if(_=Math.round(n*u),0===_)return{r:0,g:0,b:0,a:0};g=e,f=r,d=i;break;case"destination-in":if(_=Math.round(l*c),0===_)return{r:0,g:0,b:0,a:0};g=s,f=o,d=h;break;case"source-out":if(_=Math.round(n*(1-u)),0===_)return{r:0,g:0,b:0,a:0};g=e,f=r,d=i;break;case"destination-out":if(_=Math.round(l*(1-c)),0===_)return{r:0,g:0,b:0,a:0};g=s,f=o,d=h;break;case"xor":const t=c*(1-u),b=u*(1-c);if(_=Math.round(n*(1-u)+l*(1-c)),0===_)return{r:0,g:0,b:0,a:0};const m=t+b;if(0===m)return{r:0,g:0,b:0,a:0};const p=t/m,y=b/m;g=Math.round(e*p+s*y),f=Math.round(r*p+o*y),d=Math.round(i*p+h*y);break;case"copy":return{r:e,g:r,b:i,a:n}}return{r:Math.max(0,Math.min(255,Math.round(g))),g:Math.max(0,Math.min(255,Math.round(f))),b:Math.max(0,Math.min(255,Math.round(d))),a:Math.max(0,Math.min(255,Math.round(_)))}}static _sourceOver(t,e,r,i,n,s,a,o){if(255===i)return{r:t,g:e,b:r,a:i};const h=i/255,l=1-h;return{r:Math.round(t*h+n*l),g:Math.round(e*h+s*l),b:Math.round(r*h+a*l),a:Math.round(i+o*l)}}static getSupportedOperations(){return["source-over","destination-over","source-atop","destination-atop","source-in","destination-in","source-out","destination-out","xor","copy"]}static isSupported(t){return a.getSupportedOperations().includes(t)}}class o{static encode(t){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");const e=t.width,r=t.height,i=t.data,n=e*r*4;if(i.length!==n)throw new Error(`Surface data size mismatch. Expected ${n}, got ${i.length}`);const s=o._calculateDimensions(e,r),a=new ArrayBuffer(s.fileSize),h=new DataView(a),l=new Uint8Array(a);return o._writeBMPHeaders(h,s),o._writePixelData(l,i,t,s),a}static _calculateDimensions(t,e){const r=4*Math.floor((3*t+3)/4),i=r*e;return{width:t,height:e,rowSize:r,imageSize:i,fileSize:o.BMP_HEADER_SIZE+i}}static _writeBMPHeaders(t,e){o._writeBMPFileHeader(t,e.fileSize),o._writeBMPInfoHeader(t,e)}static _writeBMPFileHeader(t,e){const r=new Uint8Array(t.buffer);r[0]=66,r[1]=77,t.setUint32(2,e,!0),t.setUint32(6,0,!0),t.setUint32(10,o.BMP_HEADER_SIZE,!0)}static _writeBMPInfoHeader(t,e){t.setUint32(14,40,!0),t.setInt32(18,e.width,!0),t.setInt32(22,-e.height,!0),t.setUint16(26,1,!0),t.setUint16(28,24,!0),t.setUint32(30,0,!0),t.setUint32(34,e.imageSize,!0);t.setInt32(38,2835,!0),t.setInt32(42,2835,!0),t.setUint32(46,0,!0),t.setUint32(50,0,!0)}static _writePixelData(t,e,r,i){let n=o.BMP_HEADER_SIZE;for(let s=0;s<i.height;s++){let a=n;for(let n=0;n<i.width;n++){const i=s*r.stride+4*n,h=e[i],l=e[i+1],c=e[i+2],u=e[i+3],g=o._unpremultiplyAlpha(h,l,c,u);t[a]=g.b,t[a+1]=g.g,t[a+2]=g.r,a+=3}for(;a-n<i.rowSize;)t[a]=0,a++;n+=i.rowSize}}static _unpremultiplyAlpha(t,e,r,i){return 0===i?{r:0,g:0,b:0}:255===i?{r:t,g:e,b:r}:{r:Math.round(255*t/i),g:Math.round(255*e/i),b:Math.round(255*r/i)}}static getBMPInfo(t){if(!t||!t.width||!t.height)throw new Error("Invalid surface");const e=o._calculateDimensions(t.width,t.height);return{width:e.width,height:e.height,bitsPerPixel:24,compression:"None",rowSize:e.rowSize,imageSize:e.imageSize,fileSize:e.fileSize,headerSize:o.BMP_HEADER_SIZE}}static canEncode(t){try{if(!t||"object"!=typeof t)return!1;if(!t.width||!t.height||!t.data)return!1;if(t.width<=0||t.height<=0)return!1;if(t.width>o.MAX_DIMENSION||t.height>o.MAX_DIMENSION)return!1;const e=t.width*t.height*4;return t.data.length===e}catch(t){return!1}}static calculateMemoryUsage(t,e){if(t<=0||e<=0)return 0;return o._calculateDimensions(t,e).fileSize}}o.BMP_HEADER_SIZE=54,o.MAX_DIMENSION=65535;class h{static flattenPath(t){const r=[];let i=[],n=new e(0,0),s=new e(0,0);for(const a of t.commands)switch(a.type){case"moveTo":h._handleMoveTo(a,r,i),n=new e(a.x,a.y),s=new e(a.x,a.y),i=[n.toObject()];break;case"lineTo":n=new e(a.x,a.y),i.push(n.toObject());break;case"closePath":h._handleClosePath(i,s,r),i=[];break;case"quadraticCurveTo":const t=h._flattenQuadraticBezier(n.x,n.y,a.cpx,a.cpy,a.x,a.y);h._appendPoints(i,t,1),n=new e(a.x,a.y);break;case"bezierCurveTo":const o=h._flattenCubicBezier(n.x,n.y,a.cp1x,a.cp1y,a.cp2x,a.cp2y,a.x,a.y);h._appendPoints(i,o,1),n=new e(a.x,a.y);break;case"arc":const l=h._handleArc(a,i,n,s);n=l.currentPoint,i=l.currentPoly,l.subpathStart&&(s=l.subpathStart);break;case"ellipse":const c=h._flattenEllipse(a.x,a.y,a.radiusX,a.radiusY,a.rotation,a.startAngle,a.endAngle,a.counterclockwise);h._handleEllipsePoints(c,i,n),c.length>0&&(n=new e(c[c.length-1].x,c[c.length-1].y))}return i.length>0&&r.push(i),r}static _handleMoveTo(t,e,r){r.length>0&&e.push(r)}static _handleClosePath(t,e,r){if(t.length>0){const i=t[t.length-1];i.x===e.x&&i.y===e.y||t.push(e.toObject()),r.push(t)}}static _appendPoints(t,e,r){for(let i=r;i<e.length;i++)t.push(e[i])}static _handleArc(t,r,i,n){const s=h._flattenArc(t.x,t.y,t.radius,t.startAngle,t.endAngle,t.counterclockwise);if(0===s.length)return{currentPoint:i,currentPoly:r,subpathStart:null};const a=new e(s[0].x,s[0].y);if(0===r.length){r.push(a.toObject());const t=a,i=a;return h._appendPoints(r,s,1),{currentPoint:s.length>1?new e(s[s.length-1].x,s[s.length-1].y):t,currentPoly:r,subpathStart:i}}return i.distanceTo(a)>.01&&r.push(a.toObject()),h._appendPoints(r,s,1),{currentPoint:new e(s[s.length-1].x,s[s.length-1].y),currentPoly:r,subpathStart:null}}static _handleEllipsePoints(t,r,i){if(t.length>0){const n=new e(t[0].x,t[0].y);i.distanceTo(n)>.01&&r.push(n.toObject()),h._appendPoints(r,t,1)}}static _flattenQuadraticBezier(t,e,r,i,n,s){const a=[{x:t,y:e}];return h._flattenQuadraticBezierRecursive(t,e,r,i,n,s,a,h.TOLERANCE),a}static _flattenQuadraticBezierRecursive(t,e,r,i,n,s,a,o){const l=n-t,c=s-e;if(Math.abs((r-t)*c-(i-e)*l)/Math.sqrt(l*l+c*c)<=o||a.length>1e3)return void a.push({x:n,y:s});const u=(t+r)/2,g=(e+i)/2,f=(r+n)/2,d=(i+s)/2,_=(u+f)/2,b=(g+d)/2;h._flattenQuadraticBezierRecursive(t,e,u,g,_,b,a,o),h._flattenQuadraticBezierRecursive(_,b,f,d,n,s,a,o)}static _flattenCubicBezier(t,e,r,i,n,s,a,o){const l=[{x:t,y:e}];return h._flattenCubicBezierRecursive(t,e,r,i,n,s,a,o,l,h.TOLERANCE),l}static _flattenCubicBezierRecursive(t,e,r,i,n,s,a,o,l,c){const u=a-t,g=o-e,f=Math.sqrt(u*u+g*g);if(0===f)return void l.push({x:a,y:o});if(Math.abs((r-t)*g-(i-e)*u)/f+Math.abs((n-t)*g-(s-e)*u)/f<=c||l.length>1e3)return void l.push({x:a,y:o});const d=(t+r)/2,_=(e+i)/2,b=(r+n)/2,m=(i+s)/2,p=(n+a)/2,y=(s+o)/2,w=(d+b)/2,x=(_+m)/2,M=(b+p)/2,P=(m+y)/2,S=(w+M)/2,C=(x+P)/2;h._flattenCubicBezierRecursive(t,e,d,_,w,x,S,C,l,c),h._flattenCubicBezierRecursive(S,C,M,P,p,y,a,o,l,c)}static _flattenArc(t,e,r,i,n,s){if(r<=0)return[];let a=i,o=n;!s&&o<a?o+=2*Math.PI:s&&a<o&&(a+=2*Math.PI);const l=Math.abs(o-a),c=2*Math.acos(Math.max(0,1-h.TOLERANCE/r)),u=Math.max(1,Math.ceil(l/c)),g=[],f=(o-a)/u;for(let i=0;i<=u;i++){const n=a+i*f;g.push({x:t+r*Math.cos(n),y:e+r*Math.sin(n)})}return g}static _flattenEllipse(t,e,r,i,n,s,a,o){if(r<=0||i<=0)return[];let l=s,c=a;!o&&c<l?c+=2*Math.PI:o&&l<c&&(l+=2*Math.PI);const u=Math.abs(c-l),g=Math.min(r,i),f=2*Math.acos(Math.max(0,1-h.TOLERANCE/g)),d=Math.max(1,Math.ceil(u/f)),_=[],b=(c-l)/d,m=Math.cos(n),p=Math.sin(n);for(let n=0;n<=d;n++){const s=l+n*b,a=r*Math.cos(s),o=i*Math.sin(s);_.push({x:t+a*m-o*p,y:e+a*p+o*m})}return _}}h.TOLERANCE=.25;class l{static fillPolygons(t,e,r,i,n,s,a=1,o=1,h="source-over"){if(0===e.length)return;if(!l._isValidPaintSource(r))throw new Error("Paint source must be a Color, Gradient, or Pattern instance");const c=e.map(t=>t.map(t=>n.transformPoint(t))),u=l._calculateBounds(c,t);for(let e=u.minY;e<=u.maxY;e++)l._fillScanline(t,e,c,r,i,s,n,a,o,h)}static _calculateBounds(t,e){let r=1/0,i=-1/0;for(const e of t)for(const t of e)r=Math.min(r,t.y),i=Math.max(i,t.y);return{minY:Math.max(0,Math.floor(r)),maxY:Math.min(e.height-1,Math.ceil(i))}}static _fillScanline(t,e,r,i,n,s,a,o,h=1,c="source-over"){const u=[];for(const t of r)l._findPolygonIntersections(t,e+.5,u);u.sort((t,e)=>t.x-e.x),l._fillSpans(t,e,u,i,n,s,a,o,h,c)}static _findPolygonIntersections(t,e,r){for(let i=0;i<t.length;i++){const n=t[i],s=t[(i+1)%t.length];if(Math.abs(n.y-s.y)<1e-10)continue;const a=Math.min(n.y,s.y),o=Math.max(n.y,s.y);if(e>=a&&e<o){const t=(e-n.y)/(s.y-n.y),i=n.x+t*(s.x-n.x),a=s.y>n.y?1:-1;r.push({x:i,winding:a})}}}static _fillSpans(t,e,r,i,n,s,a,o,h=1,c="source-over"){if(0===r.length)return;let u=0,g=!1;for(let f=0;f<r.length;f++){const d=r[f],_=r[f+1];if(u+=d.winding,g="evenodd"===n?u%2!=0:0!==u,g&&_){const r=Math.max(0,Math.ceil(d.x)),n=Math.min(t.width-1,Math.floor(_.x));l._fillPixelSpan(t,e,r,n,i,s,a,o,h,c)}}}static _fillPixelSpan(t,e,r,i,n,s,a,o,h=1,c="source-over"){for(let u=r;u<=i;u++){if(s&&s.isPixelClipped(u,e))continue;const r=l._evaluatePaintSource(n,u,e,a,o,h),i=e*t.stride+4*u;l._blendPixel(t,i,r,c)}}static _blendPixel(t,e,r,i="source-over"){const n=t.data[e],s=t.data[e+1],o=t.data[e+2],h=t.data[e+3],l=a.blendPixel(i,r.r,r.g,r.b,r.a,n,s,o,h);t.data[e]=l.r,t.data[e+1]=l.g,t.data[e+2]=l.b,t.data[e+3]=l.a}static colorFromRGBA(e){return new t(e[0],e[1],e[2],e[3],!1)}static getPolygonBounds(t){if(0===t.length)return new r(0,0,0,0);const i=t.flat();return r.boundingBox(i.map(t=>new e(t.x,t.y)))}static countVertices(t){return t.reduce((t,e)=>t+e.length,0)}static _isValidPaintSource(e){return e instanceof t||e instanceof d||e instanceof _||e instanceof b||e instanceof m||e instanceof p}static _evaluatePaintSource(e,r,i,n,s,a=1){let o;o=e instanceof t?e:e instanceof d||e instanceof _||e instanceof b||e instanceof m||e instanceof p?e.getColorForPixel(r,i,n):new t(0,0,0,0);let h=o.withGlobalAlpha(s);if(a<1){const e=Math.round(h.a*a);h=new t(h.r,h.g,h.b,e,h.premultiplied)}return h}}class c{static generateStrokePolygons(t,e){const r=c._validateStrokeProperties(e);if(r.lineWidth<=0)return[];const i=h.flattenPath(t),n=c._applyDashPattern(i,r),s=[];for(const t of n){if(t.length<2)continue;const e=c._generateStrokeForPolygon(t,r);s.push(...e)}return s}static _validateStrokeProperties(t){const e={lineWidth:1,lineJoin:"miter",lineCap:"butt",miterLimit:10,lineDash:[],lineDashOffset:0,...t};if(e.lineWidth<0)throw new Error("lineWidth must not be negative");if(!["miter","round","bevel"].includes(e.lineJoin))throw new Error(`Invalid lineJoin: ${e.lineJoin}`);if(!["butt","round","square"].includes(e.lineCap))throw new Error(`Invalid lineCap: ${e.lineCap}`);if(e.miterLimit<=0)throw new Error("miterLimit must be positive");return e}static _applyDashPattern(t,e){if(!e.lineDash||0===e.lineDash.length)return t;const r=[];for(const i of t){if(i.length<2)continue;const t=c._dashPolygon(i,e.lineDash,e.lineDashOffset);r.push(...t)}return r}static _dashPolygon(t,e,r){if(t.length<2)return[];const i=[],n=e.reduce((t,e)=>t+e,0);if(n<=0)return[t];let s=r%n;s<0&&(s+=n);let a=s,o=0,h=!0,l=0;for(let t=0;t<e.length;t++){if(l+e[t]>s){o=t,a=s-l,h=t%2==0;break}l+=e[t]}let u=[];for(let r=0;r<t.length-1;r++){const n=t[r],s=t[r+1],l=Math.sqrt(Math.pow(s.x-n.x,2)+Math.pow(s.y-n.y,2));if(0===l)continue;const g=c._processSegmentWithDash(n,s,l,e,o,a,h,u,i);o=g.patternIndex,a=g.patternPosition,h=g.isDash,u=g.currentSegment}return u.length>1&&i.push(u),i}static _processSegmentWithDash(t,e,r,i,n,s,a,o,h){let l=r,c=t;for(a&&0===o.length&&o.push({x:t.x,y:t.y});l>0;){const u=i[n],g=u-s,f=Math.min(l,g),d=(r-l+f)/r,_={x:t.x+d*(e.x-t.x),y:t.y+d*(e.y-t.y)};a&&o.push({x:_.x,y:_.y}),l-=f,(s+=f)>=u&&(a&&o.length>1&&(h.push(o),o=[]),n=(n+1)%i.length,s=0,(a=!a)&&l>0&&(o=[{x:_.x,y:_.y}])),c=_}return{patternIndex:n,patternPosition:s,isDash:a,currentSegment:o}}static _generateStrokeForPolygon(t,e){if(t.length<2)return[];const r=[],i=e.lineWidth/2,n=c._isPathClosed(t),s=c._generateSegments(t,i);if(0===s.length)return[];for(const t of s)r.push(t.body);return c._generateJoins(s,r,e,n),!n&&s.length>0&&c._generateCaps(s,r,e,i),r}static _isPathClosed(t){return t.length>2&&Math.abs(t[0].x-t[t.length-1].x)<1e-10&&Math.abs(t[0].y-t[t.length-1].y)<1e-10}static _generateSegments(t,r){const i=[];for(let n=0;n<t.length-1;n++){const s=new e(t[n].x,t[n].y),a=new e(t[n+1].x,t[n+1].y),o=s.distanceTo(a);if(o<1e-10)continue;const h=c._createSegment(s,a,r,o);i.push(h)}return i}static _createSegment(t,r,i,n){const s=r.subtract(t).scale(1/n),a=new e(-s.y,s.x);return{body:[t.add(a.scale(i)).toObject(),r.add(a.scale(i)).toObject(),r.add(a.scale(-i)).toObject(),t.add(a.scale(-i)).toObject()],p1:t,p2:r,tangent:s,normal:a,length:n}}static _generateJoins(t,e,r,i){for(let i=0;i<t.length-1;i++){const n=t[i],s=t[i+1],a=c._generateJoin(n,s,r);e.push(...a)}if(i&&t.length>1){const i=t[t.length-1],n=t[0],s=c._generateJoin(i,n,r);e.push(...s)}}static _generateJoin(t,e,r){const i=e.p1,n=t.tangent.cross(e.tangent);if(Math.abs(n)<1e-10)return c._generateBevelJoin(t,e,i);switch(r.lineJoin){case"miter":return c._generateMiterJoin(t,e,i,r.miterLimit);case"round":return c._generateRoundJoin(t,e,i);default:return c._generateBevelJoin(t,e,i)}}static _generateMiterJoin(t,e,r,i){const n=Math.sqrt(Math.pow(t.body[0].x-t.body[3].x,2)+Math.pow(t.body[0].y-t.body[3].y,2))/2,s=t.tangent.cross(e.tangent);let a,o;s>0?(a=t.body[2],o=e.body[3]):(a=t.body[1],o=e.body[0]);const h={x:a.x+100*t.tangent.x,y:a.y+100*t.tangent.y},l={x:o.x-100*e.tangent.x,y:o.y-100*e.tangent.y},u=c._lineIntersection(a,h,o,l);if(!u)return c._generateBevelJoin(t,e,r);if(Math.sqrt(Math.pow(u.x-r.x,2)+Math.pow(u.y-r.y,2))/n>i)return c._generateBevelJoin(t,e,r);let g,f;return s>0?(g=t.body[1],f=e.body[0]):(g=t.body[2],f=e.body[3]),[[a,u,o],[a,o,f,g]]}static _generateBevelJoin(t,e,r){const i=t.tangent.cross(e.tangent),n=c._getOuterSides(t,e,i),s=c._getInnerSides(t,e,i);return[[n.outer1,n.outer2,s.inner2,s.inner1]]}static _generateRoundJoin(t,e,r){const i=Math.sqrt(Math.pow(t.body[0].x-t.body[3].x,2)+Math.pow(t.body[0].y-t.body[3].y,2))/2;let n,s;t.tangent.cross(e.tangent)>0?(n=t.body[2],s=e.body[3]):(n=t.body[1],s=e.body[0]);let a=Math.atan2(n.y-r.y,n.x-r.x),o=Math.atan2(s.y-r.y,s.x-r.x),h=o-a;if(h>Math.PI?h-=2*Math.PI:h<-Math.PI&&(h+=2*Math.PI),h<0){const t=a;a=o,o=t,h=-h}const l=Math.max(2,Math.ceil(h/(Math.PI/4))),c=h/l,u=[];for(let t=0;t<l;t++){const e=a+t*c,n=a+(t+1)*c,s={x:r.x+i*Math.cos(e),y:r.y+i*Math.sin(e)},o={x:r.x+i*Math.cos(n),y:r.y+i*Math.sin(n)};u.push([r.toObject(),s,o])}return u}static _generateCaps(t,e,r,i){const n=c._generateCap(t[0].p1,t[0].tangent,i,r.lineCap,!0);n&&e.push(...Array.isArray(n[0])?n:[n]);const s=t[t.length-1],a=c._generateCap(s.p2,s.tangent,i,r.lineCap,!1);a&&e.push(...Array.isArray(a[0])?a:[a])}static _generateCap(t,r,i,n,s){const a=new e(-r.y,r.x);switch(n){case"square":return c._generateSquareCap(t,r,a,i,s);case"round":return c._generateRoundCap(t,a,i,s);default:return null}}static _generateSquareCap(t,e,r,i,n){const s=n?t.subtract(e.scale(i)):t.add(e.scale(i));return[[s.add(r.scale(i)).toObject(),s.subtract(r.scale(i)).toObject(),t.subtract(r.scale(i)).toObject(),t.add(r.scale(i)).toObject()]]}static _generateRoundCap(t,e,r,i){const n=Math.atan2(e.y,e.x);return c._generateArcFan(t,r,n,n+Math.PI*(i?1:-1))}static _getOuterSides(t,e,r){return r>0?{outer1:t.body[2],outer2:e.body[3]}:{outer1:t.body[1],outer2:e.body[0]}}static _getInnerSides(t,e,r){return r>0?{inner1:t.body[1],inner2:e.body[0]}:{inner1:t.body[2],inner2:e.body[3]}}static _lineIntersection(t,e,r,i){const n=(t.x-e.x)*(r.y-i.y)-(t.y-e.y)*(r.x-i.x);if(Math.abs(n)<1e-10)return null;const s=((t.x-r.x)*(r.y-i.y)-(t.y-r.y)*(r.x-i.x))/n;return{x:t.x+s*(e.x-t.x),y:t.y+s*(e.y-t.y)}}static _generateArcFan(t,e,r,i){let n=i-r;for(;n>Math.PI;)n-=2*Math.PI;for(;n<-Math.PI;)n+=2*Math.PI;const s=Math.abs(n),a=Math.max(2,Math.ceil(s/(Math.PI/4))),o=n/a,h=[];for(let i=0;i<a;i++){const n=r+i*o,s=r+(i+1)*o,a={x:t.x+e*Math.cos(n),y:t.y+e*Math.sin(n)},l={x:t.x+e*Math.cos(s),y:t.y+e*Math.sin(s)};h.push([t.toObject(),a,l])}return h}}class u{constructor(t,e){if("number"!=typeof t||!Number.isInteger(t)||t<=0)throw new Error("ClipMask width must be a positive integer");if("number"!=typeof e||!Number.isInteger(e)||e<=0)throw new Error("ClipMask height must be a positive integer");this._width=t,this._height=e,this._numPixels=t*e,this._numBytes=Math.ceil(this._numPixels/8),this._buffer=new Uint8Array(this._numBytes),this._initializeNoClipping(),Object.defineProperty(this,"width",{value:t,writable:!1}),Object.defineProperty(this,"height",{value:e,writable:!1})}_initializeNoClipping(){this._buffer.fill(255);const t=this._numPixels%8;if(0!==t){const e=this._numBytes-1,r=(1<<t)-1;this._buffer[e]=r}}getPixel(t,e){if(t<0||t>=this._width||e<0||e>=this._height)return!1;const r=e*this._width+t;return 1===this._getBit(r)}setPixel(t,e,r){if(t<0||t>=this._width||e<0||e>=this._height)return;const i=e*this._width+t;this._setBit(i,r?1:0)}isPixelClipped(t,e){return!this.getPixel(t,e)}clear(){this._initializeNoClipping()}clipAll(){this._buffer.fill(0)}intersectWith(t){if(!(t instanceof u))throw new Error("Argument must be a ClipMask instance");if(t._width!==this._width||t._height!==this._height)throw new Error("ClipMask dimensions must match for intersection");for(let e=0;e<this._numBytes;e++)this._buffer[e]&=t._buffer[e]}clone(){const t=new u(this._width,this._height);return t._buffer.set(this._buffer),t}createPixelWriter(){return(t,e,r)=>{if(t<0||t>=this._width||e<0||e>=this._height)return;const i=r>.5;this.setPixel(t,e,i)}}getMemoryUsage(){return this._buffer.byteLength}hasClipping(){for(let t=0;t<this._numBytes-1;t++)if(255!==this._buffer[t])return!0;const t=this._numPixels%8;if(0===t)return 255!==this._buffer[this._numBytes-1];{const e=(1<<t)-1;return this._buffer[this._numBytes-1]!==e}}_getBit(t){const e=Math.floor(t/8),r=t%8;return e>=this._buffer.length?0:this._buffer[e]&1<<r?1:0}_setBit(t,e){const r=Math.floor(t/8),i=t%8;r>=this._buffer.length||(e?this._buffer[r]|=1<<i:this._buffer[r]&=~(1<<i))}toString(){const t=(this.getMemoryUsage()/1024).toFixed(2),e=this.hasClipping()?"with clipping":"no clipping";return`ClipMask(${this._width}×${this._height}, ${t}KB, ${e})`}equals(t){if(!(t instanceof u))return!1;if(t._width!==this._width||t._height!==this._height)return!1;for(let e=0;e<this._numBytes;e++)if(this._buffer[e]!==t._buffer[e])return!1;return!0}}class g{static validateAndConvert(t){g._validateImageLike(t);const e=t.width*t.height*3,r=t.width*t.height*4;if(t.data.length===e)return g._convertRGBToRGBA(t);if(t.data.length===r)return{width:t.width,height:t.height,data:t.data};throw new Error(`ImageLike data length (${t.data.length}) must match width*height*3 (${e}) for RGB or width*height*4 (${r}) for RGBA`)}static _validateImageLike(t){if(!t||"object"!=typeof t)throw new Error("ImageLike must be an object");if("number"!=typeof t.width||t.width<=0||!Number.isInteger(t.width))throw new Error("ImageLike width must be a positive integer");if("number"!=typeof t.height||t.height<=0||!Number.isInteger(t.height))throw new Error("ImageLike height must be a positive integer");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageLike data must be a Uint8ClampedArray");const e=16384;if(t.width>e||t.height>e)throw new Error("ImageLike dimensions must be ≤ 16384x16384")}static _convertRGBToRGBA(t){const e=t.width*t.height*4,r=new Uint8ClampedArray(e);for(let e=0;e<t.width*t.height;e++){const i=3*e,n=4*e;r[n]=t.data[i],r[n+1]=t.data[i+1],r[n+2]=t.data[i+2],r[n+3]=255}return{width:t.width,height:t.height,data:r}}static surfaceToImageLike(t){if(!t||"object"!=typeof t)throw new Error("Surface must be a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");return{width:t.width,height:t.height,data:new Uint8ClampedArray(t.data)}}static createBlankImage(e,r,i=[0,0,0,255]){if(!Number.isInteger(e)||!Number.isInteger(r)||e<=0||r<=0)throw new Error("Width and height must be positive integers");const n=e*r,s=new Uint8ClampedArray(4*n);let a,o,h,l;if(i instanceof t){const t=i.toRGBA();a=t[0],o=t[1],h=t[2],l=t[3]}else{if(!(Array.isArray(i)&&i.length>=4))throw new Error("fillColor must be a Color instance or RGBA array");a=i[0],o=i[1],h=i[2],l=i[3]}for(let t=0;t<n;t++){const e=4*t;s[e]=a,s[e+1]=o,s[e+2]=h,s[e+3]=l}return{width:e,height:r,data:s}}static extractRegion(t,e,r,i,n){const s=g.validateAndConvert(t);if(e<0||r<0||e+i>s.width||r+n>s.height)throw new Error("Extraction region exceeds source image bounds");if(i<=0||n<=0)throw new Error("Extraction region dimensions must be positive");const a=new Uint8ClampedArray(i*n*4);for(let t=0;t<n;t++){const n=4*((r+t)*s.width+e),o=t*i*4,h=4*i;a.set(s.data.subarray(n,n+h),o)}return{width:i,height:n,data:a}}static scaleImage(t,e,r){const i=g.validateAndConvert(t);if(!Number.isInteger(e)||!Number.isInteger(r)||e<=0||r<=0)throw new Error("Target dimensions must be positive integers");const n=new Uint8ClampedArray(e*r*4),s=i.width/e,a=i.height/r;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const o=Math.floor(r*s),h=Math.floor(t*a),l=Math.min(o,i.width-1),c=4*(Math.min(h,i.height-1)*i.width+l),u=4*(t*e+r);n[u]=i.data[c],n[u+1]=i.data[c+1],n[u+2]=i.data[c+2],n[u+3]=i.data[c+3]}return{width:e,height:r,data:n}}static isImageLike(t){try{g._validateImageLike(t);const e=t.width*t.height*3,r=t.width*t.height*4;return t.data.length===e||t.data.length===r}catch(t){return!1}}static getImageInfo(t){const e=g.validateAndConvert(t),r=t.data.length===t.width*t.height*3;return{width:e.width,height:e.height,pixelCount:e.width*e.height,format:r?"RGB":"RGBA",dataSize:e.data.length,bytesPerPixel:r?3:4,memoryUsage:e.data.byteLength}}static fromCanvas(t){if(!t||"object"!=typeof t)throw new Error("Canvas must be a valid HTMLCanvasElement");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("Canvas must have numeric width and height");if(!t.getContext||"function"!=typeof t.getContext)throw new Error("Canvas must have getContext method");try{const e=t.getContext("2d").getImageData(0,0,t.width,t.height);return{width:t.width,height:t.height,data:new Uint8ClampedArray(e.data)}}catch(t){throw new Error(`Failed to extract canvas data: ${t.message}`)}}}class f{constructor(){this._cache=new Map,this._namedColors={black:{r:0,g:0,b:0},silver:{r:192,g:192,b:192},gray:{r:128,g:128,b:128},white:{r:255,g:255,b:255},maroon:{r:128,g:0,b:0},red:{r:255,g:0,b:0},purple:{r:128,g:0,b:128},fuchsia:{r:255,g:0,b:255},green:{r:0,g:128,b:0},lime:{r:0,g:255,b:0},olive:{r:128,g:128,b:0},yellow:{r:255,g:255,b:0},navy:{r:0,g:0,b:128},blue:{r:0,g:0,b:255},teal:{r:0,g:128,b:128},aqua:{r:0,g:255,b:255},aliceblue:{r:240,g:248,b:255},antiquewhite:{r:250,g:235,b:215},aquamarine:{r:127,g:255,b:212},azure:{r:240,g:255,b:255},beige:{r:245,g:245,b:220},bisque:{r:255,g:228,b:196},blanchedalmond:{r:255,g:235,b:205},blueviolet:{r:138,g:43,b:226},brown:{r:165,g:42,b:42},burlywood:{r:222,g:184,b:135},cadetblue:{r:95,g:158,b:160},chartreuse:{r:127,g:255,b:0},chocolate:{r:210,g:105,b:30},coral:{r:255,g:127,b:80},cornflowerblue:{r:100,g:149,b:237},cornsilk:{r:255,g:248,b:220},crimson:{r:220,g:20,b:60},cyan:{r:0,g:255,b:255},darkblue:{r:0,g:0,b:139},darkcyan:{r:0,g:139,b:139},darkgoldenrod:{r:184,g:134,b:11},darkgray:{r:169,g:169,b:169},darkgreen:{r:0,g:100,b:0},darkgrey:{r:169,g:169,b:169},darkkhaki:{r:189,g:183,b:107},darkmagenta:{r:139,g:0,b:139},darkolivegreen:{r:85,g:107,b:47},darkorange:{r:255,g:140,b:0},darkorchid:{r:153,g:50,b:204},darkred:{r:139,g:0,b:0},darksalmon:{r:233,g:150,b:122},darkseagreen:{r:143,g:188,b:143},darkslateblue:{r:72,g:61,b:139},darkslategray:{r:47,g:79,b:79},darkslategrey:{r:47,g:79,b:79},darkturquoise:{r:0,g:206,b:209},darkviolet:{r:148,g:0,b:211},deeppink:{r:255,g:20,b:147},deepskyblue:{r:0,g:191,b:255},dimgray:{r:105,g:105,b:105},dimgrey:{r:105,g:105,b:105},dodgerblue:{r:30,g:144,b:255},firebrick:{r:178,g:34,b:34},floralwhite:{r:255,g:250,b:240},forestgreen:{r:34,g:139,b:34},gainsboro:{r:220,g:220,b:220},ghostwhite:{r:248,g:248,b:255},gold:{r:255,g:215,b:0},goldenrod:{r:218,g:165,b:32},grey:{r:128,g:128,b:128},greenyellow:{r:173,g:255,b:47},honeydew:{r:240,g:255,b:240},hotpink:{r:255,g:105,b:180},indianred:{r:205,g:92,b:92},indigo:{r:75,g:0,b:130},ivory:{r:255,g:255,b:240},khaki:{r:240,g:230,b:140},lavender:{r:230,g:230,b:250},lavenderblush:{r:255,g:240,b:245},lawngreen:{r:124,g:252,b:0},lemonchiffon:{r:255,g:250,b:205},lightblue:{r:173,g:216,b:230},lightcoral:{r:240,g:128,b:128},lightcyan:{r:224,g:255,b:255},lightgoldenrodyellow:{r:250,g:250,b:210},lightgray:{r:211,g:211,b:211},lightgreen:{r:144,g:238,b:144},lightgrey:{r:211,g:211,b:211},lightpink:{r:255,g:182,b:193},lightsalmon:{r:255,g:160,b:122},lightseagreen:{r:32,g:178,b:170},lightskyblue:{r:135,g:206,b:250},lightslategray:{r:119,g:136,b:153},lightslategrey:{r:119,g:136,b:153},lightsteelblue:{r:176,g:196,b:222},lightyellow:{r:255,g:255,b:224},limegreen:{r:50,g:205,b:50},linen:{r:250,g:240,b:230},magenta:{r:255,g:0,b:255},mediumaquamarine:{r:102,g:205,b:170},mediumblue:{r:0,g:0,b:205},mediumorchid:{r:186,g:85,b:211},mediumpurple:{r:147,g:112,b:219},mediumseagreen:{r:60,g:179,b:113},mediumslateblue:{r:123,g:104,b:238},mediumspringgreen:{r:0,g:250,b:154},mediumturquoise:{r:72,g:209,b:204},mediumvioletred:{r:199,g:21,b:133},midnightblue:{r:25,g:25,b:112},mintcream:{r:245,g:255,b:250},mistyrose:{r:255,g:228,b:225},moccasin:{r:255,g:228,b:181},navajowhite:{r:255,g:222,b:173},oldlace:{r:253,g:245,b:230},olivedrab:{r:107,g:142,b:35},orange:{r:255,g:165,b:0},orangered:{r:255,g:69,b:0},orchid:{r:218,g:112,b:214},palegoldenrod:{r:238,g:232,b:170},palegreen:{r:152,g:251,b:152},paleturquoise:{r:175,g:238,b:238},palevioletred:{r:219,g:112,b:147},papayawhip:{r:255,g:239,b:213},peachpuff:{r:255,g:218,b:185},peru:{r:205,g:133,b:63},pink:{r:255,g:192,b:203},plum:{r:221,g:160,b:221},powderblue:{r:176,g:224,b:230},rebeccapurple:{r:102,g:51,b:153},rosybrown:{r:188,g:143,b:143},royalblue:{r:65,g:105,b:225},saddlebrown:{r:139,g:69,b:19},salmon:{r:250,g:128,b:114},sandybrown:{r:244,g:164,b:96},seagreen:{r:46,g:139,b:87},seashell:{r:255,g:245,b:238},sienna:{r:160,g:82,b:45},skyblue:{r:135,g:206,b:235},slateblue:{r:106,g:90,b:205},slategray:{r:112,g:128,b:144},slategrey:{r:112,g:128,b:144},snow:{r:255,g:250,b:250},springgreen:{r:0,g:255,b:127},steelblue:{r:70,g:130,b:180},tan:{r:210,g:180,b:140},thistle:{r:216,g:191,b:216},tomato:{r:255,g:99,b:71},turquoise:{r:64,g:224,b:208},violet:{r:238,g:130,b:238},wheat:{r:245,g:222,b:179},whitesmoke:{r:245,g:245,b:245},yellowgreen:{r:154,g:205,b:50}}}parse(t){if(this._cache.has(t))return this._cache.get(t);let e;if("string"!=typeof t)e={r:0,g:0,b:0,a:255};else{const r=t.trim().toLowerCase();if(r.startsWith("#"))e=this._parseHex(r);else if(r.startsWith("rgb"))e=this._parseRGB(r);else if(this._namedColors[r]){const t=this._namedColors[r];e={r:t.r,g:t.g,b:t.b,a:255}}else e={r:0,g:0,b:0,a:255}}return this._cache.set(t,e),e}_parseHex(t){if(3===(t=t.substring(1)).length&&(t=t.split("").map(t=>t+t).join("")),6===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:255}}if(8===t.length){return{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16),a:parseInt(t.substring(6,8),16)}}return{r:0,g:0,b:0,a:255}}_parseRGB(t){const e=t.match(/rgba?\s*\(\s*([^)]+)\s*\)/);if(!e)return{r:0,g:0,b:0,a:255};const r=e[1].split(",").map(t=>t.trim());if(r.length<3)return{r:0,g:0,b:0,a:255};const i=Math.max(0,Math.min(255,parseInt(r[0])||0)),n=Math.max(0,Math.min(255,parseInt(r[1])||0)),s=Math.max(0,Math.min(255,parseInt(r[2])||0));let a=255;if(r.length>=4){const t=parseFloat(r[3]);isNaN(t)||(a=Math.max(0,Math.min(255,Math.round(255*t))))}return{r:i,g:n,b:s,a:a}}clearCache(){this._cache.clear()}}class d{constructor(){this._colorStops=[],this._sorted=!1}addColorStop(e,r){if("number"!=typeof e||!isFinite(e))throw new Error("Color stop offset must be a finite number");if(e<0||e>1)throw new Error("Color stop offset must be between 0 and 1");const i=(new f).parse(r),n=new t(i.r,i.g,i.b,i.a);this._colorStops.push({offset:e,color:n}),this._sorted=!1}_getSortedColorStops(){return this._sorted||(this._colorStops.sort((t,e)=>t.offset-e.offset),this._sorted=!0),this._colorStops}_getColorAt(e){const r=this._getSortedColorStops();if(0===r.length)return new t(0,0,0,0);if(1===r.length)return r[0].color;if(e<=r[0].offset)return r[0].color;if(e>=r[r.length-1].offset)return r[r.length-1].color;for(let i=0;i<r.length-1;i++){const n=r[i],s=r[i+1];if(e>=n.offset&&e<=s.offset){const r=s.offset-n.offset;if(0===r)return n.color;const i=(e-n.offset)/r,a=n.color.r,o=n.color.g,h=n.color.b,l=n.color.a,c=s.color.r,u=s.color.g,g=s.color.b,f=s.color.a,d=Math.round(a+(c-a)*i),_=Math.round(o+(u-o)*i),b=Math.round(h+(g-h)*i),m=Math.round(l+(f-l)*i);return new t(d,_,b,m)}}return r[0].color}getColorForPixel(t,e,r){throw new Error("getColorForPixel must be implemented by subclass")}}class _ extends d{constructor(t,e,r,i){super(),this._x0=t,this._y0=e,this._x1=r,this._y1=i,this._dx=r-t,this._dy=i-e,this._lengthSquared=this._dx*this._dx+this._dy*this._dy}getColorForPixel(t,r,i){const n=i.transformPoint(new e(this._x0,this._y0)),s=i.transformPoint(new e(this._x1,this._y1)),a=s.x-n.x,o=s.y-n.y,h=a*a+o*o;if(0===h)return this._getColorAt(0);const l=((t-n.x)*a+(r-n.y)*o)/h;return this._getColorAt(l)}}class b extends d{constructor(t,e,r,i,n,s){if(super(),r<0||s<0)throw new Error("Radial gradient radii must be non-negative");if(t===i&&e===n&&r===s)throw new Error("Radial gradient circles must not be identical");this._x0=t,this._y0=e,this._r0=r,this._x1=i,this._y1=n,this._r1=s}getColorForPixel(t,r,i){const n=i.transformPoint(new e(this._x0,this._y0)),s=i.transformPoint(new e(this._x1,this._y1)),a=Math.sqrt((t-n.x)**2+(r-n.y)**2),o=Math.sqrt((t-s.x)**2+(r-s.y)**2),h=Math.sqrt((s.x-n.x)**2+(s.y-n.y)**2)+this._r1;let l;return l=a<=this._r0?0:o>=this._r1?1:(a-this._r0)/(h-this._r0),this._getColorAt(Math.max(0,Math.min(1,l)))}}class m extends d{constructor(t,e,r){super(),this._angle=t,this._x=e,this._y=r}getColorForPixel(t,r,i){const n=i.transformPoint(new e(this._x,this._y));let s=Math.atan2(r-n.y,t-n.x)-this._angle;for(;s<0;)s+=2*Math.PI;for(;s>=2*Math.PI;)s-=2*Math.PI;const a=s/(2*Math.PI);return this._getColorAt(a)}}class p{constructor(t,e="repeat"){this._imageData=g.validateAndConvert(t);const r=["repeat","repeat-x","repeat-y","no-repeat"];if(!r.includes(e))throw new Error(`Invalid repetition mode: ${e}. Must be one of: ${r.join(", ")}`);this._repetition=e,this._patternTransform=new i,Object.freeze(this)}setTransform(t){if(t instanceof i){const e=Object.create(Object.getPrototypeOf(this));return e._imageData=this._imageData,e._repetition=this._repetition,e._patternTransform=t,Object.freeze(e),e}if(t&&"number"==typeof t.a){const e=new i([t.a,t.b,t.c,t.d,t.e,t.f]);return this.setTransform(e)}throw new Error("Pattern transform must be a Transform2D or DOMMatrix-like object")}getColorForPixel(r,i,n){try{const t=n.multiply(this._patternTransform),s=t.invert().transformPoint(new e(r,i));return this._samplePattern(s.x,s.y)}catch(e){return new t(0,0,0,0)}}_samplePattern(e,r){const i=this._imageData.width,n=this._imageData.height;let s,a;switch(this._repetition){case"repeat":s=this._repeatCoordinate(e,i),a=this._repeatCoordinate(r,n);break;case"repeat-x":if(s=this._repeatCoordinate(e,i),a=r,r<0||r>=n)return new t(0,0,0,0);break;case"repeat-y":if(s=e,a=this._repeatCoordinate(r,n),e<0||e>=i)return new t(0,0,0,0);break;case"no-repeat":if(s=e,a=r,e<0||e>=i||r<0||r>=n)return new t(0,0,0,0)}const o=Math.floor(s),h=Math.floor(a),l=Math.max(0,Math.min(i-1,o)),c=4*(Math.max(0,Math.min(n-1,h))*i+l),u=this._imageData.data[c],g=this._imageData.data[c+1],f=this._imageData.data[c+2],d=this._imageData.data[c+3];return new t(u,g,f,d)}_repeatCoordinate(t,e){if(0===e)return 0;let r=t%e;return r<0&&(r+=e),r}getDimensions(){return{width:this._imageData.width,height:this._imageData.height}}getRepetition(){return this._repetition}getTransform(){return this._patternTransform}static fromSurface(t,e="repeat"){const r=g.surfaceToImageLike(t);return new p(r,e)}static createSolid(t,e,r,i="repeat"){const n=g.createBlankImage(t,e,r);return new p(n,i)}}class y{constructor(t){if(!t||"object"!=typeof t)throw new Error("Rasterizer requires a valid Surface object");if(!t.width||!t.height||!t.data)throw new Error("Surface must have width, height, and data properties");this._surface=t,this._currentOp=null}get surface(){return this._surface}get currentOp(){return this._currentOp}beginOp(t={}){this._validateParams(t),this._currentOp={composite:t.composite||"source-over",globalAlpha:void 0!==t.globalAlpha?t.globalAlpha:1,transform:t.transform||new i,clipMask:t.clipMask||null,fillStyle:t.fillStyle||null,strokeStyle:t.strokeStyle||null}}endOp(){this._currentOp=null}_validateParams(t){if(void 0!==t.globalAlpha&&("number"!=typeof t.globalAlpha||t.globalAlpha<0||t.globalAlpha>1))throw new Error("globalAlpha must be a number between 0 and 1");if(t.composite&&!a.isSupported(t.composite))throw new Error(`Invalid composite operation. Supported: ${a.getSupportedOperations().join(", ")}`);if(t.transform&&!(t.transform instanceof i))throw new Error("transform must be a Transform2D instance")}_requireActiveOp(){if(!this._currentOp)throw new Error("Must call beginOp() before drawing operations")}_isPixelClipped(t,e){return!!this._currentOp?.clipMask&&this._currentOp.clipMask.isPixelClipped(t,e)}fillRect(e,r,i,s,a){if(this._requireActiveOp(),"number"!=typeof e||"number"!=typeof r||"number"!=typeof i||"number"!=typeof s)throw new Error("Rectangle coordinates must be numbers");if(i<0||s<0)throw new Error("Rectangle dimensions must be non-negative");if(0===i||0===s)return;if(this._currentOp.clipMask){const t=new n;return t.rect(e,r,i,s),void this.fill(t,"nonzero")}const o=this._currentOp.transform,h=o.transformPoint({x:e,y:r}),c=o.transformPoint({x:e+i,y:r}),u=o.transformPoint({x:e,y:r+s}),g=o.transformPoint({x:e+i,y:r+s}),f=Math.max(0,Math.floor(Math.min(h.x,c.x,u.x,g.x))),d=Math.min(this._surface.width-1,Math.floor(Math.max(h.x,c.x,u.x,g.x)-1)),_=Math.max(0,Math.floor(Math.min(h.y,c.y,u.y,g.y))),b=Math.min(this._surface.height-1,Math.floor(Math.max(h.y,c.y,u.y,g.y)-1));if(0===this._currentOp.transform.b&&0===this._currentOp.transform.c&&(a instanceof t||Array.isArray(a)))this._fillAxisAlignedRect(f,_,d-f+1,b-_+1,a);else{const n=[{x:e,y:r},{x:e+i,y:r},{x:e+i,y:r+s},{x:e,y:r+s}],o=Array.isArray(a)?new t(a[0],a[1],a[2],a[3]):a;l.fillPolygons(this._surface,[n],o,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite)}}_fillAxisAlignedRect(e,r,i,n,s){const o=this._surface,h=this._currentOp.globalAlpha,l=(Array.isArray(s)?new t(s[0],s[1],s[2],s[3]):s).withGlobalAlpha(h),c=l.r,u=l.g,g=l.b,f=l.a;for(let t=r;t<r+n;t++)if(!(t<0||t>=o.height))for(let r=e;r<e+i;r++){if(r<0||r>=o.width)continue;if(this._currentOp.clipMask&&this._isPixelClipped(r,t))continue;const e=t*o.stride+4*r,i=o.data[e],n=o.data[e+1],s=o.data[e+2],h=o.data[e+3],l=a.blendPixel(this._currentOp.composite,c,u,g,f,i,n,s,h);o.data[e]=l.r,o.data[e+1]=l.g,o.data[e+2]=l.b,o.data[e+3]=l.a}}fill(e,r){this._requireActiveOp();const i=this._currentOp.fillStyle||new t(0,0,0,255),n=r||"nonzero",s=h.flattenPath(e);l.fillPolygons(this._surface,s,i,n,this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,1,this._currentOp.composite)}stroke(e,r){this._requireActiveOp();const i=this._currentOp.strokeStyle||new t(0,0,0,255);let n=r,s=1;r.lineWidth<=1&&(s=0===r.lineWidth?1:r.lineWidth,n={...r,lineWidth:1});const a=c.generateStrokePolygons(e,n);l.fillPolygons(this._surface,a,i,"nonzero",this._currentOp.transform,this._currentOp.clipMask,this._currentOp.globalAlpha,s,this._currentOp.composite)}drawImage(t,e,r,i,n,s,o,h,l){this._requireActiveOp();const c=g.validateAndConvert(t);let u,f,d,_,b,m,p,y;if(3===arguments.length)u=0,f=0,d=c.width,_=c.height,b=e,m=r,p=d,y=_;else if(5===arguments.length)u=0,f=0,d=c.width,_=c.height,b=e,m=r,p=i,y=n;else{if(9!==arguments.length)throw new Error("Invalid number of arguments for drawImage");u=e,f=r,d=i,_=n,b=s,m=o,p=h,y=l}if(u<0||f<0||u+d>c.width||f+_>c.height)throw new Error("Source rectangle is outside image bounds");const w=this._currentOp.transform,x=w.transformPoint({x:b,y:m}),M=w.transformPoint({x:b+p,y:m}),P=w.transformPoint({x:b,y:m+y}),S=w.transformPoint({x:b+p,y:m+y}),C=Math.max(0,Math.floor(Math.min(x.x,M.x,P.x,S.x))),v=Math.min(this._surface.width-1,Math.ceil(Math.max(x.x,M.x,P.x,S.x))),k=Math.max(0,Math.floor(Math.min(x.y,M.y,P.y,S.y))),A=Math.min(this._surface.height-1,Math.ceil(Math.max(x.y,M.y,P.y,S.y))),E=w.invert(),O=this._currentOp.globalAlpha;for(let t=k;t<=A;t++)for(let e=C;e<=v;e++){if(this._currentOp.clipMask&&this._isPixelClipped(e,t))continue;const r=E.transformPoint({x:e,y:t});if(r.x<b||r.x>=b+p||r.y<m||r.y>=m+y)continue;const i=u+(r.x-b)/p*d,n=f+(r.y-m)/y*_,s=Math.floor(i),o=Math.floor(n);if(s<0||o<0||s>=c.width||o>=c.height)continue;const h=4*(o*c.width+s),l=c.data[h],g=c.data[h+1],w=c.data[h+2],x=c.data[h+3]/255*O,M=Math.round(255*x);if(0===M)continue;const P=t*this._surface.stride+4*e,S=this._surface.data[P],C=this._surface.data[P+1],v=this._surface.data[P+2],k=this._surface.data[P+3],A=a.blendPixel(this._currentOp.composite,l,g,w,M,S,C,v,k);this._surface.data[P]=A.r,this._surface.data[P+1]=A.g,this._surface.data[P+2]=A.b,this._surface.data[P+3]=A.a}}}class w{constructor(e){this.surface=e,this.rasterizer=new y(e),this.stateStack=[],this.globalAlpha=1,this.globalCompositeOperation="source-over",this._transform=new i,this._fillStyle=new t(0,0,0,255),this._strokeStyle=new t(0,0,0,255),this.lineWidth=1,this.lineJoin="miter",this.lineCap="butt",this.miterLimit=10,this._lineDash=[],this._originalLineDash=[],this._lineDashOffset=0,this._currentPath=new n,this._clipMask=null}save(){let t=null;this._clipMask&&(t=this._clipMask.clone()),this.stateStack.push({globalAlpha:this.globalAlpha,globalCompositeOperation:this.globalCompositeOperation,transform:new i([this._transform.a,this._transform.b,this._transform.c,this._transform.d,this._transform.e,this._transform.f]),fillStyle:this._fillStyle,strokeStyle:this._strokeStyle,clipMask:t,lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash.slice(),originalLineDash:this._originalLineDash.slice(),lineDashOffset:this._lineDashOffset})}restore(){if(0===this.stateStack.length)return;const t=this.stateStack.pop();this.globalAlpha=t.globalAlpha,this.globalCompositeOperation=t.globalCompositeOperation,this._transform=t.transform,this._fillStyle=t.fillStyle,this._strokeStyle=t.strokeStyle,this._clipMask=t.clipMask,this.lineWidth=t.lineWidth,this.lineJoin=t.lineJoin,this.lineCap=t.lineCap,this.miterLimit=t.miterLimit,this._lineDash=t.lineDash||[],this._originalLineDash=t.originalLineDash||[],this._lineDashOffset=t.lineDashOffset||0}transform(t,e,r,n,s,a){const o=new i([t,e,r,n,s,a]);this._transform=o.multiply(this._transform)}setTransform(t,e,r,n,s,a){this._transform=new i([t,e,r,n,s,a])}resetTransform(){this._transform=new i}translate(t,e){this._transform=(new i).translate(t,e).multiply(this._transform)}scale(t,e){this._transform=(new i).scale(t,e).multiply(this._transform)}rotate(t){this._transform=(new i).rotate(t).multiply(this._transform)}setFillStyle(e,r,i,n){1===arguments.length&&(e instanceof t||e instanceof d||e instanceof _||e instanceof b||e instanceof m||e instanceof p)?this._fillStyle=e:(n=void 0!==n?n:255,this._fillStyle=new t(e,r,i,n))}setStrokeStyle(e,r,i,n){1===arguments.length&&(e instanceof t||e instanceof d||e instanceof _||e instanceof b||e instanceof m||e instanceof p)?this._strokeStyle=e:(n=void 0!==n?n:255,this._strokeStyle=new t(e,r,i,n))}beginPath(){this._currentPath=new n}closePath(){this._currentPath.closePath()}moveTo(t,e){this._currentPath.moveTo(t,e)}lineTo(t,e){this._currentPath.lineTo(t,e)}rect(t,e,r,i){this._currentPath.rect(t,e,r,i)}arc(t,e,r,i,n,s){this._currentPath.arc(t,e,r,i,n,s)}quadraticCurveTo(t,e,r,i){this._currentPath.quadraticCurveTo(t,e,r,i)}bezierCurveTo(t,e,r,i,n,s){this._currentPath.bezierCurveTo(t,e,r,i,n,s)}fillRect(t,e,r,i){this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,fillStyle:this._fillStyle}),this.rasterizer.fillRect(t,e,r,i,this._fillStyle),this.rasterizer.endOp()}strokeRect(t,e,r,i){const s=new n;s.rect(t,e,r,i),s.closePath(),this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,strokeStyle:this._strokeStyle}),this.rasterizer.stroke(s,{lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit}),this.rasterizer.endOp()}clearRect(t,e,r,i){this.rasterizer.beginOp({composite:"copy",globalAlpha:1,transform:this._transform}),this.rasterizer.fillRect(t,e,r,i,[0,0,0,0]),this.rasterizer.endOp()}fill(t,e){let r,i;0===arguments.length?(r=this._currentPath,i="nonzero"):1===arguments.length?"string"==typeof t?(r=this._currentPath,i=t):(r=t,i="nonzero"):(r=t,i=e),i=i||"nonzero",this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,fillStyle:this._fillStyle}),this.rasterizer.fill(r,i),this.rasterizer.endOp()}stroke(t){const e=t||this._currentPath;this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:this._transform,clipMask:this._clipMask,strokeStyle:this._strokeStyle}),this.rasterizer.stroke(e,{lineWidth:this.lineWidth,lineJoin:this.lineJoin,lineCap:this.lineCap,miterLimit:this.miterLimit,lineDash:this._lineDash.slice(),lineDashOffset:this._lineDashOffset}),this.rasterizer.endOp()}clip(t,e){const r=t||this._currentPath,i=e||"nonzero",n=new u(this.surface.width,this.surface.height);n.clipAll();n.createPixelWriter();const s=this._fillStyle;this._fillStyle=[255,255,255,255];const a=h.flattenPath(r);this._fillPolygonsToClipBuffer(a,i,n),this._fillStyle=s,this._clipMask?this._clipMask.intersectWith(n):this._clipMask=n}_fillPolygonsToClipBuffer(t,e,r){if(0===t.length)return;const i=this.surface,n=t.map(t=>t.map(t=>this._transform.transformPoint(t)));let s=1/0,a=-1/0;for(const t of n)for(const e of t)s=Math.min(s,e.y),a=Math.max(a,e.y);s=Math.max(0,Math.floor(s)),a=Math.min(i.height-1,Math.ceil(a));for(let t=s;t<=a;t++){const i=[];for(const e of n)this._findPolygonIntersections(e,t+.5,i);i.sort((t,e)=>t.x-e.x),this._fillClipSpans(t,i,e,r)}}_findPolygonIntersections(t,e,r){for(let i=0;i<t.length;i++){const n=t[i],s=t[(i+1)%t.length];if(Math.abs(n.y-s.y)<1e-10)continue;const a=Math.min(n.y,s.y),o=Math.max(n.y,s.y);if(e>=a&&e<o){const t=(e-n.y)/(s.y-n.y),i=n.x+t*(s.x-n.x),a=s.y>n.y?1:-1;r.push({x:i,winding:a})}}}_fillClipSpans(t,e,r,i){if(0===e.length)return;let n=0,s=!1;for(let a=0;a<e.length;a++){const o=e[a],h=e[a+1];n+=o.winding;if(s="evenodd"===r?n%2!=0:0!==n,s&&h){const e=Math.max(0,Math.ceil(o.x)),r=Math.min(this.surface.width-1,Math.floor(h.x));for(let n=e;n<=r;n++)i.setPixel(n,t,!0)}}}drawImage(t,e,r,n,s,a,o,h,l){if("undefined"!=typeof console&&console.log,!t||"object"!=typeof t)throw new Error("First argument must be an ImageLike object");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("ImageLike must have numeric width and height properties");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageLike data must be a Uint8ClampedArray");this.rasterizer.beginOp({composite:this.globalCompositeOperation,globalAlpha:this.globalAlpha,transform:new i([this._transform.a,this._transform.b,this._transform.c,this._transform.d,this._transform.e,this._transform.f]),clipMask:this._clipMask}),this.rasterizer.drawImage.apply(this.rasterizer,arguments),this.rasterizer.endOp()}setLineDash(t){if(!Array.isArray(t))throw new Error("setLineDash expects an array");for(let e=0;e<t.length;e++){if("number"!=typeof t[e]||isNaN(t[e]))throw new Error("Dash segments must be numbers");if(t[e]<0)throw new Error("Dash segments must be non-negative")}this._originalLineDash=t.slice(),this._lineDash=t.slice(),this._lineDash.length%2==1&&(this._lineDash=this._lineDash.concat(this._lineDash))}getLineDash(){return this._originalLineDash.slice()}set lineDashOffset(t){"number"!=typeof t||isNaN(t)||(this._lineDashOffset=t)}get lineDashOffset(){return this._lineDashOffset}createLinearGradient(t,e,r,i){return new _(t,e,r,i)}createRadialGradient(t,e,r,i,n,s){return new b(t,e,r,i,n,s)}createConicGradient(t,e,r){return new m(t,e,r)}createPattern(t,e){return new p(t,e)}}class x{constructor(t){this._core=new w(t),this._colorParser=new f,this._fillStyle="#000000",this._strokeStyle="#000000"}_updateSurface(t){this._core=new w(t),this._applyFillStyle(),this._applyStrokeStyle()}get fillStyle(){return this._fillStyle}set fillStyle(t){this._fillStyle=t,this._applyFillStyle()}get strokeStyle(){return this._strokeStyle}set strokeStyle(t){this._strokeStyle=t,this._applyStrokeStyle()}_applyFillStyle(){if(this._fillStyle instanceof d||this._fillStyle instanceof _||this._fillStyle instanceof b||this._fillStyle instanceof m||this._fillStyle instanceof p)this._core.setFillStyle(this._fillStyle);else{const t=this._colorParser.parse(this._fillStyle);this._core.setFillStyle(t.r,t.g,t.b,t.a)}}_applyStrokeStyle(){if(this._strokeStyle instanceof d||this._strokeStyle instanceof _||this._strokeStyle instanceof b||this._strokeStyle instanceof m||this._strokeStyle instanceof p)this._core.setStrokeStyle(this._strokeStyle);else{const t=this._colorParser.parse(this._strokeStyle);this._core.setStrokeStyle(t.r,t.g,t.b,t.a)}}get globalAlpha(){return this._core.globalAlpha}set globalAlpha(t){this._core.globalAlpha=t}get globalCompositeOperation(){return this._core.globalCompositeOperation}set globalCompositeOperation(t){this._core.globalCompositeOperation=t}get lineWidth(){return this._core.lineWidth}set lineWidth(t){this._core.lineWidth=t}get lineJoin(){return this._core.lineJoin}set lineJoin(t){this._core.lineJoin=t}get lineCap(){return this._core.lineCap}set lineCap(t){this._core.lineCap=t}get miterLimit(){return this._core.miterLimit}set miterLimit(t){this._core.miterLimit=t}get lineDashOffset(){return this._core.lineDashOffset}set lineDashOffset(t){this._core.lineDashOffset=t}save(){this._core.save()}restore(){this._core.restore()}transform(t,e,r,i,n,s){this._core.transform(t,e,r,i,n,s)}setTransform(t,e,r,i,n,s){this._core.setTransform(t,e,r,i,n,s)}resetTransform(){this._core.resetTransform()}translate(t,e){this._core.translate(t,e)}scale(t,e){this._core.scale(t,e)}rotate(t){this._core.rotate(t)}beginPath(){this._core.beginPath()}closePath(){this._core.closePath()}moveTo(t,e){this._core.moveTo(t,e)}lineTo(t,e){this._core.lineTo(t,e)}rect(t,e,r,i){this._core.rect(t,e,r,i)}arc(t,e,r,i,n,s=!1){this._core.arc(t,e,r,i,n,s)}quadraticCurveTo(t,e,r,i){this._core.quadraticCurveTo(t,e,r,i)}bezierCurveTo(t,e,r,i,n,s){this._core.bezierCurveTo(t,e,r,i,n,s)}fillRect(t,e,r,i){this._core.fillRect(t,e,r,i)}strokeRect(t,e,r,i){this._core.strokeRect(t,e,r,i)}clearRect(t,e,r,i){this._core.clearRect(t,e,r,i)}fill(t,e){"string"==typeof t?this._core.fill(t):t&&t instanceof n?this._core.fill(t,e):this._core.fill()}stroke(t){t&&t instanceof n?this._core.stroke(t):this._core.stroke()}setLineDash(t){this._core.setLineDash(t)}getLineDash(){return this._core.getLineDash()}clip(t,e){"string"==typeof t?this._core.clip(t):t&&t instanceof n?this._core.clip(t,e):this._core.clip()}drawImage(t,...e){if("undefined"!=typeof console&&console.log,t&&t instanceof M)this._core.drawImage(t._imageData,...e);else if(t&&"object"==typeof t&&t.getContext&&"function"==typeof t.getContext){const r=t.getContext("2d").getImageData(0,0,t.width,t.height);this._core.drawImage(r,...e)}else t&&"object"==typeof t&&t.width&&t.height&&t.data,this._core.drawImage(t,...e)}createImageData(t,e){if("number"!=typeof t||t<=0||!Number.isInteger(t))throw new Error("Width must be a positive integer");if("number"!=typeof e||e<=0||!Number.isInteger(e))throw new Error("Height must be a positive integer");return{width:t,height:e,data:new Uint8ClampedArray(t*e*4)}}getImageData(t,e,r,i){if("number"!=typeof t||"number"!=typeof e)throw new Error("Coordinates must be numbers");if("number"!=typeof r||r<=0||!Number.isInteger(r))throw new Error("Width must be a positive integer");if("number"!=typeof i||i<=0||!Number.isInteger(i))throw new Error("Height must be a positive integer");const n=this.createImageData(r,i),s=this._core.surface;for(let a=0;a<i;a++){const i=Math.floor(e)+a,o=a;if(i>=0&&i<s.height)for(let e=0;e<r;e++){const a=Math.floor(t)+e,h=e;if(a>=0&&a<s.width){const t=i*s.stride+4*a,e=o*r*4+4*h;n.data[e]=s.data[t],n.data[e+1]=s.data[t+1],n.data[e+2]=s.data[t+2],n.data[e+3]=s.data[t+3]}}}return n}putImageData(t,e,r){if(!t||"object"!=typeof t)throw new Error("ImageData must be an object");if("number"!=typeof t.width||"number"!=typeof t.height)throw new Error("ImageData must have numeric width and height");if(!(t.data instanceof Uint8ClampedArray))throw new Error("ImageData data must be a Uint8ClampedArray");if("number"!=typeof e||"number"!=typeof r)throw new Error("Destination coordinates must be numbers");const i=this._core.surface;for(let n=0;n<t.height;n++){const s=Math.floor(r)+n,a=n;if(s>=0&&s<i.height)for(let r=0;r<t.width;r++){const n=Math.floor(e)+r,o=r;if(n>=0&&n<i.width){const e=s*i.stride+4*n,r=a*t.width*4+4*o;i.data[e]=t.data[r],i.data[e+1]=t.data[r+1],i.data[e+2]=t.data[r+2],i.data[e+3]=t.data[r+3]}}}}createLinearGradient(t,e,r,i){return this._core.createLinearGradient(t,e,r,i)}createRadialGradient(t,e,r,i,n,s){return this._core.createRadialGradient(t,e,r,i,n,s)}createConicGradient(t,e,r){return this._core.createConicGradient(t,e,r)}createPattern(t,e){return this._core.createPattern(t,e)}get _coreContext(){return this._core}}class M{constructor(t=300,e=150){this._width=t,this._height=e,this._surface=new s(t,e),this._context=null}get width(){return this._width}set width(t){const e=Math.max(1,Math.floor(t));e!==this._width&&(this._width=e,this._recreateSurface())}get height(){return this._height}set height(t){const e=Math.max(1,Math.floor(t));e!==this._height&&(this._height=e,this._recreateSurface())}getContext(t){if("2d"!==t)throw new Error("SWCanvas only supports 2d context");return this._context||(this._context=new x(this._surface)),this._context}_recreateSurface(){this._surface=new s(this._width,this._height),this._context&&this._context._updateSurface(this._surface)}get _coreSurface(){return this._surface}get _imageData(){return{width:this._width,height:this._height,data:this._surface.data}}get data(){return this._surface.data}toString(){return`[object SWCanvasElement(${this._width}x${this._height})]`}}function P(t=300,e=150){return new M(t,e)}function S(t,e){return new s(t,e)}function C(t,e){if("number"!=typeof t||t<=0||!Number.isInteger(t))throw new Error("Width must be a positive integer");if("number"!=typeof e||e<=0||!Number.isInteger(e))throw new Error("Height must be a positive integer");return{width:t,height:e,data:new Uint8ClampedArray(t*e*4)}}"undefined"!=typeof window?window.SWCanvas={createCanvas:P,createImageData:C,Core:{Surface:S,Context2D:w,Transform2D:i,Path2D:n,Color:t,Point:e,Rectangle:r,BitmapEncoder:o,ClipMask:u,ImageProcessor:g,CompositeOperations:a,Rasterizer:y,PathFlattener:h,PolygonFiller:l,StrokeGenerator:c,Gradient:d,LinearGradient:_,RadialGradient:b,ConicGradient:m,Pattern:p}}:"undefined"!=typeof module&&module.exports&&(module.exports={createCanvas:P,createImageData:C,Core:{Surface:S,Context2D:w,Transform2D:i,Path2D:n,Color:t,Point:e,Rectangle:r,BitmapEncoder:o,ClipMask:u,ImageProcessor:g,CompositeOperations:a,Rasterizer:y,PathFlattener:h,PolygonFiller:l,StrokeGenerator:c,Gradient:d,LinearGradient:_,RadialGradient:b,ConicGradient:m,Pattern:p}})}();
//# sourceMappingURL=swcanvas.min.js.map